
/****************************************************************************************************//**
 * @file     TZ10xx.h
 *
 * @brief    CMSIS Cortex-M4 Peripheral Access Layer Header File for
 *           TZ10xx from .
 *
 * @date     12. February 2015
 *
 * @note     Generated with SVDConv V2.83b 
 *           from CMSIS SVD File 'TZ10xx.svd' Version 0.1,
 *******************************************************************************************************/

/*
 * COPYRIGHT (C) 2014-2017
 * TOSHIBA CORPORATION STORAGE & ELECTRONIC DEVICES SOLUTIONS COMPANY
 *
 * Portions Copyright (C) 2013 Synopsys, Inc.  
 * Used with permission. All rights reserved. 
 * Synopsys & DesignWare are registered trademarks of Synopsys, Inc.
 *
 * This software is released under the MIT License.
 * http://opensource.org/licenses/mit-license.php
 */
/*
 * The register names included in the following "sdmac", "i2c2", "spim2" 
 * and "usb2fs" sections are Synopsys Proprietary. 
 * Used with permission.
 */



/** @addtogroup (null)
  * @{
  */

/** @addtogroup TZ10xx
  * @{
  */

#ifndef TZ10XX_H
#define TZ10XX_H

#ifdef __cplusplus
extern "C" {
#endif


/* -------------------------  Interrupt Number Definition  ------------------------ */

typedef enum {
/* -------------------  Cortex-M4 Processor Exceptions Numbers  ------------------- */
  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
  MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
                                                         and No Match                                                          */
  BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                         related Fault                                                         */
  UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
/* ----------------------  TZ10xx Specific Interrupt Numbers  --------------------- */
  GPIO_Pin0_IRQn                =   0,              /*!<   0  GPIO_Pin0                                                        */
  GPIO_Pin1_IRQn                =   1,              /*!<   1  GPIO_Pin1                                                        */
  GPIO_Pin2_IRQn                =   2,              /*!<   2  GPIO_Pin2                                                        */
  GPIO_Pin3_IRQn                =   3,              /*!<   3  GPIO_Pin3                                                        */
  GPIO_Pin4_IRQn                =   4,              /*!<   4  GPIO_Pin4                                                        */
  GPIO_Pin5_IRQn                =   5,              /*!<   5  GPIO_Pin5                                                        */
  GPIO_Pin6_IRQn                =   6,              /*!<   6  GPIO_Pin6                                                        */
  GPIO_Pin7_IRQn                =   7,              /*!<   7  GPIO_Pin7                                                        */
  GPIO_Pin8_IRQn                =   8,              /*!<   8  GPIO_Pin8                                                        */
  GPIO_Pin9_IRQn                =   9,              /*!<   9  GPIO_Pin9                                                        */
  GPIO_Pin10_IRQn               =  10,              /*!<  10  GPIO_Pin10                                                       */
  GPIO_Pin11_IRQn               =  11,              /*!<  11  GPIO_Pin11                                                       */
  GPIO_Pin12_IRQn               =  12,              /*!<  12  GPIO_Pin12                                                       */
  GPIO_Pin13_IRQn               =  13,              /*!<  13  GPIO_Pin13                                                       */
  GPIO_Pin14_IRQn               =  14,              /*!<  14  GPIO_Pin14                                                       */
  GPIO_Pin15_IRQn               =  15,              /*!<  15  GPIO_Pin15                                                       */
  GPIO_Pin16_IRQn               =  16,              /*!<  16  GPIO_Pin16                                                       */
  GPIO_Pin17_IRQn               =  17,              /*!<  17  GPIO_Pin17                                                       */
  GPIO_Pin18_IRQn               =  18,              /*!<  18  GPIO_Pin18                                                       */
  GPIO_Pin19_IRQn               =  19,              /*!<  19  GPIO_Pin19                                                       */
  GPIO_Pin20_IRQn               =  20,              /*!<  20  GPIO_Pin20                                                       */
  GPIO_Pin21_IRQn               =  21,              /*!<  21  GPIO_Pin21                                                       */
  GPIO_Pin22_IRQn               =  22,              /*!<  22  GPIO_Pin22                                                       */
  GPIO_Pin23_IRQn               =  23,              /*!<  23  GPIO_Pin23                                                       */
  GPIO_Pin24_IRQn               =  24,              /*!<  24  GPIO_Pin24                                                       */
  GPIO_Pin25_IRQn               =  25,              /*!<  25  GPIO_Pin25                                                       */
  GPIO_Pin26_IRQn               =  26,              /*!<  26  GPIO_Pin26                                                       */
  GPIO_Pin27_IRQn               =  27,              /*!<  27  GPIO_Pin27                                                       */
  GPIO_Pin28_IRQn               =  28,              /*!<  28  GPIO_Pin28                                                       */
  GPIO_Pin29_IRQn               =  29,              /*!<  29  GPIO_Pin29                                                       */
  GPIO_Pin30_IRQn               =  30,              /*!<  30  GPIO_Pin30                                                       */
  GPIO_Pin31_IRQn               =  31,              /*!<  31  GPIO_Pin31                                                       */
  SPIM0_IRQn                    =  32,              /*!<  32  SPIM0                                                            */
  SPIM1_IRQn                    =  33,              /*!<  33  SPIM1                                                            */
  SPIM2_IRQn                    =  34,              /*!<  34  SPIM2                                                            */
  SPIM3_IRQn                    =  35,              /*!<  35  SPIM3                                                            */
  I2C0_IRQn                     =  36,              /*!<  36  I2C0                                                             */
  I2C1_IRQn                     =  37,              /*!<  37  I2C1                                                             */
  I2C2_IRQn                     =  38,              /*!<  38  I2C2                                                             */
  RTC_IRQn                      =  39,              /*!<  39  RTC                                                              */
  UART0_IRQn                    =  40,              /*!<  40  UART0                                                            */
  UART1_IRQn                    =  41,              /*!<  41  UART1                                                            */
  UART2_IRQn                    =  42,              /*!<  42  UART2                                                            */
  USB_IRQn                      =  43,              /*!<  43  USB                                                              */
  SRAM_M2M_IRQn                 =  44,              /*!<  44  SRAM_M2M                                                         */
  SRAM_ERR_IRQn                 =  45,              /*!<  45  SRAM_ERR                                                         */
  SPIC_IRQn                     =  46,              /*!<  46  SPIC                                                             */
  SDMAC0_IRQn                   =  48,              /*!<  48  SDMAC0                                                           */
  SDMAC1_IRQn                   =  49,              /*!<  49  SDMAC1                                                           */
  SDMAC2_IRQn                   =  50,              /*!<  50  SDMAC2                                                           */
  SDMAC3_IRQn                   =  51,              /*!<  51  SDMAC3                                                           */
  SDMAC4_IRQn                   =  52,              /*!<  52  SDMAC4                                                           */
  SDMAC5_IRQn                   =  53,              /*!<  53  SDMAC5                                                           */
  SDMAC6_IRQn                   =  54,              /*!<  54  SDMAC6                                                           */
  SDMAC7_IRQn                   =  55,              /*!<  55  SDMAC7                                                           */
  ADCC12_IRQn                   =  56,              /*!<  56  ADCC12                                                           */
  ADCC24_IRQn                   =  57,              /*!<  57  ADCC24                                                           */
  WDT_IRQn                      =  59,              /*!<  59  WDT                                                              */
  TMR0_IRQn                     =  60,              /*!<  60  TMR0                                                             */
  TMR1_IRQn                     =  61,              /*!<  61  TMR1                                                             */
  ADVTMR0_IRQn                  =  64,              /*!<  64  ADVTMR0                                                          */
  ADVTMR1_IRQn                  =  65,              /*!<  65  ADVTMR1                                                          */
  ADVTMR2_IRQn                  =  66,              /*!<  66  ADVTMR2                                                          */
  ADVTMR3_IRQn                  =  67,              /*!<  67  ADVTMR3                                                          */
  ADVTMR0_CAP_IRQn              =  68,              /*!<  68  ADVTMR0_CAP                                                      */
  ADVTMR1_CAP_IRQn              =  69,              /*!<  69  ADVTMR1_CAP                                                      */
  ADVTMR2_CAP_IRQn              =  70,              /*!<  70  ADVTMR2_CAP                                                      */
  ADVTMR3_CAP_IRQn              =  71,              /*!<  71  ADVTMR3_CAP                                                      */
  ADVTMR0_CMP_IRQn              =  72,              /*!<  72  ADVTMR0_CMP                                                      */
  ADVTMR1_CMP_IRQn              =  73,              /*!<  73  ADVTMR1_CMP                                                      */
  ADVTMR2_CMP_IRQn              =  74,              /*!<  74  ADVTMR2_CMP                                                      */
  ADVTMR3_CMP_IRQn              =  75,              /*!<  75  ADVTMR3_CMP                                                      */
  PMU_WKUP_IRQn                 =  76,              /*!<  76  PMU_WKUP                                                         */
  BOR_IRQn                      =  77,              /*!<  77  BOR                                                              */
  FPU_IRQn                      =  79               /*!<  79  FPU                                                              */
} IRQn_Type;


/** @addtogroup Configuration_of_CMSIS
  * @{
  */


/* ================================================================================ */
/* ================      Processor and Core Peripheral Section     ================ */
/* ================================================================================ */

/* ----------------Configuration of the Cortex-M4 Processor and Core Peripherals---------------- */
#define __CM4_REV                  0x0001           /*!< Core revision r0p1                                                    */
#define __MPU_PRESENT                   1           /*!< MPU present or not                                                    */
#define __NVIC_PRIO_BITS                3           /*!< Number of Bits used for Priority Levels                               */
#define __Vendor_SysTickConfig          0           /*!< Set to 1 if different SysTick Config is used                          */
#define __FPU_PRESENT                   1           /*!< FPU present or not                                                    */
/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm4.h"                               /*!< Cortex-M4 processor and core peripherals                              */
#include "system_TZ10xx.h"                          /*!< TZ10xx System                                                         */


/* ================================================================================ */
/* ================       Device Specific Peripheral Section       ================ */
/* ================================================================================ */


/** @addtogroup Device_Peripheral_Registers
  * @{
  */


/* -------------------  Start of section using anonymous unions  ------------------ */
#if defined(__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined(__ICCARM__)
  #pragma language=extended
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
/* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning 586
#else
  #warning Not supported compiler type
#endif



/* ================================================================================ */
/* ================                      mpier                     ================ */
/* ================================================================================ */


/**
  * @brief mpier (mpier)
  */

typedef struct {                                    /*!< mpier Structure                                                       */
  __I  uint32_t  RESERVED0[16383];
  
  union {
    __I  uint32_t  BUS_BUSY;                        /*!< Bus busy flag for monitoring whether there are outstanding transactions
                                                         on APB buses.For detail of procedure for power mode transition
                                                          using this register, refer to Chapter 2. MCU Power Management
                                                          Unit.                                                                */
    
    struct {
      __I  uint32_t  APB0_BUSY  :  1;               /*!< APB0 bus busy (0x0 : IDLE, 0x1 : BUSY)                                */
      __I  uint32_t  APB1_BUSY  :  1;               /*!< APB1 bus busy (0x0 : IDLE, 0x1 : BUSY)                                */
      __I  uint32_t  APB2_BUSY  :  1;               /*!< APB2 bus busy (0x0 : IDLE, 0x1 : BUSY)                                */
      __I  uint32_t  APBM_BUSY  :  1;               /*!< APB bus for AESA, RNG, EVM, SRAMC register busy (0x0 : IDLE,
                                                         0x1 : BUSY)                                                           */
           uint32_t : 28; // padding
    } BUS_BUSY_b;                                   /*!< BitSize                                                               */
  };
} mpier_Type;


/* ================================================================================ */
/* ================                      pmulv                     ================ */
/* ================================================================================ */


/**
  * @brief pmulv (pmulv)
  */

typedef struct {                                    /*!< pmulv Structure                                                       */
  
  union {
    __IO uint32_t  CG_ON_POWERDOMAIN;               /*!< Clock gating ON (for each power supply domain)[Write]1: Clock
                                                         stops. 0: Ignored[Read]1: Clock is stopped. 0: Clock is being
                                                          supplied.* Writing also changes the values of associated individual
                                                          CG registers. (Example) If writing is done to the CG_PD field,
                                                          the values of the [CG_ON_PD] and [CG_OFF_PD] registers are also
                                                          changed.                                                             */
    
    struct {
      __IO uint32_t  CG_PM      :  1;               /*!< Batch control of clocks belonging to PM                               */
      __IO uint32_t  CG_PE      :  1;               /*!< Batch control of clocks belonging to PE                               */
      __IO uint32_t  CG_PS0     :  1;               /*!< Batch control of clocks belonging to PS0                              */
      __IO uint32_t  CG_PS1     :  1;               /*!< Batch control of clocks belonging to PS1                              */
      __IO uint32_t  CG_PS2     :  1;               /*!< Batch control of clocks belonging to PS2                              */
      __IO uint32_t  CG_PF      :  1;               /*!< Batch control of clocks belonging to PF                               */
           uint32_t             :  1;
      __IO uint32_t  CG_PD      :  1;               /*!< Batch control of clocks belonging to PD                               */
      __IO uint32_t  CG_PU      :  1;               /*!< Batch control of clocks belonging to PU                               */
      __IO uint32_t  CG_PA12    :  1;               /*!< Batch control of clocks belonging to PA12                             */
      __IO uint32_t  CG_PA24    :  1;               /*!< Batch control of clocks belonging to PA24                             */
      __IO uint32_t  CG_PP1     :  1;               /*!< Batch control of clocks belonging to PP1                              */
           uint32_t : 20; // padding
    } CG_ON_POWERDOMAIN_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_OFF_POWERDOMAIN;              /*!< Clock gating OFF (for each power supply domain)[Write]1: Clock
                                                         is supplied. 0: Ignored[Read]1: Clock is being supplied. 0:
                                                          Clock is stopped.* Writing also changes the values of associated
                                                          individual CG registers. (Example) If writing is done to the
                                                          CG_PD field, the values of the [CG_ON_PD] and [CG_OFF_PD] registers
                                                          are also changed.                                                    */
    
    struct {
      __IO uint32_t  CG_PM      :  1;               /*!< Batch control of clocks belonging to PM                               */
      __IO uint32_t  CG_PE      :  1;               /*!< Batch control of clocks belonging to PE                               */
      __IO uint32_t  CG_PS0     :  1;               /*!< Batch control of clocks belonging to PS0                              */
      __IO uint32_t  CG_PS1     :  1;               /*!< Batch control of clocks belonging to PS1                              */
      __IO uint32_t  CG_PS2     :  1;               /*!< Batch control of clocks belonging to PS2                              */
      __IO uint32_t  CG_PF      :  1;               /*!< Batch control of clocks belonging to PF                               */
           uint32_t             :  1;
      __IO uint32_t  CG_PD      :  1;               /*!< Batch control of clocks belonging to PD                               */
      __IO uint32_t  CG_PU      :  1;               /*!< Batch control of clocks belonging to PU                               */
      __IO uint32_t  CG_PA12    :  1;               /*!< Batch control of clocks belonging to PA12                             */
      __IO uint32_t  CG_PA24    :  1;               /*!< Batch control of clocks belonging to PA24                             */
      __IO uint32_t  CG_PP1     :  1;               /*!< Batch control of clocks belonging to PP1                              */
           uint32_t : 20; // padding
    } CG_OFF_POWERDOMAIN_b;                         /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[2];
  
  union {
    __IO uint32_t  DCG_POWERDOMAIN;                 /*!< Dynamic clock gating (for each power supply domain)[Write]1:
                                                         Dynamic clock gating enable. 0: Dynamic clock gating disable.[Read]
                                                          A configured value can be checked.* Writing also changes values
                                                          of associated individual DCG registers. (Example) If writing
                                                          is done to the DCG_PD field, the [DCG_PD] register value is
                                                          also changed.                                                        */
    
    struct {
      __IO uint32_t  DCG_PM     :  1;               /*!< Batch control of clocks belonging to PM                               */
      __IO uint32_t  DCG_PE     :  1;               /*!< Batch control of clocks belonging to PE                               */
      __IO uint32_t  DCG_PS0    :  1;               /*!< Batch control of clocks belonging to PS0                              */
      __IO uint32_t  DCG_PS1    :  1;               /*!< Batch control of clocks belonging to PS1                              */
      __IO uint32_t  DCG_PS2    :  1;               /*!< Batch control of clocks belonging to PS2                              */
      __IO uint32_t  DCG_PF     :  1;               /*!< Batch control of clocks belonging to PF                               */
           uint32_t             :  1;
      __IO uint32_t  DCG_PD     :  1;               /*!< Batch control of clocks belonging to PD                               */
      __IO uint32_t  DCG_PU     :  1;               /*!< Batch control of clocks belonging to PU                               */
      __IO uint32_t  DCG_PA12   :  1;               /*!< Batch control of clocks belonging to PA12                             */
      __IO uint32_t  DCG_PA24   :  1;               /*!< Batch control of clocks belonging to PA24                             */
      __IO uint32_t  DCG_PP1    :  1;               /*!< Batch control of clocks belonging to PP1                              */
           uint32_t : 20; // padding
    } DCG_POWERDOMAIN_b;                            /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];
  
  union {
    __IO uint32_t  SRST_ON_POWERDOMAIN;             /*!< Soft reset ON (for each power supply domain)[Write]1: Reset
                                                         assert. 0: Ignored.[Read]1: Reset assert in progress. 0: Reset
                                                          deassert in progress* Writing also changes values of associated
                                                          individual SRST registers. (Example) If writing is done to the
                                                          SRST_PD field, the values of the [SRST_ON_PD] and [SRST_OFF_PD]
                                                          registers are also changed.                                          */
    
    struct {
      __IO uint32_t  SRST_PM    :  1;               /*!< Batch control of resets belonging to PM                               */
      __IO uint32_t  SRST_PE    :  1;               /*!< Batch control of resets belonging to PE                               */
           uint32_t             :  3;
      __IO uint32_t  SRST_PF    :  1;               /*!< Batch control of resets belonging to PF                               */
           uint32_t             :  1;
      __IO uint32_t  SRST_PD    :  1;               /*!< Batch control of resets belonging to PD                               */
           uint32_t             :  1;
      __IO uint32_t  SRST_PA12  :  1;               /*!< Batch control of resets belonging to PA12                             */
      __IO uint32_t  SRST_PA24  :  1;               /*!< Batch control of resets belonging to PA24                             */
      __IO uint32_t  SRST_PP1   :  1;               /*!< Batch control of resets belonging to PP1                              */
           uint32_t : 20; // padding
    } SRST_ON_POWERDOMAIN_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_OFF_POWERDOMAIN;            /*!< Soft reset OFF (for each power supply domain)[Write]1: Reset
                                                         deassert. 0: Ignored.[Read]1: Reset deassert in progress. 0:
                                                          Reset assert in progress* Writing also changes values of associated
                                                          individual SRST registers. (Example) If writing is done to the
                                                          SRST_PD field, the values of the [SRST_ON_PD] and [SRST_OFF_PD]
                                                          registers are also changed.                                          */
    
    struct {
      __IO uint32_t  SRST_PM    :  1;               /*!< Batch control of resets belonging to PM                               */
      __IO uint32_t  SRST_PE    :  1;               /*!< Batch control of resets belonging to PE                               */
           uint32_t             :  3;
      __IO uint32_t  SRST_PF    :  1;               /*!< Batch control of resets belonging to PF                               */
           uint32_t             :  1;
      __IO uint32_t  SRST_PD    :  1;               /*!< Batch control of resets belonging to PD                               */
           uint32_t             :  1;
      __IO uint32_t  SRST_PA12  :  1;               /*!< Batch control of resets belonging to PA12                             */
      __IO uint32_t  SRST_PA24  :  1;               /*!< Batch control of resets belonging to PA24                             */
      __IO uint32_t  SRST_PP1   :  1;               /*!< Batch control of resets belonging to PP1                              */
           uint32_t : 20; // padding
    } SRST_OFF_POWERDOMAIN_b;                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[54];
  
  union {
    __IO uint32_t  CG_ON_PM_0;                      /*!< Clock gating ON (PM/PS0/PS1/PS2)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.                         */
    
    struct {
           uint32_t             : 20;
      __IO uint32_t  CG_mpierclk_h2pm_hclk:  1;     /*!< H2APB clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PM
                                                         and [CG_OFF_POWERDOMAIN].CG_PM.                                       */
           uint32_t             :  1;
      __IO uint32_t  CG_mpierclk_evm_pclk:  1;      /*!< EVM clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PM
                                                         and [CG_OFF_POWERDOMAIN].CG_PM.                                       */
      __IO uint32_t  CG_mpierclk_sramc_hclk:  1;    /*!< SRAMC AHB I/F clock (T0/T1/T2)* Also changed by writing to [CG_ON_POWERDOM
                                                         AIN].CG_PM and [CG_OFF_POWERDOMAIN].CG_PM.                            */
      __IO uint32_t  CG_mpierclk_sramc_s0hclk:  1;  /*!< SRAMC PS0 clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PS0
                                                         and [CG_OFF_POWERDOMAIN].CG_PS0.                                      */
      __IO uint32_t  CG_mpierclk_sramc_s1hclk:  1;  /*!< SRAMC PS1 clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PS1
                                                         and [CG_OFF_POWERDOMAIN].CG_PS1.                                      */
      __IO uint32_t  CG_mpierclk_sramc_s2hclk:  1;  /*!< SRAMC PS2 clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PS2
                                                         and [CG_OFF_POWERDOMAIN].CG_PS2.                                      */
      __IO uint32_t  CG_mpierclk_sramc_pclk:  1;    /*!< SRAMC APB I/F clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PM
                                                         and [CG_OFF_POWERDOMAIN].CG_PM.                                       */
           uint32_t : 4; // padding
    } CG_ON_PM_0_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_ON_PM_1;                      /*!< Clock gating ON (PM)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PM and [CG_OFF_POWERDOMAIN].CG_PM. */
    
    struct {
      __IO uint32_t  CG_mpierclk_h2hp0_hclk:  1;    /*!< H2HSYNCDNP0 clock                                                     */
      __IO uint32_t  CG_ppier0clk_h2pp0_hclk:  1;   /*!< H2APBP0 clock                                                         */
      __IO uint32_t  CG_ppier0clk_rtclv_pclk:  1;   /*!< RTCLV APB I/F clock                                                   */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_wdt_pclk:  1;     /*!< WDT APB I/F clock                                                     */
      __IO uint32_t  CG_ppier0clk_wdt_wdtclk:  1;   /*!< WDT timer counter clock                                               */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_pclk:  1;  /*!< ADVTMR APB I/F clock                                                  */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch0_timclk:  1;/*!< ADVTMR ch0 timer counter clock                                    */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch1_timclk:  1;/*!< ADVTMR ch1 timer counter clock                                    */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch2_timclk:  1;/*!< ADVTMR ch2 timer counter clock                                    */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch3_timclk:  1;/*!< ADVTMR ch3 timer counter clock                                    */
           uint32_t             :  3;
      __IO uint32_t  CG_ppier0clk_tmr_pclk:  1;     /*!< TMR APB I/F clock                                                     */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_tmr_ch0_timclk:  1;/*!< TMR ch0 timer counter clock                                          */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_tmr_ch1_timclk:  1;/*!< TMR ch1 timer counter clock                                          */
      __IO uint32_t  CG_ppier0clk_i2c2_pclk:  1;    /*!< I2C2 APB I/F clock                                                    */
      __IO uint32_t  CG_ppier0clk_i2c2_sclk:  1;    /*!< I2C2 serial clock                                                     */
      __IO uint32_t  CG_ppier0clk_spim2_pclk:  1;   /*!< SPIM2 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_spim2_sclk:  1;   /*!< SPIM2 serial clock                                                    */
      __IO uint32_t  CG_ppier0clk_spim3_pclk:  1;   /*!< SPIM3 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_spim3_sclk:  1;   /*!< SPIM3 serial clock                                                    */
           uint32_t : 2; // padding
    } CG_ON_PM_1_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_ON_PM_2;                      /*!< Clock gating ON (PM)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PM and [CG_OFF_POWERDOMAIN].CG_PM. */
    
    struct {
      __IO uint32_t  CG_ppier0clk_gconf_pclk:  1;   /*!< GCONF APB I/F clock                                                   */
           uint32_t             :  3;
      __IO uint32_t  CG_ppier0clk_gpio0_pclk:  1;   /*!< GPIO0 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_gpio1_pclk:  1;   /*!< GPIO1 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_gpio2_pclk:  1;   /*!< GPIO2 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_gpio3_pclk:  1;   /*!< GPIO3 APB I/F clock                                                   */
      __IO uint32_t  CG_mpierclk_h2hp2_hclk:  1;    /*!< H2HSYNCDNP2 clock                                                     */
      __IO uint32_t  CG_ppier2clk_h2pp2_hclk:  1;   /*!< H2APBP2 clock                                                         */
      __IO uint32_t  CG_ppier2clk_uart2_pclk:  1;   /*!< UART2 APB I/F clock                                                   */
      __IO uint32_t  CG_uart2clk_uart2_sclk:  1;    /*!< UART2 serial clock                                                    */
           uint32_t             :  4;
      __IO uint32_t  CG_mpierclk_h2hp1_hclk:  1;    /*!< H2HSYNCDNP1 clock                                                     */
           uint32_t : 15; // padding
    } CG_ON_PM_2_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;
  
  union {
    __IO uint32_t  CG_ON_PE;                        /*!< Clock gating ON (PE)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PE and [CG_OFF_POWERDOMAIN].CG_PE. */
    
    struct {
      __IO uint32_t  CG_mpierclk_aesa_busclk:  1;   /*!< AESA APB I/F clock                                                    */
      __IO uint32_t  CG_mpierclk_aesa_coreclk:  1;  /*!< AESA core clock                                                       */
      __IO uint32_t  CG_mpierclk_rng_busclk:  1;    /*!< RNG APB I/F clock                                                     */
      __IO uint32_t  CG_mpierclk_rng_coreclk:  1;   /*!< RNG core clock                                                        */
           uint32_t : 28; // padding
    } CG_ON_PE_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[3];
  
  union {
    __IO uint32_t  CG_ON_PF;                        /*!< Clock gating ON (PF)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PF and [CG_OFF_POWERDOMAIN].CG_PF. */
    
    struct {
      __IO uint32_t  CG_mpierclk_spic_hclk:  1;     /*!< SPIC AHB I/F clock                                                    */
      __IO uint32_t  CG_mpierclk_spic_srclk:  1;    /*!< SPIC SRAM clock                                                       */
      __IO uint32_t  CG_spicclk_spic_spclk:  1;     /*!< SPIC SPI clock                                                        */
           uint32_t : 29; // padding
    } CG_ON_PF_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5;
  
  union {
    __IO uint32_t  CG_ON_PD;                        /*!< Clock gating ON (PD)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PD and [CG_OFF_POWERDOMAIN].CG_PD. */
    
    struct {
      __IO uint32_t  CG_mpierclk_sdmac_hclk:  1;    /*!< DMAC clock                                                            */
           uint32_t : 31; // padding
    } CG_ON_PD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_ON_PU;                        /*!< Clock gating ON (PU)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PU and [CG_OFF_POWERDOMAIN].CG_PU. */
    
    struct {
      __IO uint32_t  CG_mpierclk_h2hdnu_hclk:  1;   /*!< H2HSYNCDNU slave clock                                                */
           uint32_t             :  1;
      __IO uint32_t  CG_mpierclk_h2hupu_hclk:  1;   /*!< H2HSYNCUPU clock                                                      */
      __IO uint32_t  CG_usbbclk_usb2fs_hclk:  1;    /*!< USB AHB I/F clock                                                     */
      __IO uint32_t  CG_usbiclk_usb2fs_usbclk:  1;  /*!< USB USB clock                                                         */
           uint32_t : 27; // padding
    } CG_ON_PU_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6;
  
  union {
    __IO uint32_t  CG_ON_PA12;                      /*!< Clock gating ON (PA12)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PA12 and [CG_OFF_POWERDOMAIN].CG_PA12
                                                         .                                                                     */
    
    struct {
      __IO uint32_t  CG_ppier0clk_adcc12_pclk:  1;  /*!< ADC12 APB I/F clock                                                   */
      __IO uint32_t  CG_adcc12aclk_adcc12_adccclk:  1;/*!< ADC12 ADC clock                                                     */
      __IO uint32_t  CG_rtcclk_adcc12_rtcclk:  1;   /*!< ADC12 RTC clock                                                       */
           uint32_t : 29; // padding
    } CG_ON_PA12_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_ON_PA24;                      /*!< Clock gating ON (PA24)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PA24 and [CG_OFF_POWERDOMAIN].CG_PA24
                                                         .                                                                     */
    
    struct {
      __IO uint32_t  CG_ppier0clk_adcc24_pclk:  1;  /*!< ADC24 APB I/F clock                                                   */
      __IO uint32_t  CG_adcc24aclk_adcc24_adccclk:  1;/*!< ADC24 ADC clock                                                     */
      __IO uint32_t  CG_rtcclk_adcc24_rtcclk:  1;   /*!< ADC24 RTC clock                                                       */
           uint32_t : 29; // padding
    } CG_ON_PA24_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_ON_PP1;                       /*!< Clock gating ON (PP1)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PP1 and [CG_OFF_POWERDOMAIN].CG_PP1. */
    
    struct {
      __IO uint32_t  CG_ppier1clk_h2pp1_hclk:  1;   /*!< H2APBP1 clock                                                         */
           uint32_t             :  3;
      __IO uint32_t  CG_ppier1clk_i2c0_pclk:  1;    /*!< I2C0 APB I/F clock                                                    */
      __IO uint32_t  CG_ppier1clk_i2c0_sclk:  1;    /*!< I2C0 serial clock                                                     */
      __IO uint32_t  CG_ppier1clk_i2c1_pclk:  1;    /*!< I2C1 APB I/F clock                                                    */
      __IO uint32_t  CG_ppier1clk_i2c1_sclk:  1;    /*!< I2C1 serial clock                                                     */
      __IO uint32_t  CG_ppier1clk_spim0_pclk:  1;   /*!< SPIM0 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier1clk_spim0_sclk:  1;   /*!< SPIM0 serial clock                                                    */
      __IO uint32_t  CG_ppier1clk_spim1_pclk:  1;   /*!< SPIM1 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier1clk_spim1_sclk:  1;   /*!< SPIM1 serial clock                                                    */
      __IO uint32_t  CG_ppier1clk_uart0_pclk:  1;   /*!< UART0 APB I/F clock                                                   */
      __IO uint32_t  CG_uart0clk_uart0_sclk:  1;    /*!< UART0 serial clock                                                    */
      __IO uint32_t  CG_ppier1clk_uart1_pclk:  1;   /*!< UART1 APB I/F clock                                                   */
      __IO uint32_t  CG_uart1clk_uart1_sclk:  1;    /*!< UART1 serial clock                                                    */
           uint32_t : 16; // padding
    } CG_ON_PP1_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_ON_HARDMACRO;                 /*!< Clock gating ON (HARDMACRO)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.                         */
    
    struct {
      __IO uint32_t  CG_pmulvclk_pmulv_efuseclk:  1;/*!< EFUSE clock                                                           */
           uint32_t             : 15;
      __IO uint32_t  CG_dcdcclk_dcdc_gatedclk:  1;  /*!< DCDC clock                                                            */
           uint32_t : 15; // padding
    } CG_ON_HARDMACRO_b;                            /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7;
  
  union {
    __IO uint32_t  CG_ON_REFCLK;                    /*!< Clock gating ON (REFCLK)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.                         */
    
    struct {
      __IO uint32_t  CG_ref32kclk_pmulv_refclk:  1; /*!< PMULV reference clock                                                 */
           uint32_t             : 15;
      __IO uint32_t  CG_ref32kclk_adpll_refclk:  1; /*!< ADPLL reference clock                                                 */
           uint32_t : 15; // padding
    } CG_ON_REFCLK_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8[13];
  
  union {
    __IO uint32_t  CG_OFF_PM_0;                     /*!< Clock gating OFF (PM/PS0/PS1/PS2)[Write]1: Clock is supplied.
                                                         0: Ignored.[Read]1: Clock is being supplied. 0: Clock is stopped.     */
    
    struct {
           uint32_t             : 20;
      __IO uint32_t  CG_mpierclk_h2pm_hclk:  1;     /*!< H2APB clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PM
                                                         and [CG_OFF_POWERDOMAIN].CG_PM.                                       */
           uint32_t             :  1;
      __IO uint32_t  CG_mpierclk_evm_pclk:  1;      /*!< EVM clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PM
                                                         and [CG_OFF_POWERDOMAIN].CG_PM.                                       */
      __IO uint32_t  CG_mpierclk_sramc_hclk:  1;    /*!< SRAMC AHB I/F clock (T0/T1/T2)* Also changed by writing to [CG_ON_POWERDOM
                                                         AIN].CG_PM and [CG_OFF_POWERDOMAIN].CG_PM.                            */
      __IO uint32_t  CG_mpierclk_sramc_s0hclk:  1;  /*!< SRAMC PS0 clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PS0
                                                         and [CG_OFF_POWERDOMAIN].CG_PS0.                                      */
      __IO uint32_t  CG_mpierclk_sramc_s1hclk:  1;  /*!< SRAMC PS1 clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PS1
                                                         and [CG_OFF_POWERDOMAIN].CG_PS1.                                      */
      __IO uint32_t  CG_mpierclk_sramc_s2hclk:  1;  /*!< SRAMC PS2 clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PS2
                                                         and [CG_OFF_POWERDOMAIN].CG_PS2.                                      */
      __IO uint32_t  CG_mpierclk_sramc_pclk:  1;    /*!< SRAMC APB I/F clock* Also changed by writing to [CG_ON_POWERDOMAIN].CG_PM
                                                         and [CG_OFF_POWERDOMAIN].CG_PM.                                       */
           uint32_t : 4; // padding
    } CG_OFF_PM_0_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_OFF_PM_1;                     /*!< Clock gating OFF (PM)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PM and [CG_OFF_POWERDOMAIN].CG_PM. */
    
    struct {
      __IO uint32_t  CG_mpierclk_h2hp0_hclk:  1;    /*!< H2HSYNCDNP0 clock                                                     */
      __IO uint32_t  CG_ppier0clk_h2pp0_hclk:  1;   /*!< H2APBP0 clock                                                         */
      __IO uint32_t  CG_ppier0clk_rtclv_pclk:  1;   /*!< RTCLV APB I/F clock                                                   */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_wdt_pclk:  1;     /*!< WDT APB I/F clock                                                     */
      __IO uint32_t  CG_ppier0clk_wdt_wdtclk:  1;   /*!< WDT timer counter clock                                               */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_pclk:  1;  /*!< ADVTMR APB I/F clock                                                  */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch0_timclk:  1;/*!< ADVTMR ch0 timer counter clock                                    */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch1_timclk:  1;/*!< ADVTMR ch1 timer counter clock                                    */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch2_timclk:  1;/*!< ADVTMR ch2 timer counter clock                                    */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_advtmr_ch3_timclk:  1;/*!< ADVTMR ch3 timer counter clock                                    */
           uint32_t             :  3;
      __IO uint32_t  CG_ppier0clk_tmr_pclk:  1;     /*!< TMR APB I/F clock                                                     */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_tmr_ch0_timclk:  1;/*!< TMR ch0 timer counter clock                                          */
           uint32_t             :  1;
      __IO uint32_t  CG_ppier0clk_tmr_ch1_timclk:  1;/*!< TMR ch1 timer counter clock                                          */
      __IO uint32_t  CG_ppier0clk_i2c2_pclk:  1;    /*!< I2C2 APB I/F clock                                                    */
      __IO uint32_t  CG_ppier0clk_i2c2_sclk:  1;    /*!< I2C2 serial clock                                                     */
      __IO uint32_t  CG_ppier0clk_spim2_pclk:  1;   /*!< SPIM2 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_spim2_sclk:  1;   /*!< SPIM2 serial clock                                                    */
      __IO uint32_t  CG_ppier0clk_spim3_pclk:  1;   /*!< SPIM3 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_spim3_sclk:  1;   /*!< SPIM3 serial clock                                                    */
           uint32_t : 2; // padding
    } CG_OFF_PM_1_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_OFF_PM_2;                     /*!< Clock gating OFF (PM)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PM and [CG_OFF_POWERDOMAIN].CG_PM. */
    
    struct {
      __IO uint32_t  CG_ppier0clk_gconf_pclk:  1;   /*!< GCONF APB I/F clock                                                   */
           uint32_t             :  3;
      __IO uint32_t  CG_ppier0clk_gpio0_pclk:  1;   /*!< GPIO0 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_gpio1_pclk:  1;   /*!< GPIO1 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_gpio2_pclk:  1;   /*!< GPIO2 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier0clk_gpio3_pclk:  1;   /*!< GPIO3 APB I/F clock                                                   */
      __IO uint32_t  CG_mpierclk_h2hp2_hclk:  1;    /*!< H2HSYNCDNP2 clock                                                     */
      __IO uint32_t  CG_ppier2clk_h2pp2_hclk:  1;   /*!< H2APBP2 clock                                                         */
      __IO uint32_t  CG_ppier2clk_uart2_pclk:  1;   /*!< UART2 APB I/F clock                                                   */
      __IO uint32_t  CG_uart2clk_uart2_sclk:  1;    /*!< UART2 serial clock                                                    */
           uint32_t             :  4;
      __IO uint32_t  CG_mpierclk_h2hp1_hclk:  1;    /*!< H2HSYNCDNP1 clock                                                     */
           uint32_t : 15; // padding
    } CG_OFF_PM_2_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED9;
  
  union {
    __IO uint32_t  CG_OFF_PE;                       /*!< Clock gating OFF (PE)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PE and [CG_OFF_POWERDOMAIN].CG_PE. */
    
    struct {
      __IO uint32_t  CG_mpierclk_aesa_busclk:  1;   /*!< AESA APB I/F clock                                                    */
      __IO uint32_t  CG_mpierclk_aesa_coreclk:  1;  /*!< AESA core clock                                                       */
      __IO uint32_t  CG_mpierclk_rng_busclk:  1;    /*!< RNG APB I/F clock                                                     */
      __IO uint32_t  CG_mpierclk_rng_coreclk:  1;   /*!< RNG core clock                                                        */
           uint32_t : 28; // padding
    } CG_OFF_PE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED10[3];
  
  union {
    __IO uint32_t  CG_OFF_PF;                       /*!< Clock gating OFF (PF)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PF and [CG_OFF_POWERDOMAIN].CG_PF. */
    
    struct {
      __IO uint32_t  CG_mpierclk_spic_hclk:  1;     /*!< SPIC AHB I/F clock                                                    */
      __IO uint32_t  CG_mpierclk_spic_srclk:  1;    /*!< SPIC SRAM clock                                                       */
      __IO uint32_t  CG_spicclk_spic_spclk:  1;     /*!< SPIC SPI clock                                                        */
           uint32_t : 29; // padding
    } CG_OFF_PF_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED11;
  
  union {
    __IO uint32_t  CG_OFF_PD;                       /*!< Clock gating OFF (PD)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PD and [CG_OFF_POWERDOMAIN].CG_PD. */
    
    struct {
      __IO uint32_t  CG_mpierclk_sdmac_hclk:  1;    /*!< DMAC clock                                                            */
           uint32_t : 31; // padding
    } CG_OFF_PD_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_OFF_PU;                       /*!< Clock gating OFF (PU)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PU and [CG_OFF_POWERDOMAIN].CG_PU. */
    
    struct {
      __IO uint32_t  CG_mpierclk_h2hdnu_hclk:  1;   /*!< H2HSYNCDNU slave clock                                                */
           uint32_t             :  1;
      __IO uint32_t  CG_mpierclk_h2hupu_hclk:  1;   /*!< H2HSYNCUPU clock                                                      */
      __IO uint32_t  CG_usbbclk_usb2fs_hclk:  1;    /*!< USB AHB I/F clock                                                     */
      __IO uint32_t  CG_usbiclk_usb2fs_usbclk:  1;  /*!< USB USB clock                                                         */
           uint32_t : 27; // padding
    } CG_OFF_PU_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED12;
  
  union {
    __IO uint32_t  CG_OFF_PA12;                     /*!< Clock gating OFF (PA12)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PA12 and [CG_OFF_POWERDOMAIN].CG_PA12
                                                         .                                                                     */
    
    struct {
      __IO uint32_t  CG_ppier0clk_adcc12_pclk:  1;  /*!< ADC12 APB I/F clock                                                   */
      __IO uint32_t  CG_adcc12aclk_adcc12_adccclk:  1;/*!< ADC12 ADC clock                                                     */
      __IO uint32_t  CG_rtcclk_adcc12_rtcclk:  1;   /*!< ADC12 RTC clock                                                       */
           uint32_t : 29; // padding
    } CG_OFF_PA12_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_OFF_PA24;                     /*!< Clock gating OFF (PA24)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PA24 and [CG_OFF_POWERDOMAIN].CG_PA24
                                                         .                                                                     */
    
    struct {
      __IO uint32_t  CG_ppier0clk_adcc24_pclk:  1;  /*!< ADC24 APB I/F clock                                                   */
      __IO uint32_t  CG_adcc24aclk_adcc24_adccclk:  1;/*!< ADC24 ADC clock                                                     */
      __IO uint32_t  CG_rtcclk_adcc24_rtcclk:  1;   /*!< ADC24 RTC clock                                                       */
           uint32_t : 29; // padding
    } CG_OFF_PA24_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_OFF_PP1;                      /*!< Clock gating OFF (PP1)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN].CG_PP1 and [CG_OFF_POWERDOMAIN].CG_PP1. */
    
    struct {
      __IO uint32_t  CG_ppier1clk_h2pp1_hclk:  1;   /*!< H2APBP1 clock                                                         */
           uint32_t             :  3;
      __IO uint32_t  CG_ppier1clk_i2c0_pclk:  1;    /*!< I2C0 APB I/F clock                                                    */
      __IO uint32_t  CG_ppier1clk_i2c0_sclk:  1;    /*!< I2C0 serial clock                                                     */
      __IO uint32_t  CG_ppier1clk_i2c1_pclk:  1;    /*!< I2C1 APB I/F clock                                                    */
      __IO uint32_t  CG_ppier1clk_i2c1_sclk:  1;    /*!< I2C1 serial clock                                                     */
      __IO uint32_t  CG_ppier1clk_spim0_pclk:  1;   /*!< SPIM0 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier1clk_spim0_sclk:  1;   /*!< SPIM0 serial clock                                                    */
      __IO uint32_t  CG_ppier1clk_spim1_pclk:  1;   /*!< SPIM1 APB I/F clock                                                   */
      __IO uint32_t  CG_ppier1clk_spim1_sclk:  1;   /*!< SPIM1 serial clock                                                    */
      __IO uint32_t  CG_ppier1clk_uart0_pclk:  1;   /*!< UART0 APB I/F clock                                                   */
      __IO uint32_t  CG_uart0clk_uart0_sclk:  1;    /*!< UART0 serial clock                                                    */
      __IO uint32_t  CG_ppier1clk_uart1_pclk:  1;   /*!< UART1 APB I/F clock                                                   */
      __IO uint32_t  CG_uart1clk_uart1_sclk:  1;    /*!< UART1 serial clock                                                    */
           uint32_t : 16; // padding
    } CG_OFF_PP1_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CG_OFF_HARDMACRO;                /*!< Clock gating OFF (HARDMACRO)[Write]1: Clock is supplied. 0:
                                                         Ignored.[Read]1: Clock is being supplied. 0: Clock is stopped.        */
    
    struct {
      __IO uint32_t  CG_pmulvclk_pmulv_efuseclk:  1;/*!< EFUSE clock                                                           */
           uint32_t             : 15;
      __IO uint32_t  CG_dcdcclk_dcdc_gatedclk:  1;  /*!< DCDC clock                                                            */
           uint32_t : 15; // padding
    } CG_OFF_HARDMACRO_b;                           /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED13;
  
  union {
    __IO uint32_t  CG_OFF_REFCLK;                   /*!< Clock gating OFF (HARDMACRO)[Write]1: Clock is supplied. 0:
                                                         Ignored.[Read]1: Clock is being supplied. 0: Clock is stopped.        */
    
    struct {
      __IO uint32_t  CG_ref32kclk_pmulv_refclk:  1; /*!< PMULV reference clock                                                 */
           uint32_t             : 15;
      __IO uint32_t  CG_ref32kclk_adpll_refclk:  1; /*!< ADPLL reference clock                                                 */
           uint32_t : 15; // padding
    } CG_OFF_REFCLK_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED14[13];
  
  union {
    __IO uint32_t  DCG_PM_0;                        /*!< Dynamic clock gating (PM)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.                                                          */
    
    struct {
      __IO uint32_t  DCG_mpierclk_mpier_hclk:  1;   /*!< MPIER clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM.     */
           uint32_t             : 19;
      __IO uint32_t  DCG_mpierclk_h2pm_hclk:  1;    /*!< H2APBM clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM.    */
           uint32_t             :  1;
      __IO uint32_t  DCG_mpierclk_evm_pclk:  1;     /*!< EVM clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM.       */
      __IO uint32_t  DCG_mpierclk_sramc_hclk:  1;   /*!< SRAMC AHB I/F clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM. */
      __IO uint32_t  DCG_mpierclk_sramc_s0hclk:  1; /*!< SRAMC PS0 clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PS0. */
      __IO uint32_t  DCG_mpierclk_sramc_s1hclk:  1; /*!< SRAMC PS1 clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PS1. */
      __IO uint32_t  DCG_mpierclk_sramc_s2hclk:  1; /*!< SRAMC PS2 clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PS2. */
      __IO uint32_t  DCG_mpierclk_sramc_pclk:  1;   /*!< SRAMC APB I/F clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM. */
      __IO uint32_t  DCG_mpierclk_h2hasync_hclk:  1;/*!< H2HASYNC slave clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM. */
      __IO uint32_t  DCG_pmulvclk_h2hasync_hclk:  1;/*!< H2HASYNC master clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM
                                                         .                                                                     */
      __IO uint32_t  DCG_pmulvclk_h2ppmu_hclk:  1;  /*!< H2APBPMU clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM.  */
      __IO uint32_t  DCG_pmulvclk_pmulv_lv0clk:  1; /*!< PMULV clock* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM.     */
    } DCG_PM_0_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DCG_PM_1;                        /*!< Dynamic clock gating (PM)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM.    */
    
    struct {
      __IO uint32_t  DCG_mpierclk_h2hp0_hclk:  1;   /*!< H2HSYNCDNP0 clock                                                     */
      __IO uint32_t  DCG_ppier0clk_h2pp0_hclk:  1;  /*!< H2APBP0 clock                                                         */
           uint32_t             :  2;
      __IO uint32_t  DCG_ppier0clk_wdt_pclk:  1;    /*!< WDT APB I/F clock                                                     */
      __IO uint32_t  DCG_ppier0clk_wdt_wdtclk:  1;  /*!< WDT timer counter clock                                               */
           uint32_t             :  1;
      __IO uint32_t  DCG_ppier0clk_advtmr_pclk:  1; /*!< ADVTMR APB I/F clock                                                  */
           uint32_t             :  1;
      __IO uint32_t  DCG_ppier0clk_advtmr_ch0_timclk:  1;/*!< ADVTMR ch0 timer counter clock                                   */
           uint32_t             :  1;
      __IO uint32_t  DCG_ppier0clk_advtmr_ch1_timclk:  1;/*!< ADVTMR ch1 timer counter clock                                   */
           uint32_t             :  1;
      __IO uint32_t  DCG_ppier0clk_advtmr_ch2_timclk:  1;/*!< ADVTMR ch2 timer counter clock                                   */
           uint32_t             :  1;
      __IO uint32_t  DCG_ppier0clk_advtmr_ch3_timclk:  1;/*!< ADVTMR ch3 timer counter clock                                   */
           uint32_t             :  3;
      __IO uint32_t  DCG_ppier0clk_tmr_pclk:  1;    /*!< TMR APB I/F clock                                                     */
           uint32_t             :  1;
      __IO uint32_t  DCG_ppier0clk_tmr_ch0_timclk:  1;/*!< TMR ch0 timer counter clock                                         */
           uint32_t             :  1;
      __IO uint32_t  DCG_ppier0clk_tmr_ch1_timclk:  1;/*!< TMR ch1 timer counter clock                                         */
      __IO uint32_t  DCG_ppier0clk_i2c2_pclk:  1;   /*!< I2C2 APB I/F clock                                                    */
      __IO uint32_t  DCG_ppier0clk_i2c2_sclk:  1;   /*!< I2C2 serial clock                                                     */
      __IO uint32_t  DCG_ppier0clk_spim2_pclk:  1;  /*!< SPIM2 APB I/F clock                                                   */
      __IO uint32_t  DCG_ppier0clk_spim2_sclk:  1;  /*!< SPIM2 serial clock                                                    */
      __IO uint32_t  DCG_ppier0clk_spim3_pclk:  1;  /*!< SPIM3 APB I/F clock                                                   */
      __IO uint32_t  DCG_ppier0clk_spim3_sclk:  1;  /*!< SPIM3 serial clock                                                    */
           uint32_t : 2; // padding
    } DCG_PM_1_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DCG_PM_2;                        /*!< Dynamic clock gating (PM)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PM.    */
    
    struct {
      __IO uint32_t  DCG_ppier0clk_gconf_pclk:  1;  /*!< GCONF APB I/F clock                                                   */
           uint32_t             :  3;
      __IO uint32_t  DCG_ppier0clk_gpio0_pclk:  1;  /*!< GPIO0 APB I/F clock                                                   */
      __IO uint32_t  DCG_ppier0clk_gpio1_pclk:  1;  /*!< GPIO1 APB I/F clock                                                   */
      __IO uint32_t  DCG_ppier0clk_gpio2_pclk:  1;  /*!< GPIO2 APB I/F clock                                                   */
      __IO uint32_t  DCG_ppier0clk_gpio3_pclk:  1;  /*!< GPIO3 APB I/F clock                                                   */
      __IO uint32_t  DCG_mpierclk_h2hp2_hclk:  1;   /*!< H2HSYNCDNP2 clock                                                     */
      __IO uint32_t  DCG_ppier2clk_h2pp2_hclk:  1;  /*!< H2APBP2 clock                                                         */
      __IO uint32_t  DCG_ppier2clk_uart2_pclk:  1;  /*!< UART2 APB I/F clock                                                   */
      __IO uint32_t  DCG_uart2clk_uart2_sclk:  1;   /*!< UART2 serial clock                                                    */
           uint32_t             :  4;
      __IO uint32_t  DCG_mpierclk_h2hp1_hclk:  1;   /*!< H2HSYNCDNP1 clock                                                     */
           uint32_t : 15; // padding
    } DCG_PM_2_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED15;
  
  union {
    __IO uint32_t  DCG_PE;                          /*!< Dynamic clock gating (PE)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PE.    */
    
    struct {
      __IO uint32_t  DCG_mpierclk_aesa_busclk:  1;  /*!< AESA APB I/F clock                                                    */
      __IO uint32_t  DCG_mpierclk_aesa_coreclk:  1; /*!< AESA core clock                                                       */
      __IO uint32_t  DCG_mpierclk_rng_busclk:  1;   /*!< RNG APB I/F clock                                                     */
      __IO uint32_t  DCG_mpierclk_rng_coreclk:  1;  /*!< RNG core clock                                                        */
           uint32_t : 28; // padding
    } DCG_PE_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED16[3];
  
  union {
    __IO uint32_t  DCG_PF;                          /*!< Dynamic clock gating (PF)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PF.    */
    
    struct {
      __IO uint32_t  DCG_mpierclk_spic_hclk:  1;    /*!< SPIC AHB I/F clock                                                    */
      __IO uint32_t  DCG_mpierclk_spic_srclk:  1;   /*!< SPIC SRAM clock                                                       */
      __IO uint32_t  DCG_spicclk_spic_spclk:  1;    /*!< SPIC SPI clock                                                        */
           uint32_t : 29; // padding
    } DCG_PF_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED17;
  
  union {
    __IO uint32_t  DCG_PD;                          /*!< Dynamic clock gating (PD)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PD.    */
    
    struct {
      __IO uint32_t  DCG_mpierclk_sdmac_hclk:  1;   /*!< DMAC clock                                                            */
           uint32_t : 31; // padding
    } DCG_PD_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DCG_PU;                          /*!< Dynamic clock gating (PU)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PU.    */
    
    struct {
      __IO uint32_t  DCG_mpierclk_h2hdnu_hclk:  1;  /*!< H2HSYNCDNU slave clock                                                */
           uint32_t : 31; // padding
    } DCG_PU_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED18;
  
  union {
    __IO uint32_t  DCG_PA12;                        /*!< Dynamic clock gating (PA12)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PA12.  */
    
    struct {
      __IO uint32_t  DCG_ppier0clk_adcc12_pclk:  1; /*!< ADC12 APB I/F clock                                                   */
      __IO uint32_t  DCG_adcc12aclk_adcc12_adccclk:  1;/*!< ADC12 ADC clock                                                    */
           uint32_t : 30; // padding
    } DCG_PA12_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DCG_PA24;                        /*!< Dynamic clock gating (PA24)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PA24.  */
    
    struct {
      __IO uint32_t  DCG_ppier0clk_adcc24_pclk:  1; /*!< ADC24 APB I/F clock                                                   */
      __IO uint32_t  DCG_adcc24aclk_adcc24_adccclk:  1;/*!< ADC24 ADC clock                                                    */
           uint32_t : 30; // padding
    } DCG_PA24_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DCG_PP1;                         /*!< Dynamic clock gating (PP1)[Write]1: Dynamic clock gating enable.
                                                         0: Dynamic clock gating disable[Read] A configured value can
                                                          be checked.* Also changed by writing to [DCG_POWERDOMAIN].DCG_PP1.   */
    
    struct {
      __IO uint32_t  DCG_ppier1clk_h2pp1_hclk:  1;  /*!< H2APBP1 clock                                                         */
           uint32_t             :  3;
      __IO uint32_t  DCG_ppier1clk_i2c0_pclk:  1;   /*!< I2C0 APB I/F clock                                                    */
      __IO uint32_t  DCG_ppier1clk_i2c0_sclk:  1;   /*!< I2C0 serial clock                                                     */
      __IO uint32_t  DCG_ppier1clk_i2c1_pclk:  1;   /*!< I2C1 APB I/F clock                                                    */
      __IO uint32_t  DCG_ppier1clk_i2c1_sclk:  1;   /*!< I2C1 serial clock                                                     */
      __IO uint32_t  DCG_ppier1clk_spim0_pclk:  1;  /*!< SPIM0 APB I/F clock                                                   */
      __IO uint32_t  DCG_ppier1clk_spim0_sclk:  1;  /*!< SPIM0 serial clock                                                    */
      __IO uint32_t  DCG_ppier1clk_spim1_pclk:  1;  /*!< SPIM1 APB I/F clock                                                   */
      __IO uint32_t  DCG_ppier1clk_spim1_sclk:  1;  /*!< SPIM1 serial clock                                                    */
      __IO uint32_t  DCG_ppier1clk_uart0_pclk:  1;  /*!< UART0 APB I/F clock                                                   */
      __IO uint32_t  DCG_uart0clk_uart0_sclk:  1;   /*!< UART0 serial clock                                                    */
      __IO uint32_t  DCG_ppier1clk_uart1_pclk:  1;  /*!< UART1 APB I/F clock                                                   */
      __IO uint32_t  DCG_uart1clk_uart1_sclk:  1;   /*!< UART1 serial clock                                                    */
           uint32_t : 16; // padding
    } DCG_PP1_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED19[20];
  
  union {
    __IO uint32_t  CLKREQ_CONFIG_PE;                /*!< Sets the clock supply period extension after bus transaction.0x0:
                                                         0cycle (no extension)0x1: 1cycle0x2: 2cycle0x3: 3cycle0x4: 4cycle0x5:
                                                          5cycle0x6: 6cycle0x7: 7cycle0x8: 8cycle0x9: 9cycle0xA: 10cycle0xB:
                                                          11cycle0xC: 12cycle0xD: 13cycle0xE: 14cycle0xF: 15cycle              */
    
    struct {
      __IO uint32_t  POSTCLK_LENGTH_mpierclk_aesa_busclk:  4;/*!< AESA APB I/F clock                                           */
           uint32_t             : 12;
      __IO uint32_t  POSTCLK_LENGTH_mpierclk_rng_busclk:  4;/*!< RNG APB I/F clock                                             */
           uint32_t : 12; // padding
    } CLKREQ_CONFIG_PE_b;                           /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED20[27];
  
  union {
    __IO uint32_t  SRST_ON_PM_0;                    /*!< Soft reset ON (PM)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PM and [SRST_OFF_POWERDOMAI
                                                         N].CG_PM.                                                             */
    
    struct {
           uint32_t             : 20;
      __IO uint32_t  SRST_asyncrst_h2pm_hrstn:  1;  /*!< H2APBM reset                                                          */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_evm_prstn:  1;   /*!< EVM reset                                                             */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_sramc_hrstn:  1; /*!< SRAMC AHB I/F reset                                                   */
           uint32_t             :  2;
      __IO uint32_t  SRST_asyncrst_sramc_prstn:  1; /*!< SRAMC APB I/F reset                                                   */
           uint32_t : 4; // padding
    } SRST_ON_PM_0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_ON_PM_1;                    /*!< Soft reset ON (PM)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PM and [SRST_OFF_POWERDOMAI
                                                         N].CG_PM.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_h2hp0_hrstn:  1; /*!< H2HSYNCDNP0 reset                                                     */
      __IO uint32_t  SRST_asyncrst_h2pp0_hrstn:  1; /*!< H2APBP0 reset                                                         */
      __IO uint32_t  SRST_asyncrst_rtclv_prstn:  1; /*!< RTCLV APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_rtclv_busrstn:  1;/*!< RTCLV timer reset                                                    */
      __IO uint32_t  SRST_asyncrst_wdt_prstn:  1;   /*!< WDT reset.                                                            */
           uint32_t             :  2;
      __IO uint32_t  SRST_asyncrst_advtmr_prstn:  1;/*!< ADVTMR reset                                                          */
           uint32_t             : 11;
      __IO uint32_t  SRST_asyncrst_tmr_prstn:  1;   /*!< TMR reset                                                             */
           uint32_t             :  4;
      __IO uint32_t  SRST_asyncrst_i2c2_prstn:  1;  /*!< I2C2 APB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_i2c2_srstn:  1;  /*!< I2C2 serial reset                                                     */
      __IO uint32_t  SRST_asyncrst_spim2_prstn:  1; /*!< SPIM2 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim2_srstn:  1; /*!< SPIM2 serial reset                                                    */
      __IO uint32_t  SRST_asyncrst_spim3_prstn:  1; /*!< SPIM3 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim3_srstn:  1; /*!< SPIM3 serial reset                                                    */
           uint32_t : 2; // padding
    } SRST_ON_PM_1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_ON_PM_2;                    /*!< Soft reset ON (PM)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PM and [SRST_OFF_POWERDOMAI
                                                         N].CG_PM.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_gconf_prstn:  1; /*!< GCONF APB I/F reset                                                   */
           uint32_t             :  3;
      __IO uint32_t  SRST_asyncrst_gpio0_prstn:  1; /*!< GPIO0 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_gpio1_prstn:  1; /*!< GPIO1 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_gpio2_prstn:  1; /*!< GPIO2 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_gpio3_prstn:  1; /*!< GPIO3 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_h2hp2_hrstn:  1; /*!< H2HSYNCDNP2 reset                                                     */
      __IO uint32_t  SRST_asyncrst_h2pp2_hrstn:  1; /*!< H2APBP2 reset                                                         */
      __IO uint32_t  SRST_asyncrst_uart2_prstn:  1; /*!< UART2 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_uart2_srstn:  1; /*!< UART2 serial reset.                                                   */
           uint32_t             :  4;
      __IO uint32_t  SRST_asyncrst_h2hp1_hrstn:  1; /*!< H2HSYNCDNP1 reset                                                     */
           uint32_t : 15; // padding
    } SRST_ON_PM_2_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED21;
  
  union {
    __IO uint32_t  SRST_ON_PE;                      /*!< Soft reset ON (PE)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PE and [SRST_OFF_POWERDOMAI
                                                         N].CG_PE.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_aesa_rstn:  1;   /*!< AESA reset                                                            */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_rng_rstn:  1;    /*!< RNG reset                                                             */
           uint32_t : 29; // padding
    } SRST_ON_PE_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED22[3];
  
  union {
    __IO uint32_t  SRST_ON_PF;                      /*!< Soft reset ON (PF)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PF and [SRST_OFF_POWERDOMAI
                                                         N].CG_PF.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_spic_hrstn:  1;  /*!< SPIC AHB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_spic_srrstn:  1; /*!< SPIC SRAM reset                                                       */
      __IO uint32_t  SRST_asyncrst_spic_sprstn:  1; /*!< SPIC SPI reset                                                        */
      __IO uint32_t  SRST_asyncrst_spic_spifrstn:  1;/*!< SPIC SPIF reset                                                      */
           uint32_t : 28; // padding
    } SRST_ON_PF_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED23;
  
  union {
    __IO uint32_t  SRST_ON_PD;                      /*!< Soft reset ON (PD)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PD and [SRST_OFF_POWERDOMAI
                                                         N].CG_PD.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_sdmac_hrstn:  1; /*!< DMAC reset                                                            */
           uint32_t : 31; // padding
    } SRST_ON_PD_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_ON_PU;                      /*!< Soft reset ON (PU)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PU and [SRST_OFF_POWERDOMAI
                                                         N].CG_PU.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_h2hdnu_hrstn:  1;/*!< H2HSYNCDNU reset                                                      */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_h2hupu_hrstn:  1;/*!< H2HSYNCUPU reset                                                      */
      __IO uint32_t  SRST_asyncrst_usb2fs_hrstn:  1;/*!< USB AHB I/F reset                                                     */
      __IO uint32_t  SRST_asyncrst_usb2fs_usbrstn:  1;/*!< USB USB reset                                                       */
           uint32_t : 27; // padding
    } SRST_ON_PU_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED24;
  
  union {
    __IO uint32_t  SRST_ON_PA12;                    /*!< Soft reset ON (PM)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PM and [SRST_OFF_POWERDOMAI
                                                         N].CG_PM.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_adcc12_prstn:  1;/*!< ADCC12 APB I/F reset                                                  */
      __IO uint32_t  SRST_asyncrst_adcc12_adcrstn:  1;/*!< ADCC12 ADC reset                                                    */
           uint32_t : 30; // padding
    } SRST_ON_PA12_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_ON_PA24;                    /*!< Soft reset ON (PA24)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PA24 and [SRST_OFF_POWERDOM
                                                         AIN].CG_PA24.                                                         */
    
    struct {
      __IO uint32_t  SRST_asyncrst_adcc24_prstn:  1;/*!< ADCC24 APB I/F reset                                                  */
      __IO uint32_t  SRST_asyncrst_adcc24_adcrstn:  1;/*!< ADCC24 ADC reset                                                    */
           uint32_t : 30; // padding
    } SRST_ON_PA24_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_ON_PP1;                     /*!< Soft reset ON (PP1)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PP1 and [SRST_OFF_POWERDOMA
                                                         IN].CG_PP1.                                                           */
    
    struct {
      __IO uint32_t  SRST_asyncrst_h2pp1_hrstn:  1; /*!< H2APBP1 reset                                                         */
           uint32_t             :  3;
      __IO uint32_t  SRST_asyncrst_i2c0_prstn:  1;  /*!< I2C0 APB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_i2c0_srstn:  1;  /*!< I2C0 serial reset                                                     */
      __IO uint32_t  SRST_asyncrst_i2c1_prstn:  1;  /*!< I2C1 APB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_i2c1_srstn:  1;  /*!< I2C1 serial reset                                                     */
      __IO uint32_t  SRST_asyncrst_spim0_prstn:  1; /*!< SPIM0 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim0_srstn:  1; /*!< SPIM0 serial reset                                                    */
      __IO uint32_t  SRST_asyncrst_spim1_prstn:  1; /*!< SPIM1 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim1_srstn:  1; /*!< SPIM1 serial reset                                                    */
      __IO uint32_t  SRST_asyncrst_uart0_prstn:  1; /*!< UART0 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_uart0_srstn:  1; /*!< UART0 serial reset.                                                   */
      __IO uint32_t  SRST_asyncrst_uart1_prstn:  1; /*!< UART1 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_uart1_srstn:  1; /*!< UART1 serial reset.                                                   */
           uint32_t : 16; // padding
    } SRST_ON_PP1_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED25[16];
  
  union {
    __IO uint32_t  SRST_OFF_PM_0;                   /*!< Soft reset OFF (PM)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PM and [SRST_OFF_POWERDOMAI
                                                         N].CG_PM.                                                             */
    
    struct {
           uint32_t             : 20;
      __IO uint32_t  SRST_asyncrst_h2pm_hrstn:  1;  /*!< H2APBM reset                                                          */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_evm_prstn:  1;   /*!< EVM reset                                                             */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_sramc_hrstn:  1; /*!< SRAMC AHB I/F reset                                                   */
           uint32_t             :  2;
      __IO uint32_t  SRST_asyncrst_sramc_prstn:  1; /*!< SRAMC APB I/F reset                                                   */
           uint32_t : 4; // padding
    } SRST_OFF_PM_0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_OFF_PM_1;                   /*!< Soft reset OFF (PM)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PM and [SRST_OFF_POWERDOMAI
                                                         N].CG_PM.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_h2hp0_hrstn:  1; /*!< H2HSYNCDNP0 reset                                                     */
      __IO uint32_t  SRST_asyncrst_h2pp0_hrstn:  1; /*!< H2APBP0 reset                                                         */
      __IO uint32_t  SRST_asyncrst_rtclv_prstn:  1; /*!< RTCLV APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_rtclv_busrstn:  1;/*!< RTCLV timer reset                                                    */
      __IO uint32_t  SRST_asyncrst_wdt_prstn:  1;   /*!< WDT reset.                                                            */
           uint32_t             :  2;
      __IO uint32_t  SRST_asyncrst_advtmr_prstn:  1;/*!< ADVTMR reset                                                          */
           uint32_t             : 11;
      __IO uint32_t  SRST_asyncrst_tmr_prstn:  1;   /*!< TMR reset                                                             */
           uint32_t             :  4;
      __IO uint32_t  SRST_asyncrst_i2c2_prstn:  1;  /*!< I2C2 APB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_i2c2_srstn:  1;  /*!< I2C2 serial reset                                                     */
      __IO uint32_t  SRST_asyncrst_spim2_prstn:  1; /*!< SPIM2 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim2_srstn:  1; /*!< SPIM2 serial reset                                                    */
      __IO uint32_t  SRST_asyncrst_spim3_prstn:  1; /*!< SPIM3 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim3_srstn:  1; /*!< SPIM3 serial reset                                                    */
           uint32_t : 2; // padding
    } SRST_OFF_PM_1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_OFF_PM_2;                   /*!< Soft reset OFF (PM)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PM and [SRST_OFF_POWERDOMAI
                                                         N].CG_PM.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_gconf_prstn:  1; /*!< GCONF APB I/F reset                                                   */
           uint32_t             :  3;
      __IO uint32_t  SRST_asyncrst_gpio0_prstn:  1; /*!< GPIO0 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_gpio1_prstn:  1; /*!< GPIO1 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_gpio2_prstn:  1; /*!< GPIO2 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_gpio3_prstn:  1; /*!< GPIO3 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_h2hp2_hrstn:  1; /*!< H2HSYNCDNP2 reset                                                     */
      __IO uint32_t  SRST_asyncrst_h2pp2_hrstn:  1; /*!< H2APBP2 reset                                                         */
      __IO uint32_t  SRST_asyncrst_uart2_prstn:  1; /*!< UART2 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_uart2_srstn:  1; /*!< UART2 serial reset.                                                   */
           uint32_t             :  4;
      __IO uint32_t  SRST_asyncrst_h2hp1_hrstn:  1; /*!< H2HSYNCDNP1 reset                                                     */
           uint32_t : 15; // padding
    } SRST_OFF_PM_2_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED26;
  
  union {
    __IO uint32_t  SRST_OFF_PE;                     /*!< Soft reset OFF (PE)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PE and [SRST_OFF_POWERDOMAI
                                                         N].CG_PE.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_aesa_rstn:  1;   /*!< AESA reset                                                            */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_rng_rstn:  1;    /*!< RNG reset                                                             */
           uint32_t : 29; // padding
    } SRST_OFF_PE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED27[3];
  
  union {
    __IO uint32_t  SRST_OFF_PF;                     /*!< Soft reset OFF (PF)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PF and [SRST_OFF_POWERDOMAI
                                                         N].CG_PF.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_spic_hrstn:  1;  /*!< SPIC AHB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_spic_srrstn:  1; /*!< SPIC SRAM reset                                                       */
      __IO uint32_t  SRST_asyncrst_spic_sprstn:  1; /*!< SPIC SPI reset                                                        */
      __IO uint32_t  SRST_asyncrst_spic_spifrstn:  1;/*!< SPIC SPIF reset                                                      */
           uint32_t : 28; // padding
    } SRST_OFF_PF_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED28;
  
  union {
    __IO uint32_t  SRST_OFF_PD;                     /*!< Soft reset OFF (PD)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PD and [SRST_OFF_POWERDOMAI
                                                         N].CG_PD.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_sdmac_hrstn:  1; /*!< DMAC reset                                                            */
           uint32_t : 31; // padding
    } SRST_OFF_PD_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_OFF_PU;                     /*!< Soft reset OFF (PU)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PU and [SRST_OFF_POWERDOMAI
                                                         N].CG_PU.                                                             */
    
    struct {
      __IO uint32_t  SRST_asyncrst_h2hdnu_hrstn:  1;/*!< H2HSYNCDNU reset                                                      */
           uint32_t             :  1;
      __IO uint32_t  SRST_asyncrst_h2hupu_hrstn:  1;/*!< H2HSYNCUPU reset                                                      */
      __IO uint32_t  SRST_asyncrst_usb2fs_hrstn:  1;/*!< USB AHB I/F reset                                                     */
      __IO uint32_t  SRST_asyncrst_usb2fs_usbrstn:  1;/*!< USB USB reset                                                       */
           uint32_t : 27; // padding
    } SRST_OFF_PU_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED29;
  
  union {
    __IO uint32_t  SRST_OFF_PA12;                   /*!< Soft reset OFF (PA12)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PA12 and [SRST_OFF_POWERDOM
                                                         AIN].CG_PA12.                                                         */
    
    struct {
      __IO uint32_t  SRST_asyncrst_adcc12_prstn:  1;/*!< ADCC12 APB I/F reset                                                  */
      __IO uint32_t  SRST_asyncrst_adcc12_adcrstn:  1;/*!< ADCC12 ADC reset                                                    */
           uint32_t : 30; // padding
    } SRST_OFF_PA12_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_OFF_PA24;                   /*!< Soft reset OFF (PA24)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PA24 and [SRST_OFF_POWERDOM
                                                         AIN].CG_PA24.                                                         */
    
    struct {
      __IO uint32_t  SRST_asyncrst_adcc24_prstn:  1;/*!< ADCC24 APB I/F reset                                                  */
      __IO uint32_t  SRST_asyncrst_adcc24_adcrstn:  1;/*!< ADCC24 ADC reset                                                    */
           uint32_t : 30; // padding
    } SRST_OFF_PA24_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SRST_OFF_PP1;                    /*!< Soft reset OFF (PP1)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress* Also
                                                          changed by writing to [SRST_ON_POWERDOMAIN].CG_PP1 and [SRST_OFF_POWERDOMA
                                                         IN].CG_PP1.                                                           */
    
    struct {
      __IO uint32_t  SRST_asyncrst_h2pp1_hrstn:  1; /*!< H2APBP1 reset                                                         */
           uint32_t             :  3;
      __IO uint32_t  SRST_asyncrst_i2c0_prstn:  1;  /*!< I2C0 APB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_i2c0_srstn:  1;  /*!< I2C0 serial reset                                                     */
      __IO uint32_t  SRST_asyncrst_i2c1_prstn:  1;  /*!< I2C1 APB I/F reset                                                    */
      __IO uint32_t  SRST_asyncrst_i2c1_srstn:  1;  /*!< I2C1 serial reset                                                     */
      __IO uint32_t  SRST_asyncrst_spim0_prstn:  1; /*!< SPIM0 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim0_srstn:  1; /*!< SPIM0 serial reset                                                    */
      __IO uint32_t  SRST_asyncrst_spim1_prstn:  1; /*!< SPIM1 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_spim1_srstn:  1; /*!< SPIM1 serial reset                                                    */
      __IO uint32_t  SRST_asyncrst_uart0_prstn:  1; /*!< UART0 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_uart0_srstn:  1; /*!< UART0 serial reset.                                                   */
      __IO uint32_t  SRST_asyncrst_uart1_prstn:  1; /*!< UART1 APB I/F reset                                                   */
      __IO uint32_t  SRST_asyncrst_uart1_srstn:  1; /*!< UART1 serial reset.                                                   */
           uint32_t : 16; // padding
    } SRST_OFF_PP1_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED30[16];
  
  union {
    __IO uint32_t  CTRL_MODETRAN;                   /*!< PowerMode Control for #E36                                            */
    
    struct {
      __IO uint32_t  CTRL_MODETRAN:  1;             /*!< 0b0: ES2.1 and before 0b1: ES2.2 and after* This register is
                                                         valid after ES2.2.* It is prohibited to set one until ES2.1
                                                          and must apply the workaround(refer to balvenie_errata #E36).        */
           uint32_t : 31; // padding
    } CTRL_MODETRAN_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_MAIN;                        /*!< Clock source setting (CD_MPIER/CD_PPIER0/CD_PPIER1/CD_PPIER2/CD_SPIC/CD_US
                                                         BB)                                                                   */
    
    struct {
      __IO uint32_t  CSMSEL_MAIN:  3;               /*!< 0b000: SIOSC4M0b001: OSC12M0b010: PLL0b011: ADPLL0b100: OSC32K/SIOSC32K0b1
                                                         01: ignored0b110: ignored0b111: ignored* OSC32K and SIOSC32K
                                                         are switched with [CSM_RTC].* The initial value is determined
                                                          with a value stored in EFUSE.                                        */
           uint32_t : 29; // padding
    } CSM_MAIN_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_CPUTRC;                      /*!< Clock source setting (CD_CPUTRC)                                      */
    
    struct {
      __IO uint32_t  CSMSEL_CPUTRC:  1;             /*!< 0b0:SIOSC4M0b1:OSC12M                                                 */
           uint32_t : 31; // padding
    } CSM_CPUTRC_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_CPUST;                       /*!< Clock source setting (CD_CPUST)                                       */
    
    struct {
      __IO uint32_t  CSMSEL_CPUST:  3;              /*!< 0b000: SIOSC4M0b001: OSC12M0b010: ignored0b011: ignored0b100:
                                                         OSC32K/SIOSC32K0b101: ignored0b110: ignored0b111: ignored* OSC32K
                                                          and SIOSC32K are switched with [CSM_RTC].                            */
           uint32_t : 29; // padding
    } CSM_CPUST_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_USBI;                        /*!< Clock source setting (CD USBI)                                        */
    
    struct {
      __IO uint32_t  CSMSEL_USBI:  1;               /*!< 0b0:PLL0b1:ADPLL                                                      */
           uint32_t : 31; // padding
    } CSM_USBI_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_UART0;                       /*!< Clock source setting (CD UART0)                                       */
    
    struct {
      __IO uint32_t  CSMSEL_UART0:  3;              /*!< 0b000: SIOSC4M0b001: OSC12M0b010: PLL0b011: ADPLL0b100: OSC32K/SIOSC32K0b1
                                                         01: ignored0b110: ignored0b111: ignored* OSC32K and SIOSC32K
                                                         are switched with [CSM_RTC].                                          */
           uint32_t : 29; // padding
    } CSM_UART0_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_UART1;                       /*!< Clock source setting (CD UART1)                                       */
    
    struct {
      __IO uint32_t  CSMSEL_UART1:  3;              /*!< 0b000: SIOSC4M0b001: OSC12M0b010: PLL0b011: ADPLL0b100: OSC32K/SIOSC32K0b1
                                                         01: ignored0b110: ignored0b111: ignored* OSC32K and SIOSC32K
                                                         are switched with [CSM_RTC].                                          */
           uint32_t : 29; // padding
    } CSM_UART1_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_UART2;                       /*!< Clock source setting (CD UART2)                                       */
    
    struct {
      __IO uint32_t  CSMSEL_UART2:  3;              /*!< 0b000: SIOSC4M0b001: OSC12M0b010: PLL0b011: ADPLL0b100: OSC32K/SIOSC32K0b1
                                                         01: ignored0b110: ignored0b111: ignored* OSC32K and SIOSC32K
                                                         are switched with [CSM_RTC].                                          */
           uint32_t : 29; // padding
    } CSM_UART2_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_ADCC12A;                     /*!< Clock source setting (CD ADCC12)                                      */
    
    struct {
      __IO uint32_t  CSMSEL_ADCC12A:  3;            /*!< 0b000: SIOSC4M0b001: OSC12M0b010: PLL0b011: ADPLL0b100: ignored0b101:
                                                         1/3 frequency division of OSC12M0b110: 1/3 frequency division
                                                          of PLL0b111: 1/9 frequency division of PLL* If the value is
                                                          0b101-111, set 0x1 to [PRESCAL_ADCC12A].                             */
           uint32_t : 29; // padding
    } CSM_ADCC12A_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CSM_ADCC24A;                     /*!< Clock source setting (CD ADCC24)                                      */
    
    struct {
      __IO uint32_t  CSMSEL_ADCC24A:  3;            /*!< 0b000: SIOSC4M0b001: OSC12M0b010: PLL0b011: ADPLL0b100: ignored0b101:
                                                         1/3 frequency division of OSC12M0b110: ignored0b111: 1/9 frequency
                                                          division of PLL* If the value is 0b101 or 0b111, set 0x1 to
                                                          [PRESCAL_ADCC24A].                                                   */
           uint32_t : 29; // padding
    } CSM_ADCC24A_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED31[23];
  
  union {
    __IO uint32_t  PRESCAL_MAIN;                    /*!< Prescaler setting (CD_MPIER/CD_PPIER0/CD_PPIER1/CD_PPIER2/CD_SPIC/CD_USBB)
                                                         0x0: Stop0x1: 1/1 frequency division0x2: 1/2 frequency division0x3:
                                                         1/3 frequency division0x4: 1/4 frequency division0x5: 1/5 frequency
                                                          division0x6: 1/6 frequency division0x7: 1/7 frequency division0x8:
                                                          1/8 frequency division0x9: 1/9 frequency division0xA: 1/10 frequency
                                                          division0xB: 1/12 frequency division0xC: 1/18 frequency division0xD:
                                                          1/24 frequency division0xE: 1/36 frequency division0xF: 1/48
                                                          frequency division                                                   */
    
    struct {
      __IO uint32_t  PSSEL_CD_MPIER:  4;            /*!< CD_MPIER* 0x0: Setting prohibited                                     */
      __IO uint32_t  PSSEL_CD_SPIC:  4;             /*!< CD_SPIC* The frequency is divided for the clock selected with
                                                         CSM_MAIN.* Frequency=fCSM_MAIN/DIVPSSEL_CD_SPIC                       */
      __IO uint32_t  PSSEL_CD_USBB:  4;             /*!< CD_USBB* The frequency is divided for the clock selected with
                                                         CSM_MAIN.* Frequency=fCSM_MAIN/(DIVPSSEL_CD_MPIER * DIVPSSEL_CD_USBB) */
      __IO uint32_t  PSSEL_CD_PPIER0:  4;           /*!< CD_PPIER0* The frequency is divided for the clock selected with
                                                         CSM_MAIN.* Frequency=fCSM_MAIN/(DIVPSSEL_CD_MPIER * DIVPSSEL_CD_PPIER0) */
      __IO uint32_t  PSSEL_CD_PPIER1:  4;           /*!< CD_PPIER1* The frequency is divided for the clock selected with
                                                         CSM_MAIN.* Frequency=fCSM_MAIN/(DIVPSSEL_CD_MPIER * DIVPSSEL_CD_PPIER1) */
      __IO uint32_t  PSSEL_CD_PPIER2:  4;           /*!< CD_PPIER2* The frequency is divided for the clock selected with
                                                         CSM_MAIN.* Frequency=fCSM_MAIN/(DIVPSSEL_CD_MPIER * DIVPSSEL_CD_PPIER2) */
           uint32_t : 8; // padding
    } PRESCAL_MAIN_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED32;
  
  union {
    __IO uint32_t  PRESCAL_CPUST;                   /*!< Prescaler setting (CD_CPUST)0x0: Stop0x1: 1/1 frequency division0x2:
                                                         1/2 frequency division0x3: 1/3 frequency division0x4: 1/4 frequency
                                                          division0x5: 1/5 frequency division0x6: 1/6 frequency division0x7:
                                                          1/7 frequency division0x8: 1/8 frequency division0x9: 1/9 frequency
                                                          division0xA: 1/10 frequency division0xB: 1/12 frequency division0xC:
                                                          1/18 frequency division0xD: 1/24 frequency division0xE: 1/36
                                                          frequency division0xF: 1/48 frequency division                       */
    
    struct {
      __IO uint32_t  PSSEL_CD_CPUST:  4;            /*!< CD_CPUST                                                              */
           uint32_t : 28; // padding
    } PRESCAL_CPUST_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PRESCAL_USBI;                    /*!< Prescaler setting (CD_USBI)0x0: Stop0x1: 1/1 frequency division0x2:
                                                         1/2 frequency division0x3: 1/3 frequency division0x4: 1/4 frequency
                                                          division0x5: 1/5 frequency division0x6: 1/6 frequency division0x7:
                                                          1/7 frequency division0x8: 1/8 frequency division0x9: 1/9 frequency
                                                          division0xA: 1/10 frequency division0xB: 1/12 frequency division0xC:
                                                          1/18 frequency division0xD: 1/24 frequency division0xE: 1/36
                                                          frequency division0xF: 1/48 frequency division                       */
    
    struct {
      __IO uint32_t  PSSEL_CD_USBI:  4;             /*!< CD_USBI                                                               */
           uint32_t : 28; // padding
    } PRESCAL_USBI_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PRESCAL_UART0;                   /*!< Prescaler setting (CD_UART0)0x0: Stop0x1: 1/1 frequency division0x2:
                                                         1/2 frequency division0x3: 1/3 frequency division0x4: 1/4 frequency
                                                          division0x5: 1/5 frequency division0x6: 1/6 frequency division0x7:
                                                          1/7 frequency division0x8: 1/8 frequency division0x9: 1/9 frequency
                                                          division0xA: 1/10 frequency division0xB: 1/12 frequency division0xC:
                                                          1/18 frequency division0xD: 1/24 frequency division0xE: 1/36
                                                          frequency division0xF: 1/48 frequency division                       */
    
    struct {
      __IO uint32_t  PSSEL_CD_UART0:  4;            /*!< CD_UART0                                                              */
           uint32_t : 28; // padding
    } PRESCAL_UART0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PRESCAL_UART1;                   /*!< Prescaler setting (CD_UART1)0x0: Stop0x1: 1/1 frequency division0x2:
                                                         1/2 frequency division0x3: 1/3 frequency division0x4: 1/4 frequency
                                                          division0x5: 1/5 frequency division0x6: 1/6 frequency division0x7:
                                                          1/7 frequency division0x8: 1/8 frequency division0x9: 1/9 frequency
                                                          division0xA: 1/10 frequency division0xB: 1/12 frequency division0xC:
                                                          1/18 frequency division0xD: 1/24 frequency division0xE: 1/36
                                                          frequency division0xF: 1/48 frequency division                       */
    
    struct {
      __IO uint32_t  PSSEL_CD_UART1:  4;            /*!< CD_UART1                                                              */
           uint32_t : 28; // padding
    } PRESCAL_UART1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PRESCAL_UART2;                   /*!< Prescaler setting (CD_UART2)0x0: Stop0x1: 1/1 frequency division0x2:
                                                         1/2 frequency division0x3: 1/3 frequency division0x4: 1/4 frequency
                                                          division0x5: 1/5 frequency division0x6: 1/6 frequency division0x7:
                                                          1/7 frequency division0x8: 1/8 frequency division0x9: 1/9 frequency
                                                          division0xA: 1/10 frequency division0xB: 1/12 frequency division0xC:
                                                          1/18 frequency division0xD: 1/24 frequency division0xE: 1/36
                                                          frequency division0xF: 1/48 frequency division                       */
    
    struct {
      __IO uint32_t  PSSEL_CD_UART2:  4;            /*!< CD_UART2                                                              */
           uint32_t : 28; // padding
    } PRESCAL_UART2_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PRESCAL_ADCC12A;                 /*!< Prescaler setting (CD_ADCC12A)0x0: Stop0x1: 1/1 frequency division0x2:
                                                         1/2 frequency division0x3: reserved0x4: 1/4 frequency division0x5:
                                                          reserved0x6: 1/6 frequency division0x7: reserved0x8: 1/8 frequency
                                                          division0x9: reserved0xA: 1/10 frequency division0xB: 1/12 frequency
                                                          division0xC: 1/18 frequency division0xD: 1/24 frequency division0xE:
                                                          1/36 frequency division0xF: 1/48 frequency division* With [CSM_ADCC12A]=0b
                                                         101-111, use the setting of '0x1: 1/1 frequency division'.            */
    
    struct {
      __IO uint32_t  PSSEL_CD_ADCC12A:  4;          /*!< CD_ADCC12A                                                            */
           uint32_t : 28; // padding
    } PRESCAL_ADCC12A_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PRESCAL_ADCC24A;                 /*!< Prescaler setting (CD_ADCC24A)0x0: Stop0x1: 1/1 frequency division0x2:
                                                         1/2 frequency division0x3: reserved0x4: 1/4 frequency division0x5:
                                                          reserved0x6: 1/6 frequency division0x7: reserved0x8: 1/8 frequency
                                                          division0x9: reserved0xA: 1/10 frequency division0xB: 1/12 frequency
                                                          division0xC: 1/18 frequency division0xD: 1/24 frequency division0xE:
                                                          1/36 frequency division0xF: 1/48 frequency division* With [CSM_ADCC24A]=0b
                                                         101 or 0b111, use the setting of '0x1: 1/1 frequency division'.       */
    
    struct {
      __IO uint32_t  PSSEL_CD_ADCC24A:  4;          /*!< CD_ADCC24A                                                            */
           uint32_t : 28; // padding
    } PRESCAL_ADCC24A_b;                            /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED33[22];
  
  union {
    __IO uint32_t  CONFIG_OSC12M;                   /*!< OSC12M control                                                        */
    
    struct {
      __IO uint32_t  OSC12M_EN  :  1;               /*!< Enable control0: Stops OSC.1: Starts OSC.* The initial value
                                                         is determined with a value stored in EFUSE.                           */
           uint32_t : 31; // padding
    } CONFIG_OSC12M_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED34;
  
  union {
    __IO uint32_t  CONFIG_PLL_0;                    /*!< PLL control                                                           */
    
    struct {
      __IO uint32_t  PLL_BP     :  1;               /*!< Sets the bypass mode.0: Normal mode1: Bypass mode* Can be controlled
                                                         from SW regardless of the value of [CONFIG_PLL_0].PLL_SWEN.*
                                                          The initial value is determined with a value stored in EFUSE.        */
           uint32_t             : 30;
      __IO uint32_t  PLL_SWEN   :  1;               /*!< SW control enable0: Any terminals of PLL other than BP cannot
                                                         be controlled from SW.1: All terminals of PLL can be controlled
                                                          from SW.                                                             */
    } CONFIG_PLL_0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_PLL_1;                    /*!< PLL control                                                           */
    
    struct {
      __IO uint32_t  PLL_ND     :  2;               /*!< PLL_ND                                                                */
           uint32_t             :  2;
      __IO uint32_t  PLL_BW     :  2;               /*!< PLL_BW                                                                */
      __IO uint32_t  PLL_IS     :  2;               /*!< * Can be controlled from SW for [CONFIG_PLL_0].PLL_SWEN=1.            */
           uint32_t : 24; // padding
    } CONFIG_PLL_1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_ADPLL_0;                  /*!< ADPLL control                                                         */
    
    struct {
      __IO uint32_t  ADPLL_ENPLL:  1;               /*!< Operation control0: Disable1: Enable                                  */
           uint32_t : 31; // padding
    } CONFIG_ADPLL_0_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_ADPLL_1;                  /*!< ADPLL control                                                         */
    
    struct {
      __IO uint32_t  ADPLL_NTWMODE:  1;             /*!< Sets the Normalized Tuning Word mode.0: Disable (Internal Mode)1:
                                                         Enable (External Mode)                                                */
           uint32_t             :  1;
      __IO uint32_t  ADPLL_NTWOUT_LATEN:  1;        /*!< Normalized Tuning Word output latch enable control0: Disable1:
                                                         Enable                                                                */
           uint32_t             :  1;
      __I  uint32_t  ADPLL_NTWIN: 10;               /*!< Normalized Tuning Word input                                          */
           uint32_t : 18; // padding
    } CONFIG_ADPLL_1_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED35[4];
  
  union {
    __IO uint32_t  CONFIG_DCDC_LVREG_1;             /*!< DCDC control                                                          */
    
    struct {
           uint32_t             : 18;
      __IO uint32_t  DCDC_SSFAST:  1;               /*!< Soft start control0: Enable (slow)1: Disable (fast)                   */
           uint32_t : 13; // padding
    } CONFIG_DCDC_LVREG_1_b;                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED36;
  
  union {
    __IO uint32_t  CONFIG_LDOF_0;                   /*!< LDOF control                                                          */
    
    struct {
      __IO uint32_t  LDOF_STANDBYMX:  1;            /*!< Enable control0: Power down1: Operation* 0 -> 1 in the reset
                                                         release sequence                                                      */
      __I  uint32_t  LDOF_POWERGOODM:  1;           /*!< Low voltage detection0: Low voltage1: Proper voltage* 0 -> 1
                                                         in the reset release sequence                                         */
           uint32_t : 30; // padding
    } CONFIG_LDOF_0_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED37[19];
  
  union {
    __IO uint32_t  OVERRIDE_EFUSE_OSC12M;           /*!< OSC12M control* With [SELECT_EFUSE].SEL_EFUSE_OSC12M=0, EFUSE
                                                         data is reloaded with write access. With [SELECT_EFUSE].SEL_EFUSE_OSC12M=1
                                                         , write data is applied.* The initial value is determined with
                                                          a value stored in EFUSE.                                             */
    
    struct {
      __IO uint32_t  OVERRIDE_EFUSE_OSC12M_MAIN_GM:  4;/*!< XO_Main GM adjustment0b0000:Mode0(recommended)0b0001:Mode10b0011:Mode20b01
                                                         11:Mode3*The setting value other than above is prohibited.*The
                                                         setting value will be changed from 0b0111 to 0b0000 by boot
                                                          sequencer.                                                           */
           uint32_t : 28; // padding
    } OVERRIDE_EFUSE_OSC12M_b;                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED38[11];
  
  union {
    __IO uint32_t  OVERRIDE_EFUSE_LDOF;             /*!< LDOF control* With [SELECT_EFUSE].SEL_EFUSE_LDOF=0, EFUSE data
                                                         is reloaded with write access. With [SELECT_EFUSE].SEL_EFUSE_LDOF=1,
                                                          write data is applied.* The initial value is determined with
                                                          a value stored in EFUSE.                                             */
    
    struct {
      __IO uint32_t  OVERRIDE_EFUSE_LDOF_RSV:  7;   /*!< reserved                                                              */
           uint32_t : 25; // padding
    } OVERRIDE_EFUSE_LDOF_b;                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED39[3];
  
  union {
    __IO uint32_t  SELECT_EFUSE;                    /*!< Selects data to be stored in the OVERRIDE register.0: EFUSE
                                                         data1: Write data                                                     */
    
    struct {
      __IO uint32_t  SEL_EFUSE_OSC12M:  1;          /*!< OSC12M* Control of [OVERRIDE_EFUSE_OSC12M]                            */
           uint32_t             :  4;
      __IO uint32_t  SEL_EFUSE_BGR:  1;             /*!< BGR* Control of [OVERRIDE_EFUSE_BGR_0],[OVERRIDE_EFUSE_BGR_1]         */
      __IO uint32_t  SEL_EFUSE_LDOF:  1;            /*!< LDOF* Control of [OVERRIDE_EFUSE_LDOF]                                */
           uint32_t             :  3;
      __IO uint32_t  SEL_EFUSE_OSC32K:  1;          /*!< OSC32K* Control of [OVERRIDE_EFUSE_OSC32K]                            */
      __IO uint32_t  SEL_EFUSE_SiOSC32K:  1;        /*!< SIOSC32K* Control of [OVERRIDE_EFUSE_SiOSC32K]                        */
      __IO uint32_t  SEL_EFUSE_SiOSC4M:  1;         /*!< SIOSC4M* Control of [OVERRIDE_EFUSE_SiOSC4M]                          */
           uint32_t : 19; // padding
    } SELECT_EFUSE_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED40[6];
  
  union {
    __I  uint32_t  EFUSE_REVISIONID;                /*!< REVISIONID* The initial value is determined with a value stored
                                                         in EFUSE.                                                             */
    
    struct {
      __I  uint32_t  EFUSE_REVISIONID: 32;          /*!< [31:28]:Reserved[27:24]:ID for geomagnetic sensor(revision ID
                                                         for the mounted geomagnetic sensor chip) 0b0000:not mounted
                                                          0b0001:geomagnetic sensor identification1 0b0010:geomagnetic
                                                          sensor identification2[23:20]:ID for gyro sensor(revision ID
                                                          for the mounted gyro sensor chip) 0b0000:not mounted 0b0001:gyro
                                                          sensor identification1 0b0010:gyro sensor identification2[19:16]:ID
                                                          for accelaration sensor(revision ID for the mounted accelaration
                                                          sensor chip) 0b0000:not mounted 0b0001:accelaration sensor identifica */
    } EFUSE_REVISIONID_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  EFUSE_BOOTSEQ;                   /*!< BOOTSEQ* The initial value is determined with a value stored
                                                         in EFUSE.                                                             */
    
    struct {
      __I  uint32_t  EFUSE_SEL_FLASH:  1;           /*!< FLASH selection0: winbond1: macronics                                 */
           uint32_t             :  3;
      __I  uint32_t  EFUSE_SEL_CSM_MAIN:  2;        /*!< Selects CSM_MAIN at CPU start.0b00: PLL0b01: OSC12Mother: SIOSC4M     */
           uint32_t             :  2;
      __I  uint32_t  EFUSE_SCR_EN:  1;              /*!< Control access to the internal FLASH.0: disable1: enable              */
           uint32_t : 23; // padding
    } EFUSE_BOOTSEQ_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  EFUSE_SiOSC4M;                   /*!< SiOS4M Oscillation frequency adjustment* The initial value is
                                                         determined with a value stored in EFUSE.                              */
    
    struct {
      __I  uint32_t  EFUSE_SiOSC4M_CTRIM_MODEA:  8; /*!< Mode A (1.2V)                                                         */
      __I  uint32_t  EFUSE_SiOSC4M_CTRIM_MODEB:  8; /*!< Mode B (1.1V)                                                         */
      __I  uint32_t  EFUSE_SiOSC4M_CTRIM_MODEC:  8; /*!< Mode C (1.0V)                                                         */
      __I  uint32_t  EFUSE_SiOSC4M_CTRIM_MODED:  8; /*!< Mode D (0.9V)                                                         */
    } EFUSE_SiOSC4M_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED41[6];
  
  union {
    __IO uint32_t  BROWNOUTRESET;                   /*!< Brownout soft reset* Used together with the Brownout interrupt.
                                                         The Brownout reset can be made by writing 1 to this register
                                                          after a CPU interrupt.                                               */
    
    struct {
      __IO uint32_t  BOR        :  1;               /*!< [Write]1: Assert. 0: Ignored.[Read]1: Assert. 0: Deassert             */
           uint32_t : 31; // padding
    } BROWNOUTRESET_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED42[63];
  
  union {
    __IO uint32_t  MOVE_VOLTAGE_START;              /*!< Voltage Mode transition setting                                       */
    
    struct {
      __IO uint32_t  START      :  1;               /*!< Starts Voltage Mode transition.[Write]1: Start. 0: Ignored.[Read]1:
                                                         Transition in progress. 0: Stop                                       */
           uint32_t             :  1;
      __I  uint32_t  VMSTATUS   :  2;               /*!< Voltage Mode status0b00: Mode A (1.2V)0b01: Mode B (1.1V)0b10:
                                                         Mode C (1.0V)0b11: Mode D (0.9V)                                      */
           uint32_t : 28; // padding
    } MOVE_VOLTAGE_START_b;                         /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  MOVE_POWER_VOLTAGE_MODE;         /*!< Power/Voltage Mode transition setting                                 */
    
    struct {
      __IO uint32_t  VOLTAGE_MODE:  2;              /*!< Sets a Voltage Mode transition destination.0b00: Mode A (1.2V)0b01:
                                                         Mode B (1.1V)0b10: Mode C (1.0V)0b11: Mode D (0.9V)                   */
           uint32_t             :  2;
      __IO uint32_t  POWER_MODE :  4;               /*!< Sets a Power Mode transition destination.0b0000: ACTIVE (Voltage
                                                         Mode transition)0b0001: SLEEP00b0010: SLEEP10b0011: SLEEP20b0100:
                                                          WAIT0b0101: WAIT-RETENTION0b0110: reserved0b0111: RETENTION0b1000:
                                                          RTC0b1001: STOPother: reserved                                       */
      __IO uint32_t  FAST_MODE  :  1;               /*!< High-speed return mode (only WAIT/WAIT-RETENTION/RETENTION)0:
                                                         Normal return mode Returns to Voltage Mode used before transition.1:
                                                          High-speed return mode ModeD is started up at return. So, a
                                                          higher speed return is made because the mode is not returned
                                                          to Voltage Mode before transition.                                   */
           uint32_t : 23; // padding
    } MOVE_POWER_VOLTAGE_MODE_b;                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED43[2];
  
  union {
    __IO uint32_t  POWERDOMAIN_CTRL;                /*!< Starts power supply domain control.[Write]1: Start. 0: Ignored.[Read]1:
                                                         Transition in progress. 0: Stop* The power supply domain cannot
                                                          be controlled for PM with SW.                                        */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  START_PE   :  1;               /*!< For PE power supply domain control                                    */
      __IO uint32_t  START_PS0  :  1;               /*!< For PS0 power supply domain control                                   */
      __IO uint32_t  START_PS1  :  1;               /*!< For PS1 power supply domain control                                   */
      __IO uint32_t  START_PS2  :  1;               /*!< For PS2 power supply domain control                                   */
      __IO uint32_t  START_PF   :  1;               /*!< For PF power supply domain control                                    */
      __IO uint32_t  START_PC   :  1;               /*!< For PC power supply domain control                                    */
      __IO uint32_t  START_PD   :  1;               /*!< For PD power supply domain control                                    */
           uint32_t             :  1;
      __IO uint32_t  START_PA12 :  1;               /*!< For PA12 power supply domain control                                  */
      __IO uint32_t  START_PA24 :  1;               /*!< For PA24 power supply domain control                                  */
      __IO uint32_t  START_PP1  :  1;               /*!< For PP1 power supply domain control                                   */
           uint32_t : 20; // padding
    } POWERDOMAIN_CTRL_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  POWERDOMAIN_CTRL_MODE;           /*!< Sets a power supply domain control transition destination.0b00:
                                                         Power On0b01: Power Off0b10: RETENTION0b11: WAIT (only PS0,PS1,and
                                                          PS2 settable)                                                        */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  PDMODE_PE  :  2;               /*!< For PE power supply domain control                                    */
      __IO uint32_t  PDMODE_PS0 :  2;               /*!< For PS0 power supply domain control                                   */
      __IO uint32_t  PDMODE_PS1 :  2;               /*!< For PS1 power supply domain control                                   */
      __IO uint32_t  PDMODE_PS2 :  2;               /*!< For PS2 power supply domain control                                   */
      __IO uint32_t  PDMODE_PF  :  2;               /*!< For PF power supply domain control                                    */
      __IO uint32_t  PDMODE_PC  :  2;               /*!< For PC power supply domain control                                    */
      __IO uint32_t  PDMODE_PD  :  2;               /*!< For PD power supply domain control                                    */
           uint32_t             :  2;
      __IO uint32_t  PDMODE_PA12:  2;               /*!< For PA12 power supply domain control                                  */
      __IO uint32_t  PDMODE_PA24:  2;               /*!< For PA24 power supply domain control                                  */
      __IO uint32_t  PDMODE_PP1 :  2;               /*!< For PP1 power supply domain control                                   */
           uint32_t : 8; // padding
    } POWERDOMAIN_CTRL_MODE_b;                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  POWERDOMAIN_CTRL_STATUS;         /*!< Power supply domain control status0b00: Power On0b01: Power
                                                         Off0b10: RETENTION0b11: WAIT (only PS0,PS1,and PS2 used)              */
    
    struct {
           uint32_t             :  2;
      __I  uint32_t  PDSTATUS_PE:  2;               /*!< For PE power supply domain control                                    */
      __I  uint32_t  PDSTATUS_PS0:  2;              /*!< For PS0 power supply domain control                                   */
      __I  uint32_t  PDSTATUS_PS1:  2;              /*!< For PS1 power supply domain control                                   */
      __I  uint32_t  PDSTATUS_PS2:  2;              /*!< For PS2 power supply domain control                                   */
      __I  uint32_t  PDSTATUS_PF:  2;               /*!< For PF power supply domain control                                    */
      __I  uint32_t  PDSTATUS_PC:  2;               /*!< For PC power supply domain control                                    */
      __I  uint32_t  PDSTATUS_PD:  2;               /*!< For PD power supply domain control                                    */
           uint32_t             :  2;
      __I  uint32_t  PDSTATUS_PA12:  2;             /*!< For PA12 power supply domain control                                  */
      __I  uint32_t  PDSTATUS_PA24:  2;             /*!< For PA24 power supply domain control                                  */
      __I  uint32_t  PDSTATUS_PP1:  2;              /*!< For PP1 power supply domain control                                   */
           uint32_t : 8; // padding
    } POWERDOMAIN_CTRL_STATUS_b;                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED44;
  
  union {
    __IO uint32_t  POWERDOMAIN_CTRL_MODE_FOR_WAIT;  /*!< Sets a power supply domain control transition destination in
                                                         WAIT mode.0b00:PowerOn0b01: Power Off0b10: RETENTION0b11: WAIT
                                                          (only PS0,PS1,and PS2 used)                                          */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  PDMODE_FOR_WAIT_PS0:  2;       /*!< For PS0 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_WAIT_PS1:  2;       /*!< For PS1 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_WAIT_PS2:  2;       /*!< For PS2 power supply domain control                                   */
           uint32_t : 22; // padding
    } POWERDOMAIN_CTRL_MODE_FOR_WAIT_b;             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  POWERDOMAIN_CTRL_MODE_FOR_WRET;  /*!< Sets a power supply domain control transition destination in
                                                         WAIT-RETENTION mode.0b00: Power On0b01: Power Off (PC unsettable)0b10:RETE
                                                         NTION0b11:WAIT (only PS0,PS1,and PS2 used)                            */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  PDMODE_FOR_WRET_PE:  2;        /*!< For PE power supply domain control                                    */
      __IO uint32_t  PDMODE_FOR_WRET_PS0:  2;       /*!< For PS0 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_WRET_PS1:  2;       /*!< For PS1 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_WRET_PS2:  2;       /*!< For PS2 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_WRET_PF:  2;        /*!< For PF power supply domain control                                    */
      __IO uint32_t  PDMODE_FOR_WRET_PC:  2;        /*!< For PC power supply domain control                                    */
      __IO uint32_t  PDMODE_FOR_WRET_PD:  2;        /*!< For PD power supply domain control                                    */
           uint32_t             :  2;
      __IO uint32_t  PDMODE_FOR_WRET_PA12:  2;      /*!< For PA12 power supply domain control                                  */
      __IO uint32_t  PDMODE_FOR_WRET_PA24:  2;      /*!< For PA24 power supply domain control                                  */
      __IO uint32_t  PDMODE_FOR_WRET_PP1:  2;       /*!< For PP1 power supply domain control                                   */
           uint32_t : 8; // padding
    } POWERDOMAIN_CTRL_MODE_FOR_WRET_b;             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  POWERDOMAIN_CTRL_MODE_FOR_RET;   /*!< Sets a power supply domain control transition destination in
                                                         RETENTION mode.0b00: Setting prohibited0b01: Power Off(PC unsettable)0b10:
                                                          RETENTION0b11: Setting prohibited                                    */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  PDMODE_FOR_RET_PE:  2;         /*!< For PE power supply domain control                                    */
      __IO uint32_t  PDMODE_FOR_RET_PS0:  2;        /*!< For PS0 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_RET_PS1:  2;        /*!< For PS1 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_RET_PS2:  2;        /*!< For PS2 power supply domain control                                   */
      __IO uint32_t  PDMODE_FOR_RET_PF:  2;         /*!< For PF power supply domain control                                    */
      __IO uint32_t  PDMODE_FOR_RET_PC:  2;         /*!< For PC power supply domain control                                    */
      __IO uint32_t  PDMODE_FOR_RET_PD:  2;         /*!< For PD power supply domain control                                    */
           uint32_t             :  2;
      __IO uint32_t  PDMODE_FOR_RET_PA12:  2;       /*!< For PA12 power supply domain control                                  */
      __IO uint32_t  PDMODE_FOR_RET_PA24:  2;       /*!< For PA24 power supply domain control                                  */
      __IO uint32_t  PDMODE_FOR_RET_PP1:  2;        /*!< For PP1 power supply domain control                                   */
           uint32_t : 8; // padding
    } POWERDOMAIN_CTRL_MODE_FOR_RET_b;              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED45;
  
  union {
    __IO uint32_t  VOLTAGEMODE_SETTING;             /*!< Voltage Mode setting                                                  */
    
    struct {
      __I  uint32_t  VOLTAGESOURCE_MODEA:  1;       /*!< 0:DCDC                                                                */
      __IO uint32_t  VOLTAGESOURCE_MODEB:  1;       /*!< 0:DCDC, 1:LDOM                                                        */
      __IO uint32_t  VOLTAGESOURCE_MODEC:  1;       /*!< 0:DCDC, 1:LDOM                                                        */
      __IO uint32_t  VOLTAGESOURCE_MODED:  1;       /*!< 0:LDOS, 1:LDOM                                                        */
           uint32_t : 28; // padding
    } VOLTAGEMODE_SETTING_b;                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED46[3];
  
  union {
    __IO uint32_t  WAITTIME_LDOF;                   /*!< Wait time at LDOF Power On/Off switching0us(0x00)-630us(0x3f)*units
                                                         of 10us                                                               */
    
    struct {
      __IO uint32_t  WAITTIME_LDOF_PWON:  6;        /*!< Sets the period from On control until power is stably supplied
                                                         to the target (initial value: 300us).                                 */
           uint32_t             : 10;
      __IO uint32_t  WAITTIME_LDOF_PWOFF:  6;       /*!< Sets the period from Off control until power to the target is
                                                         turned off (initial value: 300us).                                    */
           uint32_t : 10; // padding
    } WAITTIME_LDOF_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  WAITTIME_PSW;                    /*!< Wait time at Internal Power Switch Power On/Off switching (only
                                                         PS0,PS1,and PS2 used)1us(0x0)-16us(0xf)*units of 1us                  */
    
    struct {
      __IO uint32_t  WAITTIME_PSW_PWON:  4;         /*!< Sets the period from On control until power is stably supplied
                                                         to the target (initial value: 16us).                                  */
           uint32_t             : 12;
      __IO uint32_t  WAITTIME_PSW_PWOFF:  4;        /*!< Sets the period from Off control until power to the target is
                                                         turned off (initial value: 16us)                                      */
           uint32_t : 12; // padding
    } WAITTIME_PSW_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  WAITTIME_DVSCTL;                 /*!< Wait time at power source or voltage switching*units of 1us           */
    
    struct {
      __IO uint32_t  WAITTIME_DCDC_tDE:  6;         /*!< Wait time from a rising edge of DCDC EN_DCDCREF until a rising
                                                         edge of EN_DCDC (initial value: 30us)0us(0x00)-63us(0x3f)* units
                                                          of 1us                                                               */
           uint32_t             :  2;
      __IO uint32_t  WAITTIME_CHGTIME:  9;          /*!< Wait time until the power source is switched (initial value:
                                                         30us)0us(0x000)-511us(0x1ff)*units of 1us                             */
           uint32_t             :  3;
      __IO uint32_t  WAITTIME_SBSTIME:  5;          /*!< Wait time until voltage is switched (step time when voltage
                                                         is increased every 0.1V) (initial value: 10us)0us(0x00)-31us(0x1f)*
                                                          0 setting: No step execution* units of 1us                           */
           uint32_t : 7; // padding
    } WAITTIME_DVSCTL_b;                            /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED47[13];
  
  union {
    __IO uint32_t  POWERMODE_SLEEP_CG_ON;           /*!< Block to be subject to clock gating ON addition control in SLEEP
                                                         mode0: No clock stop addition control1: Clock stop addition
                                                          control available                                                    */
    
    struct {
      __IO uint32_t  SLEEP_CG_ON_mpier:  1;         /*!< MPIER                                                                 */
      __IO uint32_t  SLEEP_CG_ON_sdmac:  1;         /*!< SDMAC                                                                 */
      __IO uint32_t  SLEEP_CG_ON_aesa:  1;          /*!< AESA                                                                  */
      __IO uint32_t  SLEEP_CG_ON_rng:  1;           /*!< RNG                                                                   */
      __IO uint32_t  SLEEP_CG_ON_sramc:  1;         /*!< SRAMC                                                                 */
      __IO uint32_t  SLEEP_CG_ON_spic:  1;          /*!< SPIC                                                                  */
      __IO uint32_t  SLEEP_CG_ON_uart0:  1;         /*!< UART0                                                                 */
      __IO uint32_t  SLEEP_CG_ON_uart1:  1;         /*!< UART1                                                                 */
      __IO uint32_t  SLEEP_CG_ON_uart2:  1;         /*!< UART2                                                                 */
      __IO uint32_t  SLEEP_CG_ON_i2c0:  1;          /*!< I2C0                                                                  */
      __IO uint32_t  SLEEP_CG_ON_i2c1:  1;          /*!< I2C1                                                                  */
      __IO uint32_t  SLEEP_CG_ON_i2c2:  1;          /*!< I2C2                                                                  */
      __IO uint32_t  SLEEP_CG_ON_spim0:  1;         /*!< SPIM0                                                                 */
      __IO uint32_t  SLEEP_CG_ON_spim1:  1;         /*!< SPIM1                                                                 */
      __IO uint32_t  SLEEP_CG_ON_spim2:  1;         /*!< SPIM2                                                                 */
      __IO uint32_t  SLEEP_CG_ON_spim3:  1;         /*!< SPIM3                                                                 */
      __IO uint32_t  SLEEP_CG_ON_wdt:  1;           /*!< WDT                                                                   */
      __IO uint32_t  SLEEP_CG_ON_advtmr:  1;        /*!< ADVTMR                                                                */
      __IO uint32_t  SLEEP_CG_ON_tmr:  1;           /*!< TMR                                                                   */
      __IO uint32_t  SLEEP_CG_ON_gconf:  1;         /*!< GCONF                                                                 */
      __IO uint32_t  SLEEP_CG_ON_gpio0:  1;         /*!< GPIO0                                                                 */
      __IO uint32_t  SLEEP_CG_ON_gpio1:  1;         /*!< GPIO1                                                                 */
      __IO uint32_t  SLEEP_CG_ON_gpio2:  1;         /*!< GPIO2                                                                 */
      __IO uint32_t  SLEEP_CG_ON_gpio3:  1;         /*!< GPIO3                                                                 */
      __IO uint32_t  SLEEP_CG_ON_adcc12:  1;        /*!< ADCC12                                                                */
      __IO uint32_t  SLEEP_CG_ON_adcc24:  1;        /*!< ADCC24                                                                */
      __IO uint32_t  SLEEP_CG_ON_rtclv:  1;         /*!< RTCLV                                                                 */
      __IO uint32_t  SLEEP_CG_ON_evm:  1;           /*!< EVM                                                                   */
      __IO uint32_t  SLEEP_CG_ON_cputrcclk_cpu_traceclk:  1;/*!< CPU trace clock                                               */
      __IO uint32_t  SLEEP_CG_ON_cpustclk_cpu_stclk:  1;/*!< CPU SYSTICK clock                                                 */
           uint32_t : 2; // padding
    } POWERMODE_SLEEP_CG_ON_b;                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED48[3];
  
  union {
    __IO uint32_t  POWERMODE_SLEEP_PRESCAL;         /*!< prescaler setting in SLEEP mode                                       */
    
    struct {
      __IO uint32_t  SLEEP_PSSEL_mpierclk_cpu_fclk:  1;/*!< CPU free-run clock0: 1/1 frequency division1: 1/4 frequency
                                                         division* Only with a mode transition by sleeping. With a mode
                                                          transition by sleepdeep, CPU free-tun clock is stopped.* Frequency=fCSM_MA
                                                         IN/(DIVPSSEL_CD_MPIER * DIVSLEEP_PSSEL_mpierclk_cpu_fclk)             */
           uint32_t : 31; // padding
    } POWERMODE_SLEEP_PRESCAL_b;                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED49[612];
  
  union {
    __IO uint32_t  CG_ON_PC_SCRT;                   /*!< Clock gating ON (PC)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN_SCRT].CG_PC_SCRT and [CG_OFF_POWERDOMAIN_
                                                         SCRT].CG_PC_SCRT.                                                     */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  CG_cputrcclk_cpu_traceclk:  1; /*!< CPU trace clock                                                       */
           uint32_t : 29; // padding
    } CG_ON_PC_SCRT_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED50[31];
  
  union {
    __IO uint32_t  CG_OFF_PC_SCRT;                  /*!< Clock gating OFF (PC)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.* Also changed
                                                          by writing to [CG_ON_POWERDOMAIN_SCRT].CG_PC_SCRT and [CG_OFF_POWERDOMAIN_
                                                         SCRT].CG_PC_SCRT.                                                     */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  CG_cputrcclk_cpu_traceclk:  1; /*!< CPU trace clock                                                       */
           uint32_t : 29; // padding
    } CG_OFF_PC_SCRT_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED51[918];
  
  union {
    __IO uint32_t  CG_ON_PA;                        /*!< Clock gating ON (PA)[Write]1: Clock stops. 0: Ignored.[Read]1:
                                                         Clock is stopped. 0: Clock is being supplied.                         */
    
    struct {
      __IO uint32_t  CG_rtcclk_rtchv_rtcclk:  1;    /*!< RTCHV clock                                                           */
           uint32_t             :  7;
      __IO uint32_t  CG_32KOSC_pmulv:  1;           /*!< PMULV clock                                                           */
           uint32_t             :  7;
      __IO uint32_t  CG_CLK32K_OUT:  1;             /*!< External clock                                                        */
           uint32_t : 15; // padding
    } CG_ON_PA_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED52[3];
  
  union {
    __IO uint32_t  CG_OFF_PA;                       /*!< Clock gating OFF (PA)[Write]1: Clock is supplied. 0: Ignored.[Read]1:
                                                         Clock is being supplied. 0: Clock is stopped.                         */
    
    struct {
      __IO uint32_t  CG_rtcclk_rtchv_rtcclk:  1;    /*!< RTCHV clock                                                           */
           uint32_t             :  7;
      __IO uint32_t  CG_32KOSC_pmulv:  1;           /*!< PMULV clock                                                           */
           uint32_t             :  7;
      __IO uint32_t  CG_CLK32K_OUT:  1;             /*!< External clock                                                        */
           uint32_t : 15; // padding
    } CG_OFF_PA_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED53[3];
  
  union {
    __IO uint32_t  SRST_ON_PA;                      /*!< Soft reset ON (PA)[Write]1: Reset assert. 0: Ignored.[Read]1:
                                                         Reset assert in progress. 0: Reset deassert in progress.              */
    
    struct {
      __IO uint32_t  SRST_asyncrst_rtchv_rtcrstn:  1;/*!< RTCHV reset                                                          */
           uint32_t : 31; // padding
    } SRST_ON_PA_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED54[3];
  
  union {
    __IO uint32_t  SRST_OFF_PA;                     /*!< Soft reset OFF (PA)[Write]1: Reset deassert. 0: Ignored.[Read]1:
                                                         Reset deassert in progress. 0: Reset assert in progress.              */
    
    struct {
      __IO uint32_t  SRST_asyncrst_rtchv_rtcrstn:  1;/*!< RTCHV reset                                                          */
           uint32_t : 31; // padding
    } SRST_OFF_PA_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED55[19];
  
  union {
    __IO uint32_t  CSM_RTC;                         /*!< Clock source setting (CD_RTC)                                         */
    
    struct {
      __IO uint32_t  CSMSEL_RTC :  1;               /*!< 0b0:OSC32K0b1:SIOSC32K                                                */
           uint32_t : 31; // padding
    } CSM_RTC_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED56[15];
  
  union {
    __IO uint32_t  RTCLV_RSYNC_SETTING;             /*!< RTCLV timer reset selection                                           */
    
    struct {
      __IO uint32_t  RTCLV_RSYNC_SETTING:  2;       /*!< 0b00: Synchronized to SiOSC4M0b01: Synchronized to OSC32K/SIOSC32K
                                                         (1 cycle)0b10: Synchronized to OSC32K/SIOSC32K (2 cycles)0b11:
                                                          reserved* OSC32K and SIOSC32K are switched with [CSM_RTC].           */
           uint32_t : 30; // padding
    } RTCLV_RSYNC_SETTING_b;                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED57[15];
  
  union {
    __IO uint32_t  CONFIG_OSC32K;                   /*!< OSC32K control                                                        */
    
    struct {
      __IO uint32_t  OSC32K_EN  :  1;               /*!< Enable control0: Stops OSC.1: Starts OSC.                             */
           uint32_t             :  1;
      __IO uint32_t  OSC32K_BOOST_DISABLE:  1;      /*!< High-speed startup disable control0: High-speed mode enable1:
                                                         High-speed mode disable                                               */
           uint32_t : 29; // padding
    } CONFIG_OSC32K_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_SiOSC32K;                 /*!< SIOSC32K control                                                      */
    
    struct {
      __IO uint32_t  SiOSC32K_EN:  1;               /*!< Enable control0: Power down1: Oscillation                             */
           uint32_t : 31; // padding
    } CONFIG_SiOSC32K_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_SiOSC4M;                  /*!< SIOSC4M control                                                       */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  SiOSC4M_CTRIM_LAT:  1;         /*!< CTRIM latch control0: Through latch1: Hold (100ns or more)            */
           uint32_t : 27; // padding
    } CONFIG_SiOSC4M_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_DCDC_HVREG;               /*!< DCDC control                                                          */
    
    struct {
      __IO uint32_t  DCDC_STANDBYX:  1;             /*!< DCDC enable control0: Power down1: Operation* 0 -> 1 in the
                                                         power-on sequence                                                     */
      __I  uint32_t  DCDC_POWERGOOD:  1;            /*!< Low voltage detection0: Low voltage1: Proper voltage* 0 -> 1
                                                         in the power-on sequence                                              */
           uint32_t : 30; // padding
    } CONFIG_DCDC_HVREG_b;                          /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED58[2];
  
  union {
    __IO uint32_t  CONFIG_LVD_0;                    /*!< LVD control                                                           */
    
    struct {
           uint32_t             :  1;
      __I  uint32_t  LVD_POWERGOOD:  1;             /*!< Low voltage detection0: Low voltage1: Proper voltage* 0 -> 1
                                                         in the power-on sequence                                              */
           uint32_t : 30; // padding
    } CONFIG_LVD_0_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED59;
  
  union {
    __IO uint32_t  CONFIG_LDOM_0;                   /*!< LDOM control                                                          */
    
    struct {
      __IO uint32_t  LDOM_STANDBYMX:  1;            /*!< Enable control0: Power down1: Operation                               */
      __I  uint32_t  LDOM_POWERGOODM:  1;           /*!< Low voltage detection0: Low voltage1: Proper voltage                  */
           uint32_t : 30; // padding
    } CONFIG_LDOM_0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_LDOM_1;                   /*!< LDOM control                                                          */
    
    struct {
      __IO uint32_t  LDOM_SETOUT:  3;               /*!< Sets output voltage.0bx00: 1.2V0bx01: 1.1V0bx10: 1.0V0bx11:
                                                         0.9V(x: dont care)                                                    */
           uint32_t : 29; // padding
    } CONFIG_LDOM_1_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED60[2];
  
  union {
    __IO uint32_t  CONFIG_LDOS_0;                   /*!< LDOS control                                                          */
    
    struct {
      __IO uint32_t  LDOS_STANDBYMX:  1;            /*!< Enable control0: Power down1: Operation                               */
           uint32_t : 31; // padding
    } CONFIG_LDOS_0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CONFIG_LDOS_1;                   /*!< LDOS control                                                          */
    
    struct {
      __IO uint32_t  LDOS_SETOUT:  3;               /*!< Sets output voltage.0b000: 1.2V0b001: 1.1V0b010: 1.0V0b011:
                                                         0.9V0b1xx: 0.8V(x: dont care)                                         */
           uint32_t : 29; // padding
    } CONFIG_LDOS_1_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED61[18];
  
  union {
    __IO uint32_t  OVERRIDE_EFUSE_OSC32K;           /*!< OSC32K control* With [SELECT_EFUSE].SEL_EFUSE_OSC32K=0, EFUSE
                                                         data is reloaded with write access. With [SELECT_EFUSE].SEL_EFUSE_OSC32K=1
                                                         , write data is applied.* The initial value is determined with
                                                          a value stored in EFUSE.                                             */
    
    struct {
      __IO uint32_t  OVERRIDE_EFUSE_OSC32K_TRIMIN:  5;/*!< Adjustment bit (current switching or the like assumed)0b00110:Mode0/Mode1/
                                                         Mode2/Mode40b00111:Mode3/Mode50b01111:Mode60b11111:Mode7*The
                                                         setting value other than above are prohited                           */
           uint32_t             :  3;
      __IO uint32_t  OVERRIDE_EFUSE_OSC32K_TRIMIN_VREF_GMBIAS:  5;/*!< Voltage adjustment bit for Gm constant bias (current switching)0b00000:Mod
                                                         e0/Mode30b00001:Mode10b00010:Mode20b00011:Mode4/Mode5/Mode6/Mode7*The
                                                         setting value other than above are prohited                           */
           uint32_t : 19; // padding
    } OVERRIDE_EFUSE_OSC32K_b;                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  OVERRIDE_EFUSE_SiOSC32K;         /*!< SIOSC32K control* With [SELECT_EFUSE].SEL_EFUSE_SIOSC32K=0,
                                                         EFUSE data is reloaded with write access. With [SELECT_EFUSE].SEL_EFUSE_SI
                                                         OSC32K=1, write data is applied.* The initial value is determined
                                                          with a value stored in EFUSE.                                        */
    
    struct {
      __IO uint32_t  OVERRIDE_EFUSE_SiOSC32K_TRIMIN_FREQ:  5;/*!< Oscillation frequency adjustment                             */
           uint32_t : 27; // padding
    } OVERRIDE_EFUSE_SiOSC32K_b;                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  OVERRIDE_EFUSE_SiOSC4M;          /*!< SIOSC4M control* With [SELECT_EFUSE].SEL_EFUSE_SIOSC4M=0, EFUSE
                                                         data is reloaded with write access. With [SELECT_EFUSE].SEL_EFUSE_SIOSC4M=
                                                         1, write data s applied.                                              */
    
    struct {
      __IO uint32_t  OVERRIDE_EFUSE_SiOSC4M_CTRIM:  8;/*!< Oscillation frequency adjustment                                    */
           uint32_t : 24; // padding
    } OVERRIDE_EFUSE_SiOSC4M_b;                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED62;
  
  union {
    __IO uint32_t  OVERRIDE_EFUSE_BGR_0;            /*!< BGR control* With [SELECT_EFUSE].SEL_EFUSE_BGR=0, EFUSE data
                                                         is reloaded with right access. With [SELECT_EFUSE].SEL_EFUSE_BGR=1,
                                                          write data is applied.* The initial value is determined with
                                                          a value stored in EFUSE.                                             */
    
    struct {
      __IO uint32_t  OVERRIDE_EFUSE_BGR_TRIMIN_LDOF:  5;/*!< LDOF output voltage adjustment                                    */
           uint32_t             :  3;
      __IO uint32_t  OVERRIDE_EFUSE_BGR_TRIMIN_PG_LDOF:  5;/*!< LDOF POWERGOOD output voltage adjustment                       */
           uint32_t             :  3;
      __IO uint32_t  OVERRIDE_EFUSE_BGR_TRIMIN_LDODM:  5;/*!< LDOM output voltage adjustment                                   */
           uint32_t             :  3;
      __IO uint32_t  OVERRIDE_EFUSE_BGR_TRIMIN_PG_LDODM:  5;/*!< LDOM POWERGOOD output voltage adjustment                      */
           uint32_t : 3; // padding
    } OVERRIDE_EFUSE_BGR_0_b;                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  OVERRIDE_EFUSE_BGR_1;            /*!< BGR control* With [SELECT_EFUSE].SEL_EFUSE_BGR=0, EFUSE data
                                                         is reloaded with right access. With [SELECT_EFUSE].SEL_EFUSE_BGR=1,
                                                          write data is applied.* The initial value is determined with
                                                          a value stored in EFUSE.                                             */
    
    struct {
      __IO uint32_t  OVERRIDE_EFUSE_BGR_TRIMIN_LDODS:  5;/*!< LDOS output voltage adjustment                                   */
           uint32_t             :  3;
      __IO uint32_t  OVERRIDE_EFUSE_BGR_TRIMIN_PG_LVD:  6;/*!< LVD POWERGOOD output voltage adjustment                         */
           uint32_t             :  2;
      __IO uint32_t  OVERRIDE_EFUSE_BGR_TRIMIN_TEMP_BGR:  5;/*!< BGR temperature characteristic adjustment                     */
           uint32_t : 11; // padding
    } OVERRIDE_EFUSE_BGR_1_b;                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED63[26];
  
  union {
    __IO uint32_t  STATUS_LVPWR;                    /*!< Power Mode status* [8:0]=0x000: ACTIVE mode                           */
    
    struct {
           uint32_t             :  3;
      __IO uint32_t  STATUS_LVPWR_WAIT:  1;         /*!< 1: WAIT mode. 0: Others                                               */
      __IO uint32_t  STATUS_LVPWR_WAIT_RETENTION:  1;/*!< 1: WAIT-RETENTION mode. 0: Others                                    */
      __IO uint32_t  STATUS_LVPWR_RETENTION:  1;    /*!< 1: RETENTION mode. 0: Others                                          */
      __IO uint32_t  STATUS_LVPWR_RTC:  1;          /*!< 1: RTC mode. 0: Others                                                */
      __IO uint32_t  STATUS_LVPWR_STOP:  1;         /*!< 1: STOP mode. 0: Others                                               */
      __IO uint32_t  STATUS_LVPWR_STARTUP:  1;      /*!< 1: STARTUP mode. 0: Others* 1 -> 0 in the reset release sequence      */
           uint32_t : 23; // padding
    } STATUS_LVPWR_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  STATUS_LVRST;                    /*!< Reset factor[Write]1: Factor clear. 0: Ignored                        */
    
    struct {
      __IO uint32_t  STATUS_LVRST_SYS_RESET_N:  1;  /*!< [Read]1: MCU_SYS_RESET_N terminal. 0: Others* 0 -> 1 in the
                                                         power-on sequence                                                     */
           uint32_t             :  3;
      __IO uint32_t  STATUS_LVRST_wdt_wdtResetout:  1;/*!< [Read]1: WDT reset. 0: Others                                       */
           uint32_t             :  3;
      __IO uint32_t  STATUS_LVRST_cpu_LOCKUP:  1;   /*!< [Read]1: Reset by a CPU hardware fault. 0: Others                     */
           uint32_t             :  3;
      __IO uint32_t  STATUS_LVRST_cpu_SYSRESETREQ:  1;/*!< [Read]1: CPU system reset request. 0: Others                        */
           uint32_t             :  3;
      __IO uint32_t  STATUS_LVRST_BOR:  1;          /*!< [Read]1: BOR. 0: Others                                               */
           uint32_t             :  3;
      __IO uint32_t  STATUS_LVRST_RTC:  1;          /*!< [Read]1: Return from RTC mode. 0: Others                              */
           uint32_t             :  3;
      __IO uint32_t  STATUS_LVRST_STOP:  1;         /*!< [Read]1: Return from STOP mode. 0: Others                             */
           uint32_t : 7; // padding
    } STATUS_LVRST_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED64[2];
  
  union {
    __IO uint32_t  BROWNOUTMODE;                    /*!< Brownout mode switching                                               */
    
    struct {
      __IO uint32_t  BOMODE     :  1;               /*!< BrownOut Mode0: Brownout reset1:Brownout interrupt                    */
           uint32_t             :  4;
      __IO uint32_t  BOMODE_INT_FOR_RTC_STOP:  1;   /*!< In RTC/STOP mode0: Return to ACTIVE mode by BrownOut interrupt1:
                                                         BrownOut reset is asserted by BrownOut interrupt.                     */
           uint32_t             : 25;
      __IO uint32_t  BROWNOUT_EN:  1;               /*!< Brownout detection enable0: Disable1: Enable                          */
    } BROWNOUTMODE_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED65[59];
  
  union {
    __IO uint32_t  CTRL_IO_AON_0;                   /*!< IO reset control (AON(PM) IO domain)                                  */
    
    struct {
      __IO uint32_t  CTRL_IO_AON_PM_RESX:  1;       /*!< 0: pull-up/pull-down/Hi-z(Depends on the IO cell)1: (Depends
                                                         on the LATI status.)* 0 -> in the reset release sequence              */
           uint32_t : 31; // padding
    } CTRL_IO_AON_0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_IO_AON_1;                   /*!< IO setting retention control (AON(PM) IO domain)                      */
    
    struct {
      __IO uint32_t  CTRL_IO_AON_PM_LATI:  1;       /*!< (For RESX=H)0: Normal1: retain                                        */
           uint32_t : 31; // padding
    } CTRL_IO_AON_1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_IO_AON_2;                   /*!< IO input standby control (AON(PM) IO domain)0: Standby. 1: Active     */
    
    struct {
      __IO uint32_t  CTRL_IO_I2C2_STBX:  1;         /*!< MCU_I2C2_DATA terminalMCU_I2C2_CLK terminal                           */
      __IO uint32_t  CTRL_IO_SPIM2_STBX:  1;        /*!< MCU_SPIM2_CS_N terminalMCU_SPIM2_CLK terminalMCU_SPIM2_MOSI
                                                         terminalMCU_SPIM2_MISO terminal                                       */
      __IO uint32_t  CTRL_IO_SPIM3_STBX:  1;        /*!< MCU_SPIM3_CS_N terminalMCU_SPIM3_CLK terminalMCU_SPIM3_MOSI
                                                         terminalMCU_SPIM3_MISO terminal                                       */
           uint32_t             :  1;
      __IO uint32_t  CTRL_IO_UA2D_STBX:  1;         /*!< MCU_UA2_RXD terminalMCU_UA2_TXD terminal                              */
      __IO uint32_t  CTRL_IO_UA2_RTS_N_STBX:  1;    /*!< MCU_UA2_RTS_N terminal                                                */
      __IO uint32_t  CTRL_IO_UA2_CTS_N_STBX:  1;    /*!< MCU_UA2_CTS_N terminal                                                */
           uint32_t             :  1;
      __IO uint32_t  CTRL_IO_ADC24_SYNC_STBX:  1;   /*!< MCU_ADC24_SYNC terminal                                               */
           uint32_t : 23; // padding
    } CTRL_IO_AON_2_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_IO_AON_3;                   /*!< IO input standby control (AON(PM) IO domain)0: Standby. 1: Active     */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  CTRL_IO_GPIO_1_STBX:  1;       /*!< MCU_GPIO_1 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_2_STBX:  1;       /*!< MCU_GPIO_2 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_3_STBX:  1;       /*!< MCU_GPIO_3 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_4_STBX:  1;       /*!< MCU_GPIO_4 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_5_STBX:  1;       /*!< MCU_GPIO_5 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_6_STBX:  1;       /*!< MCU_GPIO_6 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_7_STBX:  1;       /*!< MCU_GPIO_7 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_8_STBX:  1;       /*!< MCU_GPIO_8 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_9_STBX:  1;       /*!< MCU_GPIO_9 terminal                                                   */
      __IO uint32_t  CTRL_IO_GPIO_10_STBX:  1;      /*!< MCU_GPIO_10 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_11_STBX:  1;      /*!< MCU_GPIO_11 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_12_STBX:  1;      /*!< MCU_GPIO_12 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_13_STBX:  1;      /*!< MCU_GPIO_13 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_14_STBX:  1;      /*!< MCU_GPIO_14 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_15_STBX:  1;      /*!< MCU_GPIO_15 terminal                                                  */
           uint32_t             :  8;
      __IO uint32_t  CTRL_IO_GPIO_24_STBX:  1;      /*!< MCU_GPIO_24 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_25_STBX:  1;      /*!< MCU_GPIO_25 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_26_STBX:  1;      /*!< MCU_GPIO_26 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_27_STBX:  1;      /*!< MCU_GPIO_27 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_28_STBX:  1;      /*!< MCU_GPIO_28 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_29_STBX:  1;      /*!< MCU_GPIO_29 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_30_STBX:  1;      /*!< MCU_GPIO_30 terminal                                                  */
      __IO uint32_t  CTRL_IO_GPIO_31_STBX:  1;      /*!< MCU_GPIO_31 terminal                                                  */
    } CTRL_IO_AON_3_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_IO_AON_4;                   /*!< IO reset control (AON(PP1) IO domain)                                 */
    
    struct {
      __IO uint32_t  CTRL_IO_AON_PP1_RESX:  1;      /*!< 0: pull-up/pull-down/Hi-z(Depends on the IO cell)1: (Depends
                                                         on the LATI status.)* 0 -> in the reset release sequence              */
           uint32_t : 31; // padding
    } CTRL_IO_AON_4_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_IO_AON_5;                   /*!< IO setting retention control (AON(PP1) IO domain)                     */
    
    struct {
      __IO uint32_t  CTRL_IO_AON_PP1_LATI:  1;      /*!< (For RESX=H)0: Normal1: retain                                        */
           uint32_t : 31; // padding
    } CTRL_IO_AON_5_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_IO_AON_6;                   /*!< IO input standby control (AON(PP1) IO domain)0: Standby. 1:
                                                         Active                                                                */
    
    struct {
      __IO uint32_t  CTRL_IO_UART0_STBX:  1;        /*!< MCU_UA0_RXD terminalMCU_UA0_TXD terminal                              */
           uint32_t             :  7;
      __IO uint32_t  CTRL_IO_UA1_RXD_STBX:  1;      /*!< MCU_UA1_RXD terminal                                                  */
      __IO uint32_t  CTRL_IO_UA1_TXD_STBX:  1;      /*!< MCU_UA1_TXD terminal                                                  */
      __IO uint32_t  CTRL_IO_UA1_RTS_N_STBX:  1;    /*!< MCU_UA1_RTS_N terminal                                                */
      __IO uint32_t  CTRL_IO_UA1_CTS_N_STBX:  1;    /*!< MCU_UA1_CTS_N terminal                                                */
      __IO uint32_t  CTRL_IO_I2C0_DATA_STBX:  1;    /*!< MCU_I2C0_DATA terminal                                                */
      __IO uint32_t  CTRL_IO_I2C0_CLK_STBX:  1;     /*!< MCU_I2C0_CLK terminal                                                 */
      __IO uint32_t  CTRL_IO_I2C1_DATA_STBX:  1;    /*!< MCU_I2C1_DATA terminal                                                */
      __IO uint32_t  CTRL_IO_I2C1_CLK_STBX:  1;     /*!< MCU_I2C1_CLK terminal                                                 */
      __IO uint32_t  CTRL_IO_SPIM0_CS_N_STBX:  1;   /*!< MCU_SPIM0_CS_N terminal                                               */
      __IO uint32_t  CTRL_IO_SPIM0_CLK_STBX:  1;    /*!< MCU_SPIM0_CLK terminal                                                */
      __IO uint32_t  CTRL_IO_SPIM0_MOSI_STBX:  1;   /*!< MCU_SPIM0_MOSI terminal                                               */
      __IO uint32_t  CTRL_IO_SPIM0_MISO_STBX:  1;   /*!< MCU_SPIM0_MISO terminal                                               */
      __IO uint32_t  CTRL_IO_SPIM1_CS_N_STBX:  1;   /*!< MCU_SPIM1_CS_N terminal                                               */
      __IO uint32_t  CTRL_IO_SPIM1_CLK_STBX:  1;    /*!< MCU_SPIM1_CLK terminal                                                */
      __IO uint32_t  CTRL_IO_SPIM1_MOSI_STBX:  1;   /*!< MCU_SPIM1_MOSI terminal                                               */
      __IO uint32_t  CTRL_IO_SPIM1_MISO_STBX:  1;   /*!< MCU_SPIM1_MISO terminal                                               */
           uint32_t : 8; // padding
    } CTRL_IO_AON_6_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED66[65];
  
  union {
    __IO uint32_t  PSW_PU;                          /*!< Internal Power Switch control of the PU power supply domain[Write]1:
                                                         Power is supplied. 0: Power is turned off.[Read]1: Power is
                                                          being supplied. 0: Power is being turned off.                        */
    
    struct {
      __IO uint32_t  PSW_PU_VDDCW:  1;              /*!< VDDC weak switch control                                              */
      __IO uint32_t  PSW_PU_VDDCS:  1;              /*!< VDDC strong switch control                                            */
           uint32_t : 30; // padding
    } PSW_PU_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED67[7];
  
  union {
    __IO uint32_t  PSW_EFUSE;                       /*!< Internal Power Switch control of the EFUS power supply domain[Write]1:
                                                         Power is supplied. 0: Power is turned off.[Read]1: Power is
                                                          being supplied. 0: Power is being turned off.                        */
    
    struct {
      __IO uint32_t  PSW_EFUSE_VDDCW:  1;           /*!< VDDC weak switch control* 0 -> 1 in the reset release sequence        */
      __IO uint32_t  PSW_EFUSE_VDDCS:  1;           /*!< VDDC strong switch control* 0 -> 1 in the reset release sequence      */
           uint32_t : 30; // padding
    } PSW_EFUSE_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PSW_PLL;                         /*!< Internal Power Switch control of the PLL power supply domain[Write]1:
                                                         Power is supplied. 0: Power is turned off.[Read]1: Power is
                                                          being supplied. 0: Power is being turned off.                        */
    
    struct {
      __IO uint32_t  PSW_PLL_VDDCW:  1;             /*!< VDDC weak switch control* Switching from 0 to 1 may occur in
                                                         the reset release sequence.                                           */
      __IO uint32_t  PSW_PLL_VDDCS:  1;             /*!< VDDC strong switch control* Switching from 0 to 1 may occur
                                                         in the reset release sequence.                                        */
           uint32_t : 30; // padding
    } PSW_PLL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PSW_ADPLL;                       /*!< Internal Power Switch control of the ADPLL power supply domain[Write]1:
                                                         Power is supplied. 0: Power is turned off.[Read]1: Power is
                                                          being supplied. 0: Power is being turned off.                        */
    
    struct {
      __IO uint32_t  PSW_ADPLL_VDDCW:  1;           /*!< VDDC weak switch control                                              */
      __IO uint32_t  PSW_ADPLL_VDDCS:  1;           /*!< VDDC strong switch control                                            */
           uint32_t : 30; // padding
    } PSW_ADPLL_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED68;
  
  union {
    __IO uint32_t  PSW_IO_USB;                      /*!< Internal Power Switch control of the IO_USB[Write]1: Power is
                                                         supplied. 0: Power is turned off.[Read]1: Power is being supplied.
                                                          0: Power is being turned off.                                        */
    
    struct {
      __IO uint32_t  PSW_IO_USB_VDDCW:  1;          /*!< VDDC weak switch control                                              */
      __IO uint32_t  PSW_IO_USB_VDDCS:  1;          /*!< VDDC strong switch control                                            */
           uint32_t : 30; // padding
    } PSW_IO_USB_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PSW_HARDMACRO;                   /*!< Internal Power Switch control of Hard Macro[Write]1: Power is
                                                         supplied. 0: Power is turned off.[Read]1: Power is being supplied.
                                                          0: Power is being turned off.                                        */
    
    struct {
      __IO uint32_t  PSW_GYRO_VDDCW:  1;            /*!< GYRO VDDC weak switch control                                         */
      __IO uint32_t  PSW_GYRO_VDDCS:  1;            /*!< GYRO VDDC strong switch control                                       */
      __IO uint32_t  PSW_MAG_VDDCW:  1;             /*!< MAG VDDC weak switch control                                          */
      __IO uint32_t  PSW_MAG_VDDCS:  1;             /*!< MAG VDDC strong switch control                                        */
      __IO uint32_t  PSW_ACC_VDDCW:  1;             /*!< ACC VDDC weak switch control                                          */
      __IO uint32_t  PSW_ACC_VDDCS:  1;             /*!< ACC VDDC strong switch control                                        */
           uint32_t : 26; // padding
    } PSW_HARDMACRO_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED69[50];
  
  union {
    __IO uint32_t  ISO_PU;                          /*!< PU power supply domain isolation control[Write]1: Signal is
                                                         fixed. 0: No signal is fixed.[Read]1: Signal is being fixed.
                                                          0: No signal is fixed.                                               */
    
    struct {
      __IO uint32_t  INISOEN_PU :  1;               /*!< Input signal isolation control                                        */
      __IO uint32_t  OUTISOEN_PU:  1;               /*!< Output signal isolation control                                       */
           uint32_t : 30; // padding
    } ISO_PU_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED70[7];
  
  union {
    __IO uint32_t  ISO_EFUSE;                       /*!< EFUSE power supply domain isolation control[Write]1: Signal
                                                         is fixed. 0: No signal is fixed.[Read]1: Signal is being fixed.
                                                          0: No signal is fixed.                                               */
    
    struct {
      __IO uint32_t  INISOEN_EFUSE:  1;             /*!< Input signal isolation control* 1 -> 0 in the reset release
                                                         sequence                                                              */
      __IO uint32_t  OUTISOEN_EFUSE:  1;            /*!< Output signal isolation control* 1 -> 0 in the reset release
                                                         sequence                                                              */
           uint32_t : 30; // padding
    } ISO_EFUSE_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ISO_PLL;                         /*!< PLL power supply domain isolation control[Write]1: Signal is
                                                         fixed. 0: No signal is fixed.[Read]1: Signal is being fixed.
                                                          0: No signal is fixed.                                               */
    
    struct {
      __IO uint32_t  INISOEN_PLL:  1;               /*!< Input signal isolation control* Switching from 1 to 0 may occur
                                                         in the reset release sequence.                                        */
      __IO uint32_t  OUTISOEN_PLL:  1;              /*!< Output signal isolation control* Switching from 1 to 0 may occur
                                                         in the reset release sequence.                                        */
           uint32_t : 30; // padding
    } ISO_PLL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ISO_ADPLL;                       /*!< ADPLL power supply domain isolation control[Write]1: Signal
                                                         is fixed. 0: No signal is fixed.[Read]1: Signal is being fixed.
                                                          0: No signal is fixed.                                               */
    
    struct {
      __IO uint32_t  INISOEN_ADPLL:  1;             /*!< Input signal isolation control                                        */
      __IO uint32_t  OUTISOEN_ADPLL:  1;            /*!< Output signal isolation control                                       */
           uint32_t : 30; // padding
    } ISO_ADPLL_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED71[109];
  
  union {
    __IO uint32_t  IRQ_SETTING_0;                   /*!< Setting of Wakeup detection* The following 'bit*' is a bit number
                                                         in 4 bits of setting registers for every interrupt.bit0: Rising
                                                          edge detectionbit1: Falling edge detectionbit2: Low level detectionbit3:
                                                          High level detection1: enable0: disable* If all bits are set
                                                          to 0, it will be the state of mask.* If 1 is written to bit0
                                                          and bit1, the both edge is detected.                                 */
    
    struct {
      __IO uint32_t  IRQ_GPIO0_setting:  4;         /*!< MCU_GPIO_0 terminal                                                   */
      __IO uint32_t  IRQ_GPIO1_setting:  4;         /*!< MCU_GPIO_1 terminal                                                   */
      __IO uint32_t  IRQ_GPIO2_setting:  4;         /*!< MCU_GPIO_2 terminal                                                   */
      __IO uint32_t  IRQ_GPIO3_setting:  4;         /*!< MCU_GPIO_3 terminal                                                   */
      __IO uint32_t  IRQ_GPIO4_setting:  4;         /*!< MCU_GPIO_4 terminal                                                   */
      __IO uint32_t  IRQ_GPIO5_setting:  4;         /*!< MCU_GPIO_5 terminal                                                   */
      __IO uint32_t  IRQ_GPIO6_setting:  4;         /*!< MCU_GPIO_6 terminal                                                   */
      __IO uint32_t  IRQ_GPIO7_setting:  4;         /*!< MCU_GPIO_7 terminal                                                   */
    } IRQ_SETTING_0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IRQ_SETTING_1;                   /*!< Setting of Wakeup detection* The following 'bit*' is a bit number
                                                         in 4 bits of setting registers for every interrupt.bit0: Rising
                                                          edge detectionbit1: Falling edge detectionbit2: Low level detectionbit3:
                                                          High level detection1: enable0: disable* If all bits are set
                                                          to 0, it will be the state of mask.* If 1 is written to bit0
                                                          and bit1, the both edge is detected.                                 */
    
    struct {
      __IO uint32_t  IRQ_GPIO24_setting:  4;        /*!< MCU_GPIO_24 terminal                                                  */
      __IO uint32_t  IRQ_GPIO25_setting:  4;        /*!< MCU_GPIO_25 terminal                                                  */
      __IO uint32_t  IRQ_GPIO26_setting:  4;        /*!< MCU_GPIO_26 terminal                                                  */
      __IO uint32_t  IRQ_GPIO27_setting:  4;        /*!< MCU_GPIO_27 terminal                                                  */
      __IO uint32_t  IRQ_GPIO30_setting:  4;        /*!< MCU_GPIO_30 terminal                                                  */
      __IO uint32_t  IRQ_BROWNOUT_setting:  4;      /*!< Brownout interrupt                                                    */
      __IO uint32_t  IRQ_RTCHVWAKEUP_setting:  4;   /*!< RTCHV wakeup interrupt                                                */
      __IO uint32_t  IRQ_CPU_DEBUGIN_setting:  4;   /*!< CPU debug interrupt                                                   */
    } IRQ_SETTING_1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IRQ_STATUS;                      /*!< Cause of Wakeup[Write]1: Wakeup cause clear. 0: Ignored[Read]1:
                                                         Wakeup cause available. 0: No wakeup cause* All detected cause
                                                          can be checked.                                                      */
    
    struct {
      __IO uint32_t  IRQ_GPIO0  :  1;               /*!< MCU_GPIO_0 terminal                                                   */
      __IO uint32_t  IRQ_GPIO1  :  1;               /*!< MCU_GPIO_1 terminal                                                   */
      __IO uint32_t  IRQ_GPIO2  :  1;               /*!< MCU_GPIO_2 terminal                                                   */
      __IO uint32_t  IRQ_GPIO3  :  1;               /*!< MCU_GPIO_3 terminal                                                   */
      __IO uint32_t  IRQ_GPIO4  :  1;               /*!< MCU_GPIO_4 terminal                                                   */
      __IO uint32_t  IRQ_GPIO5  :  1;               /*!< MCU_GPIO_5 terminal                                                   */
      __IO uint32_t  IRQ_GPIO6  :  1;               /*!< MCU_GPIO_6 terminal                                                   */
      __IO uint32_t  IRQ_GPIO7  :  1;               /*!< MCU_GPIO_7 terminal                                                   */
      __IO uint32_t  IRQ_GPIO24 :  1;               /*!< MCU_GPIO_24 terminal                                                  */
      __IO uint32_t  IRQ_GPIO25 :  1;               /*!< MCU_GPIO_25 terminal                                                  */
      __IO uint32_t  IRQ_GPIO26 :  1;               /*!< MCU_GPIO_26 terminal                                                  */
      __IO uint32_t  IRQ_GPIO27 :  1;               /*!< MCU_GPIO_27 terminal                                                  */
      __IO uint32_t  IRQ_GPIO30 :  1;               /*!< MCU_GPIO_30 terminal                                                  */
           uint32_t             :  2;
      __IO uint32_t  IRQ_BROWNOUT:  1;              /*!< Brownout interrupt                                                    */
      __IO uint32_t  IRQ_RTCHVWAKEUP:  1;           /*!< RTCHV wakeup interrupt                                                */
      __IO uint32_t  IRQ_CPU_DEBUGIN:  1;           /*!< CPU debug interrupt                                                   */
           uint32_t : 14; // padding
    } IRQ_STATUS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  WAKEUP_EN;                       /*!< Setting of Wakeup interrupt0: Wakeup interrupt disable1: Wakeup
                                                         interrupt enable                                                      */
    
    struct {
      __IO uint32_t  WAKEUP_GPIO0_enable:  1;       /*!< MCU_GPIO_0 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO1_enable:  1;       /*!< MCU_GPIO_1 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO2_enable:  1;       /*!< MCU_GPIO_2 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO3_enable:  1;       /*!< MCU_GPIO_3 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO4_enable:  1;       /*!< MCU_GPIO_4 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO5_enable:  1;       /*!< MCU_GPIO_5 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO6_enable:  1;       /*!< MCU_GPIO_6 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO7_enable:  1;       /*!< MCU_GPIO_7 terminal                                                   */
      __IO uint32_t  WAKEUP_GPIO24_enable:  1;      /*!< MCU_GPIO_24 terminal                                                  */
      __IO uint32_t  WAKEUP_GPIO25_enable:  1;      /*!< MCU_GPIO_25 terminal                                                  */
      __IO uint32_t  WAKEUP_GPIO26_enable:  1;      /*!< MCU_GPIO_26 terminal                                                  */
      __IO uint32_t  WAKEUP_GPIO27_enable:  1;      /*!< MCU_GPIO_27 terminal                                                  */
      __IO uint32_t  WAKEUP_GPIO30_enable:  1;      /*!< MCU_GPIO_30 terminal                                                  */
           uint32_t             :  2;
      __IO uint32_t  WAKEUP_BROWNOUT_enable:  1;    /*!< Brownout interrupt                                                    */
      __IO uint32_t  WAKEUP_RTCHVWAKEUP_enable:  1; /*!< RTCHV wakeup interrupt                                                */
      __IO uint32_t  WAKEUP_CPU_DEBUGIN_enable:  1; /*!< CPU debug interrupt                                                   */
           uint32_t : 14; // padding
    } WAKEUP_EN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WAKEUP_STATUS;                   /*!< Cause of Wakeup interrupt0: No wakeup interrupt cause1: Wakeup
                                                         interrupt available* Only cause that set 1 to [WAKEUP_EN] can
                                                          be checked.                                                          */
    
    struct {
      __I  uint32_t  WAKEUP_GPIO0_status:  1;       /*!< MCU_GPIO_0 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO1_status:  1;       /*!< MCU_GPIO_1 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO2_status:  1;       /*!< MCU_GPIO_2 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO3_status:  1;       /*!< MCU_GPIO_3 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO4_status:  1;       /*!< MCU_GPIO_4 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO5_status:  1;       /*!< MCU_GPIO_5 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO6_status:  1;       /*!< MCU_GPIO_6 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO7_status:  1;       /*!< MCU_GPIO_7 terminal                                                   */
      __I  uint32_t  WAKEUP_GPIO24_status:  1;      /*!< MCU_GPIO_24 terminal                                                  */
      __I  uint32_t  WAKEUP_GPIO25_status:  1;      /*!< MCU_GPIO_25 terminal                                                  */
      __I  uint32_t  WAKEUP_GPIO26_status:  1;      /*!< MCU_GPIO_26 terminal                                                  */
      __I  uint32_t  WAKEUP_GPIO27_status:  1;      /*!< MCU_GPIO_27 terminal                                                  */
      __I  uint32_t  WAKEUP_GPIO30_status:  1;      /*!< MCU_GPIO_30 terminal                                                  */
           uint32_t             :  2;
      __I  uint32_t  WAKEUP_BROWNOUT_status:  1;    /*!< Brownout interrupt                                                    */
      __I  uint32_t  WAKEUP_RTCHVWAKEUP_status:  1; /*!< RTCHV wakeup interrupt                                                */
      __I  uint32_t  WAKEUP_CPU_DEBUGIN_status:  1; /*!< CPU debug interrupt                                                   */
           uint32_t : 14; // padding
    } WAKEUP_STATUS_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED72[59];
  
  union {
    __IO uint32_t  CPU_DEBUG;                       /*!< CPU debug control                                                     */
    
    struct {
      __IO uint32_t  CPU_DBGEN  :  1;               /*!< [Write]0: JTAG connection disable. 1: Ignored[Read]0: JTAG connection
                                                         disable. 1: JTAG connection enable                                    */
           uint32_t : 31; // padding
    } CPU_DEBUG_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_DEBUG_ACCESS;               /*!< Debugger access control                                               */
    
    struct {
      __IO uint32_t  CTRL_DEBUG_ACCESS:  1;         /*!< 0: JTAG connection disable1: JTAG connection enable* When the
                                                         [EFUSE_BOOTSEQ].EFUSE_SCR_EN is 1, this function is effective.        */
           uint32_t : 31; // padding
    } CTRL_DEBUG_ACCESS_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRL_CDBGPWRUPREQ;               /*!< Reset Control at the JTAG connection                                  */
    
    struct {
      __IO uint32_t  CDBGPWRUPREQ_EN:  1;           /*!< control by the following cause of reset: - CPU system reset
                                                         request - Reset by the CPU hardware fault - WDT reset0: all
                                                          blocks except for the PA power domain1: CPU core and WDT(when
                                                          the cause of reset is WDT reset)                                     */
           uint32_t : 31; // padding
    } CTRL_CDBGPWRUPREQ_b;                          /*!< BitSize                                                               */
  };
} pmulv_Type;


/* ================================================================================ */
/* ================                      spic                      ================ */
/* ================================================================================ */


/**
  * @brief spic (spic)
  */

typedef struct {                                    /*!< spic Structure                                                        */
  
  union {
    __IO uint32_t  DirMemMap;                       /*!< Direct access address mapping register                                */
    
    struct {
      __IO uint32_t  RE         :  1;               /*!< Read Enable                                                           */
           uint32_t             :  3;
      __IO uint32_t  FDEN       :  4;               /*!< Flash capacity0x0:64KB, 0x1:128KB, 0x2:256KB, 0x3:512KB, 0x4:1MB,
                                                         0x5:2MB, 0x6:4MB, 0x7:8MB, 0x8:16MBAny values other than the
                                                          above are reserved.                                                  */
           uint32_t             :  8;
      __IO uint32_t  FBA        : 12;               /*!< Specifies [27:16] of the base address for mapping Flash.This
                                                         value needs to be aligned by a value specified with the Flash
                                                          capacity.If it is not aligned, operation is not guaranteed.          */
      __I  uint32_t  FBA_SI     :  4;               /*!< Indicates [31:28] of the base address for mapping Flash.This
                                                         value is determined with an input signal. It is fixed at 0 in
                                                          this product.                                                        */
    } DirMemMap_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[3];
  
  union {
    __IO uint32_t  DirAccCtrl;                      /*!< Direct access control register                                        */
    
    struct {
      __IO uint32_t  PollWIP    :  1;               /*!< Polling Status WIP0: Polling function OFF1: Polling function
                                                         ON                                                                    */
           uint32_t : 31; // padding
    } DirAccCtrl_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DirCmdCtrl;                      /*!< Direct access command control register                                */
    
    struct {
      __IO uint32_t  DirCmdIOCtrl:  1;              /*!< SPI Command I/O ControlSelect the Command transfer operations.Change
                                                         to match the instruction that has been set to [DirCmdCtrl].CmdOp.0:
                                                          Single1: Quad                                                        */
      __IO uint32_t  DirAdrIOCtrl:  1;              /*!< SPI Address I/O ControlSelect the address transfer operations.Change
                                                         to match the instruction that has been set to [DirCmdCtrl].CmdOp.0:
                                                          Single1: QuadIf QuadAccess is selected with BootMode(MCU_BOOTMODE2),
                                                          the initial value is 0x1.                                            */
      __IO uint32_t  DirDmyIOCtrl:  1;              /*!< SPI Dummy I/O ControlSelect the dummy cycle data transfer operations.Chang
                                                         e to match the instruction that has been set to [DirCmdCtrl].CmdOp.0:
                                                         Single1: QuadIf QuadAccess is selected with BootMode(MCU_BOOTMODE2),
                                                          the initial value is 0x1.                                            */
      __IO uint32_t  DirDatIOCtrl:  1;              /*!< SPI Data I/O ControlSelect the data transfer operations.Change
                                                         to match the instruction that has been set to [DirCmdCtrl].CmdOp.0:
                                                          Single1: QuadIf QuadAccess is selected with BootMode(MCU_BOOTMODE2),
                                                          the initial value is 0x1.                                            */
           uint32_t             :  8;
      __IO uint32_t  DmyByteCount:  4;              /*!< Dummy Byte CountSpecifies the data amount of a dummy cycle in
                                                         byte units.If QuadAccess is selected with BootMode(MCU_BOOTMODE2),
                                                          the initial value is 0x3.                                            */
           uint32_t             :  8;
      __IO uint32_t  CmdOp      :  8;               /*!< SPI Command OpcodeSets a command to be sent to SPI Flash through
                                                         direct access. The initial value is FastRead(0x0B).If QuadAccess
                                                          is selected with BootMode(MCU_BOOTMODE2), the initial value
                                                          is FastReadQuadIO(0xEB).                                             */
    } DirCmdCtrl_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[2];
  
  union {
    __IO uint32_t  PrgSRAMAddr;                     /*!< SRAM transfer address register                                        */
    
    struct {
      __IO uint32_t  SRAMAddr   : 32;               /*!< Specifies the SRAM address of the transfer source (destination)
                                                         used for transfer between Flash and SRAM.The initial value is
                                                          set for the sram T0 area (0x10000000).                               */
    } PrgSRAMAddr_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PrgSRAMTrSize;                   /*!< SRAM transfer size register                                           */
    
    struct {
      __IO uint32_t  TrSize     : 20;               /*!< Sets the transfer size between Flash and SRAM.At reading, the
                                                         upper limit value for transfer is 256KB(0x40000).At writing,
                                                          since SpiFlashMemory write occurs at every 256Byte boundary,set
                                                          'SpiFlash transfer address setting [7:0] + transfer size' so
                                                          that it does not exceed 256 bytes.If Remap1 Mode is selected
                                                          with BootMode(MCU_BOOTMODE1), the initial value is 224KB(0x38000).   */
           uint32_t : 12; // padding
    } PrgSRAMTrSize_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PrgBufIOCtrl;                    /*!< Program register access IO control register                           */
    
    struct {
      __IO uint32_t  PriQuadIOEn:  1;               /*!< Primary Buffer Quad output Enable0: Single1: QuadIf 1 is set,
                                                         Primary Buffer data is transferred with Quad.The location of
                                                          data from which Quad transfer starts is set with PriQuadIOCtrl.If
                                                          QuadAccess is selected with BootMode(MCU_BOOTMODE2), the initial
                                                          value is 0x1.                                                        */
      __IO uint32_t  SecQuadIOEn:  1;               /*!< Secondary Buffer/SRAM Quad output Enable0: Single1: QuadIf 1
                                                         is set, Secondary Buffer and SRAM data is transferred with Quad.If
                                                          QuadAccess is selected with BootMode(MCU_BOOTMODE2), the initial
                                                          value is 0x1.                                                        */
           uint32_t             :  6;
      __IO uint32_t  PriQuadIOCtrl:  3;             /*!< Specifies Quad control of PrimaryBuffer (0-7 specification)Quad
                                                         processing is performed from data in the specified buffer location.   */
           uint32_t             :  5;
      __IO uint32_t  SecQuadIOCtrl:  8;             /*!< Specifies the Quad control timing of SecondaryBuffer and SRAM
                                                         transfer.Use the initial value(0x00) for this setting.                */
           uint32_t : 8; // padding
    } PrgBufIOCtrl_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PrgOECtrl;                       /*!< Program register access OutEnable control register                    */
    
    struct {
      __IO uint32_t  PriOECtrlEn:  2;               /*!< To switch the command, address, dummy cycle data transmission
                                                         to the read data reception, switches enable/disable of the function
                                                          that controls output enable.0: Disables the function.1: Switches
                                                          enable/disable in the buffer data output timing specified with
                                                          PriOEChg.2, 3: Setting prohibited. If QuadAccess is selected
                                                          with BootMode(MCU_BOOTMODE2), the initial value is 0x1.              */
           uint32_t             :  6;
      __IO uint32_t  PriOEChg   :  3;               /*!< Specifies the data location in which OutEnable is switched during
                                                         PrimaryBuffer data transmission.During Quad transfer, specify
                                                          the location of PrimaryBuffer in which the first 1 byte of dummy
                                                          cycle data is stored.Specify '4' if that byte is stored in [PrimaryBuffer1
                                                         ].PriBuf4.                                                            */
           uint32_t : 21; // padding
    } PrgOECtrl_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PrgAccCtrl;                      /*!< Program register access control register                              */
    
    struct {
           uint32_t             :  4;
      __I  uint32_t  PriBufEn   :  1;               /*!< Primary Buffer EnablePrimaryBuffer is always set to ON.               */
      __IO uint32_t  SecBufEn   :  1;               /*!< Secondary Buffer EnableSwitches use/non-use of Secondary Buffer.      */
           uint32_t             :  2;
      __IO uint32_t  TrMode     :  2;               /*!< Specifies the transfer direction of program register access.0:
                                                         Flash Memory -> SRAM transfer (Flash Read)1: SRAM transfer ->
                                                          Flash Memory (Flash Write)2: Flash Memory -> internal buffer
                                                          (Flash Read)3: Internal buffer -> Flash Memory (Flash Write)When
                                                          data transfer is not accompanied, if only command transmission
                                                          is done to SPI Flash, use the setting of 'Internal buffer ->FlashMemory'.I
                                                         f a command is issued which receives information such as status
                                                          from FlashMemory, use the setting of 'FlashMemory->internal          */
           uint32_t             :  6;
      __IO uint32_t  PriBufByteCnt:  3;             /*!< Primary Buffer Data Byte CountSpecifies the amount of PrimaryBuffer
                                                         to be used.Set a value of 'number of bytes to be used - 1'.If
                                                          QuadAccess is selected with BootMode(MCU_BOOTMODE2), the initial
                                                          value is 0x6.                                                        */
           uint32_t             :  5;
      __IO uint32_t  SecBufByteCnt:  8;             /*!< Secondary Buffer Data Byte CountSpecifies the amount of SecondaryBuffer
                                                         to be used.Set a value of 'number of bytes to be used - 1'.           */
    } PrgAccCtrl_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PrgStart;                        /*!< Program register access start register                                */
    
    struct {
      __IO uint32_t  Start      :  1;               /*!< Indicates the start of program register access.0: Disables writing.1:
                                                         Starts transfer by writing.At reading, 0 is read from this register.If
                                                          1 is set while PrgAccBusy of the [status] register is 1, no
                                                          operation is guaranteed.                                             */
           uint32_t : 31; // padding
    } PrgStart_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[2];
  
  union {
    __IO uint32_t  SPICtrl;                         /*!< SPI transfer control register                                         */
    
    struct {
      __IO uint32_t  SDLE       :  1;               /*!< SPI Data Launch Edge0: negedge1: posedge                              */
           uint32_t             :  3;
      __IO uint32_t  SDCE       :  2;               /*!< SPI Data Capture Edge0: 1st posedge1: 1st negedge2,3: not used        */
           uint32_t             :  2;
      __IO uint32_t  SCSD       :  8;               /*!< Specifies the chip select signal (CS_N) deassert period with
                                                         the number of cycles of SPI_CLK.As the initial value, 3 cycles
                                                          is set which satisfies winbond tSHSL2(50ns) for SPI_CLK maximum
                                                          frequency 48MHz.                                                     */
           uint32_t : 16; // padding
    } SPICtrl_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[3];
  
  union {
    __IO uint32_t  CodeStatus;                      /*!< Code status at address of 0x000000                                    */
    
    struct {
      __IO uint32_t  NoCodeFlag :  1;               /*!< Indicates that there is no data of address 0x000000 when checked
                                                         at boot sequence.0:Data is not 0xffffffff.1:Data 0xffffffff.If
                                                          1 is written, the value is cleared.0 write disabled.                 */
           uint32_t : 31; // padding
    } CodeStatus_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[19];
  
  union {
    __IO uint32_t  IntStat;                         /*!< Interrupt status                                                      */
    
    struct {
      __IO uint32_t  PrgRdEnd   :  1;               /*!< Indicates that read transfer has been completed for program
                                                         register access.If 1 is written, the value is cleared. (0 writing
                                                          disabled)                                                            */
      __IO uint32_t  PrgWrEnd   :  1;               /*!< Indicates that write transfer has been completed for program
                                                         register access.If 1 is written, the value is cleared. (0 writing
                                                          disabled)                                                            */
      __IO uint32_t  AccConf    :  1;               /*!< Indicates the conflict detection between direct access and program
                                                         register access.If 1 is written, the value is cleared. (0 writing
                                                          disabled)                                                            */
      __IO uint32_t  StopEnd    :  1;               /*!< Indicates that the SPI transfer suspension processing by the
                                                         SPI transfer suspension register setting has been completed.If
                                                          1 is written, the value is cleared. (0 writing disabled)             */
           uint32_t : 28; // padding
    } IntStat_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IntEn;                           /*!< Interrupt factor enable                                               */
    
    struct {
      __IO uint32_t  PrgRdEndEn :  1;               /*!< Switches enable/disable of output of the program register access
                                                         read transfer completion.0: Disable1: EnableIf Disable is set,
                                                          no interrupt is output at factor generation. However, this setting
                                                          is applied to the interrupt status ([IntStat]).                      */
      __IO uint32_t  PrgWrEndEn :  1;               /*!< Switches enable/disable of output of the program register access
                                                         write transfer completion.0: Disable1: EnableIf Disable is set,
                                                          no interrupt is output at factor generation. However, this setting
                                                          is applied to the interrupt status ([IntStat]).                      */
      __IO uint32_t  AccConfEn  :  1;               /*!< Switches enable/disable of interrupt output caused by the factor
                                                         of direct access/program register access conflict.0: Disable1:
                                                          EnableIf Disable is set, no interrupt is output at factor generation.
                                                          However, this setting is applied to the interrupt status ([IntStat]). */
      __IO uint32_t  StopEndEn  :  1;               /*!< Switches enable/disable of interrupt output caused by SPI transfer
                                                         suspension completion.0: Disable1: EnableIf Disable is set,
                                                          no interrupt is output at factor generation. However, this setting
                                                          is applied to the interrupt status ([IntStat]).                      */
           uint32_t : 28; // padding
    } IntEn_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[6];
  
  union {
    __I  uint32_t  Status;                          /*!< Internal status                                                       */
    
    struct {
      __I  uint32_t  PrgAccBusy :  1;               /*!< Indicates that program register access is in progress.                */
      __I  uint32_t  SpiStopBusy:  1;               /*!< Indicates that Spi suspension processing is in progress.              */
           uint32_t             :  6;
      __I  uint32_t  SecuEraseBusy:  1;             /*!< Indicates that Flash Erase by PMU is in progress.                     */
           uint32_t             :  7;
      __I  uint32_t  DirAccBusy :  1;               /*!< Indicates that direct access is in progress.                          */
           uint32_t : 15; // padding
    } Status_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[11];
  
  union {
    __IO uint32_t  SpiStop;                         /*!< SPI transfer suspension register                                      */
    
    struct {
      __IO uint32_t  Stop       :  1;               /*!< SPI transfer suspension indicationIf 1 is set in this register
                                                         and SPI transfer is in progress, clock supply to SPI Flash is
                                                          stopped and CS_N deassert processing occurs. At reading, a written
                                                          value is read. If this value is 1, neither direct access nor
                                                          program register access is performed even if access is newly
                                                          done.Note: If an instruction is set in Flash, do not use this
                                                          function because it would not be fetched normally.Moreover,
                                                          if the suspension function is used, transfer is stopped midway
                                                          and no data                                                          */
           uint32_t : 31; // padding
    } SpiStop_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7[3];
  
  union {
    __IO uint32_t  PrimaryBuffer0;                  /*!< PrimaryBufferBuffer for storing commands, addresses, dummy cycle
                                                         data for program register access                                      */
    
    struct {
      __IO uint32_t  PriBuf0    :  8;               /*!< PrimaryBuffer0Set the command usually. The initial value is
                                                         FastRead(0x0B).However, if QuadAccess is selected with BootMode(MCU_BOOTMO
                                                         DE2), the initial value is FastReadQuadIO(0xEB).                      */
      __IO uint32_t  PriBuf1    :  8;               /*!< PrimaryBuffer1                                                        */
      __IO uint32_t  PriBuf2    :  8;               /*!< PrimaryBuffer2                                                        */
      __IO uint32_t  PriBuf3    :  8;               /*!< PrimaryBuffer3                                                        */
    } PrimaryBuffer0_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  PrimaryBuffer1;                  /*!< PrimaryBufferBuffer for storing commands, addresses, dummy cycle
                                                         data for program register access                                      */
    
    struct {
      __IO uint32_t  PriBuf4    :  8;               /*!< PrimaryBuffer4                                                        */
      __IO uint32_t  PriBuf5    :  8;               /*!< PrimaryBuffer5                                                        */
      __IO uint32_t  PriBuf6    :  8;               /*!< PrimaryBuffer6                                                        */
      __IO uint32_t  PriBuf7    :  8;               /*!< PrimaryBuffer7                                                        */
    } PrimaryBuffer1_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8[62];
  
  union {
    __IO uint32_t  SecondaryBuffer[64];             /*!< SecondaryBufferBuffer for storing data to be transferred for
                                                         program register accessThis buffer has the area of 256Byte in
                                                          total.                                                               */
    
    struct {
      __IO uint32_t  SecBuf0    :  8;               /*!< SecBuf0                                                               */
      __IO uint32_t  SecBuf1    :  8;               /*!< SecBuf1                                                               */
      __IO uint32_t  SecBuf2    :  8;               /*!< SecBuf2                                                               */
      __IO uint32_t  SecBuf3    :  8;               /*!< SecBuf3                                                               */
    } SecondaryBuffer_b[64];                        /*!< BitSize                                                               */
  };
} spic_Type;


/* ================================================================================ */
/* ================                      sdmac                     ================ */
/* ================================================================================ */


/**
  * @brief sdmac (sdmac)
  */

typedef struct {                                    /*!< sdmac Structure                                                       */
  
  union {
    __IO uint32_t  SAR0;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Current Source Address of DMA transfer. Updated after each source
                                                         transfer. The SINC field in the CTLx register determines whether
                                                          the address increments, decrements, or is left unchanged on
                                                          every source transfer throughout the block transfer.                 */
    } SAR0_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR0_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR0;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Current Destination address of DMA transfer. Updated after each
                                                         destination transfer. The DINC field in the CTLx register determines
                                                          whether the address increments, decrements, or is left unchanged
                                                          on every destination transfer throughout the block transfer.         */
    } DAR0_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR0_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP0;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP0_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL0;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enableIf set, then all interrupt-generating sources
                                                         are enabled. Functions as a global mask bit for all interrupts
                                                          for the channel; raw* interrupt registers still assert if CTLx.INT_EN
                                                          = 0.                                                                 */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width 0b000: 8 0b001: 16 0b010: 32 0b011:
                                                         64 0b100: 128 0b101: 256 0b11X: 256                                   */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width 0b000: 8 0b001: 16 0b010: 32 0b011: 64
                                                         0b100: 128 0b101: 256 0b11X: 256                                      */
      __IO uint32_t  DINC       :  2;               /*!< Destination Address Increment.Indicates whether to increment
                                                         or decrement the destination address on every destination transfer.
                                                          If your device is writing data to a destination peripheral FIFO
                                                          with a fixed address, then set this field to 'No change.' 00
                                                          = Increment 01 = Decrement 1x = No change                            */
      __IO uint32_t  SINC       :  2;               /*!< Source Address Increment.Indicates whether to increment or decrement
                                                         the source address on every source transfer. If the device is
                                                          fetching data from a source peripheral FIFO with a fixed address,
                                                          then set this field to 'No change.' 00 = Increment 01 = Decrement
                                                          1x = No change                                                       */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst lengthNumber of data items, each
                                                         of width CTLx.DST_TR_WIDTH, to be written to the destination
                                                          every time a destination burst transaction request is made from
                                                          either the corresponding hardware or software handshaking interface.
                                                          0b000: 1 0b001: 4 0b010: 8 0b011: 16 0b100: 32 0b101: 64 0b110:
                                                          128 0b111: 256                                                       */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst lengthNumber of data items, each of
                                                         width CTLx.SRC_TR_WIDTH, to be read from the source every time
                                                          a source burst transaction request is made from either the corresponding
                                                          hardware or software handshaking interface. 0b000: 1 0b001:
                                                          4 0b010: 8 0b011: 16 0b100: 32 0b101: 64 0b110: 128 0b111: 256       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Transfer Type and Flow Control.The following transfer types
                                                         are supported.- Memory to Memory- Memory to Peripheral- Peripheral
                                                          to Memory- Peripheral to Peripheral 0b000:Memory to Memory APL03_DMAC
                                                          0b001:Memory to Peripheral APL03_DMAC 0b010:Peripheral to Memory
                                                          APL03_DMAC 0b011:Peripheral to Peripheral APL03_DMAC 0b100:Peripheral
                                                          to Memory Peripheral 0b101:Peripheral to Peripheral Source Peripheral
                                                          0b110:Memory to Peripheral Peripheral 0b111:Peripheral to Peripheral
                                                          Destination Peripheral                                               */
           uint32_t : 9; // padding
    } CTL0_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL0_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block Transfer Size.When the APL03_DMAC is the flow controller,
                                                         the user writes this field before the channel is enabled in
                                                          order to indicate the block size The number programmed into
                                                          BLOCK_TS indicates the total number of single transactions to
                                                          perform for every block transfer; a single transaction is mapped
                                                          to a single AMBA beat.                                               */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL0_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT0;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT0_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT0;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT0_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR0;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR0_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR0;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR0_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG0;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel priority. A priority of 7 is the highest priority, and
                                                         0 is the lowest. This field must be programmed within the following
                                                          range:0: (DMAH_NUM_CHANNELS - 1)A programmed value outside this
                                                          range will cause erroneous behavior.                                 */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend. Suspends all DMA data transfers from the source
                                                         until this bit is cleared. There is no guarantee that the current
                                                          transaction will complete. Can also be used in conjunction with
                                                          CFGx.FIFO_EMPTY to cleanly disable a channel without losing
                                                          any data. 0 = Not suspended. 1 = Suspend DMA transfer from the
                                                          source.                                                              */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Indicates if there is data left in the channel FIFO. Can be
                                                         used in conjunction with CFGx.CH_SUSP to cleanly disable a channel.
                                                          1 = Channel FIFO empty 0 = Channel FIFO not empty                    */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select. This register
                                                         selects which of the handshaking interfaces - hardware or software
                                                          - is active for destination requests on this channel. 0 = Hardware
                                                          handshaking interface. Software-initiated transaction requests
                                                          are ignored. 1 = Software handshaking interface. Hardware- initiated
                                                          transaction requests are ignored. If the destination peripheral
                                                          is memory, then this bit is ignored.                                 */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select. This register
                                                         selects which of the handshaking interfaces - hardware or software
                                                          - is active for source requests on this channel. 0 = Hardware
                                                          handshaking interface. Software-initiated transaction requests
                                                          are ignored. 1 = Software handshaking interface. Hardware-initiated
                                                          transaction requests are ignored. If the source peripheral is
                                                          memory, then this bit is ignored.                                    */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity. 0 = Active high
                                                         1 = Active low                                                        */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity. 0 = Active high 1 = Active
                                                         low                                                                   */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length.Maximum AMBA burst length that is
                                                         used for DMA transfers on this channel. A value of 0 indicates
                                                          that software is not limiting the maximum AMBA burst length
                                                          for DMA transfers on this channel.                                   */
           uint32_t : 2; // padding
    } CFG0_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG0_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control modeDetermines when source transaction
                                                         requests are serviced when the Destination Peripheral is the
                                                          flow controller. 0 = Source transaction requests are serviced
                                                          when they occur. Data pre-fetching is enabled. 1 = Source transaction
                                                          requests are not serviced until a destination transaction request
                                                          occurs. In this mode, the amount of data transferred from the
                                                          source is limited so that it is guaranteed to be transferred
                                                          to the destination prior to block termination by the destination.
                                                          Dat                                                                  */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< FIFO mode selectDetermines how much space or data needs to be
                                                         available in the FIFO before a burst transaction request is
                                                          serviced. 0 = Space/data available for single AHB transfer of
                                                          the specified transfer width. 1 = Data available is greater
                                                          than or equal to half the FIFO depth for destination transfers
                                                          and space available is greater than half the fifo depth for
                                                          source transfers. The exceptions are at the end of a burst transaction
                                                          request or at the end of a block transfer.                           */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interfaceThe channel can then communicate with
                                                         the source peripheral connected to that interface through the
                                                          assigned hardware handshaking interface.                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interfaceThe channel can then communicate
                                                         with the destination peripheral connected to that interface
                                                          through the assigned hardware handshaking interface.                 */
           uint32_t : 18; // padding
    } CFG0_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR0;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR0_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR0;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR0_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  SAR1;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Channel source adrress                                                */
    } SAR1_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR1_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR1;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Channel destination adrress                                           */
    } DAR1_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR1_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP1;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP1_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL1;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enable                                                      */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width                                            */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width                                                 */
      __IO uint32_t  DINC       :  2;               /*!< Destination address direction control                                 */
      __IO uint32_t  SINC       :  2;               /*!< Source address direction control                                      */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst length                                  */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst length                                       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Flow control                                                          */
           uint32_t : 9; // padding
    } CTL1_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL1_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block length                                                          */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL1_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT1;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT1_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT1;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT1_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR1;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR1_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR1;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR1_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG1;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel Priority                                                      */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend control                                               */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Channel FIFO empty status                                             */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select.                  */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select.                       */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity.                           */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity.                                */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length                                             */
           uint32_t : 2; // padding
    } CFG1_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG1_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control mode                                             */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< Channel FIFO mode control                                             */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interface                                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interface                                        */
           uint32_t : 18; // padding
    } CFG1_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR1;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR1_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR1;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR1_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  SAR2;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Channel source adrress                                                */
    } SAR2_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR2_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR2;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Channel destination adrress                                           */
    } DAR2_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR2_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP2;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP2_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL2;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enable                                                      */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width                                            */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width                                                 */
      __IO uint32_t  DINC       :  2;               /*!< Destination address direction control                                 */
      __IO uint32_t  SINC       :  2;               /*!< Source address direction control                                      */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst length                                  */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst length                                       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Flow control                                                          */
           uint32_t : 9; // padding
    } CTL2_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL2_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block length                                                          */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL2_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT2;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT2_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT2;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT2_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR2;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR2_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR2;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR2_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG2;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel Priority                                                      */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend control                                               */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Channel FIFO empty status                                             */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select.                  */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select.                       */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity.                           */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity.                                */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length                                             */
           uint32_t : 2; // padding
    } CFG2_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG2_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control mode                                             */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< Channel FIFO mode control                                             */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interface                                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interface                                        */
           uint32_t : 18; // padding
    } CFG2_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR2;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR2_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR2;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR2_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  SAR3;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Channel source adrress                                                */
    } SAR3_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR3_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR3;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Channel destination adrress                                           */
    } DAR3_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR3_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP3;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP3_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL3;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enable                                                      */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width                                            */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width                                                 */
      __IO uint32_t  DINC       :  2;               /*!< Destination address direction control                                 */
      __IO uint32_t  SINC       :  2;               /*!< Source address direction control                                      */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst length                                  */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst length                                       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Flow control                                                          */
           uint32_t : 9; // padding
    } CTL3_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL3_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block length                                                          */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL3_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT3;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT3_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT3;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT3_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR3;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR3_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR3;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR3_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG3;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel Priority                                                      */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend control                                               */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Channel FIFO empty status                                             */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select.                  */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select.                       */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity.                           */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity.                                */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length                                             */
           uint32_t : 2; // padding
    } CFG3_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG3_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control mode                                             */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< Channel FIFO mode control                                             */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interface                                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interface                                        */
           uint32_t : 18; // padding
    } CFG3_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR3;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR3_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR3;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR3_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  SAR4;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Channel source adrress                                                */
    } SAR4_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR4_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR4;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Channel destination adrress                                           */
    } DAR4_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR4_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP4;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP4_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL4;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enable                                                      */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width                                            */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width                                                 */
      __IO uint32_t  DINC       :  2;               /*!< Destination address direction control                                 */
      __IO uint32_t  SINC       :  2;               /*!< Source address direction control                                      */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst length                                  */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst length                                       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Flow control                                                          */
           uint32_t : 9; // padding
    } CTL4_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL4_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block length                                                          */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL4_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT4;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT4_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT4;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT4_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR4;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR4_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR4;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR4_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG4;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel Priority                                                      */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend control                                               */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Channel FIFO empty status                                             */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select.                  */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select.                       */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity.                           */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity.                                */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length                                             */
           uint32_t : 2; // padding
    } CFG4_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG4_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control mode                                             */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< Channel FIFO mode control                                             */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interface                                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interface                                        */
           uint32_t : 18; // padding
    } CFG4_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR4;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR4_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR4;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR4_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  SAR5;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Channel source adrress                                                */
    } SAR5_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR5_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR5;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Channel destination adrress                                           */
    } DAR5_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR5_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP5;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP5_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL5;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enable                                                      */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width                                            */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width                                                 */
      __IO uint32_t  DINC       :  2;               /*!< Destination address direction control                                 */
      __IO uint32_t  SINC       :  2;               /*!< Source address direction control                                      */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst length                                  */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst length                                       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Flow control                                                          */
           uint32_t : 9; // padding
    } CTL5_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL5_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block length                                                          */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL5_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT5;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT5_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT5;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT5_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR5;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR5_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR5;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR5_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG5;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel Priority                                                      */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend control                                               */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Channel FIFO empty status                                             */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select.                  */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select.                       */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity.                           */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity.                                */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length                                             */
           uint32_t : 2; // padding
    } CFG5_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG5_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control mode                                             */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< Channel FIFO mode control                                             */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interface                                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interface                                        */
           uint32_t : 18; // padding
    } CFG5_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR5;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR5_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR5;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR5_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  SAR6;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Channel source adrress                                                */
    } SAR6_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR6_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR6;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Channel destination adrress                                           */
    } DAR6_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR6_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP6;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP6_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL6;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enable                                                      */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width                                            */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width                                                 */
      __IO uint32_t  DINC       :  2;               /*!< Destination address direction control                                 */
      __IO uint32_t  SINC       :  2;               /*!< Source address direction control                                      */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst length                                  */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst length                                       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Flow control                                                          */
           uint32_t : 9; // padding
    } CTL6_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL6_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block length                                                          */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL6_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT6;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT6_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT6;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT6_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR6;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR6_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR6;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR6_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG6;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel Priority                                                      */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend control                                               */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Channel FIFO empty status                                             */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select.                  */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select.                       */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity.                           */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity.                                */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length                                             */
           uint32_t : 2; // padding
    } CFG6_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG6_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control mode                                             */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< Channel FIFO mode control                                             */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interface                                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interface                                        */
           uint32_t : 18; // padding
    } CFG6_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR6;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR6_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR6;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR6_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  SAR7;                            /*!< Channel source adrress                                                */
    
    struct {
      __IO uint32_t  SAR        : 32;               /*!< Channel source adrress                                                */
    } SAR7_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  SAR7_H;                            /*!< Channel source adrress                                                */
  
  union {
    __IO uint32_t  DAR7;                            /*!< Channel destination adrress                                           */
    
    struct {
      __IO uint32_t  DAR        : 32;               /*!< Channel destination adrress                                           */
    } DAR7_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  DAR7_H;                            /*!< Channel destination adrress                                           */
  __I  uint32_t  LLP7;                              /*!< Linked List Pointer Register                                          */
  __I  uint32_t  LLP7_H;                            /*!< Linked List Pointer Register                                          */
  
  union {
    __IO uint32_t  CTL7;                            /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  INT_EN     :  1;               /*!< Interrupt enable                                                      */
      __IO uint32_t  DST_TR_WIDTH:  3;              /*!< Destination transfer width                                            */
      __IO uint32_t  SRC_TR_WIDTH:  3;              /*!< Source transfer width                                                 */
      __IO uint32_t  DINC       :  2;               /*!< Destination address direction control                                 */
      __IO uint32_t  SINC       :  2;               /*!< Source address direction control                                      */
      __IO uint32_t  DEST_MSIZE :  3;               /*!< Destination transaction burst length                                  */
      __IO uint32_t  SRC_MSIZE  :  3;               /*!< Source transaction burst length                                       */
           uint32_t             :  3;
      __IO uint32_t  TT_FC      :  3;               /*!< Flow control                                                          */
           uint32_t : 9; // padding
    } CTL7_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTL7_H;                          /*!< Channel control                                                       */
    
    struct {
      __IO uint32_t  BLOCK_TS   : 12;               /*!< Block length                                                          */
      __IO uint32_t  DONE       :  1;               /*!< Done Bit                                                              */
           uint32_t : 19; // padding
    } CTL7_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SSTAT7;                            /*!< Source Status Register                                                */
  __I  uint32_t  SSTAT7_H;                          /*!< Source Status Register                                                */
  __I  uint32_t  DSTAT7;                            /*!< Destination Status Register                                           */
  __I  uint32_t  DSTAT7_H;                          /*!< Destination Status Register                                           */
  __I  uint32_t  SSTATAR7;                          /*!< Source Status Address Register                                        */
  __I  uint32_t  SSTATAR7_H;                        /*!< Source Status Address Register                                        */
  __I  uint32_t  DSTATAR7;                          /*!< Destination Status Address Register                                   */
  __I  uint32_t  DSTATAR7_H;                        /*!< Destination Status Address Register                                   */
  
  union {
    __IO uint32_t  CFG7;                            /*!< Channel configuration                                                 */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  CH_PRIOR   :  3;               /*!< Channel Priority                                                      */
      __IO uint32_t  CH_SUSP    :  1;               /*!< Channel Suspend control                                               */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< Channel FIFO empty status                                             */
      __IO uint32_t  HS_SEL_DST :  1;               /*!< Destination Software or Hardware Handshaking Select.                  */
      __IO uint32_t  HS_SEL_SRC :  1;               /*!< Source Software or Hardware Handshaking Select.                       */
           uint32_t             :  6;
      __IO uint32_t  DST_HS_POL :  1;               /*!< Destination Handshaking Interface Polarity.                           */
      __IO uint32_t  SRC_HS_POL :  1;               /*!< Source Handshaking Interface Polarity.                                */
      __IO uint32_t  MAX_ABRST  : 10;               /*!< Maximum AMBA Burst Length                                             */
           uint32_t : 2; // padding
    } CFG7_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CFG7_H;                          /*!< Channel configuration                                                 */
    
    struct {
      __IO uint32_t  FCMODE     :  1;               /*!< Channel flow control mode                                             */
      __IO uint32_t  FIFO_MODE  :  1;               /*!< Channel FIFO mode control                                             */
           uint32_t             :  5;
      __IO uint32_t  SRC_PER    :  3;               /*!< Source hardware interface                                             */
           uint32_t             :  1;
      __IO uint32_t  DEST_PER   :  3;               /*!< Destination hardware interface                                        */
           uint32_t : 18; // padding
    } CFG7_H_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  SGR7;                              /*!< Source Gather Register                                                */
  __I  uint32_t  SGR7_H;                            /*!< Source Gather Register                                                */
  __I  uint32_t  DSR7;                              /*!< Destination Scatter Register                                          */
  __I  uint32_t  DSR7_H;                            /*!< Destination Scatter Register                                          */
  
  union {
    __IO uint32_t  RAWTFR;                          /*!< Raw Status for IntTfr Interrupt                                       */
    
    struct {
      __IO uint32_t  RAW        :  8;               /*!< Raw Status for IntTfr Interrupt                                       */
           uint32_t : 24; // padding
    } RAWTFR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RAWTFR_H;                          /*!< Raw Status for IntTfr Interrupt                                       */
  
  union {
    __IO uint32_t  RAWBLOCK;                        /*!< Raw Status for IntBlock Interrupt                                     */
    
    struct {
      __IO uint32_t  RAW        :  8;               /*!< Raw Status for IntBlock Interrupt                                     */
           uint32_t : 24; // padding
    } RAWBLOCK_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RAWBLOCK_H;                        /*!< Raw Status for IntBlock Interrupt                                     */
  
  union {
    __IO uint32_t  RAWSRCTRAN;                      /*!< Raw Status for IntSrcTran Interrupt                                   */
    
    struct {
      __IO uint32_t  RAW        :  8;               /*!< Raw Status for IntSrcTran Interrupt                                   */
           uint32_t : 24; // padding
    } RAWSRCTRAN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RAWSRCTRAN_H;                      /*!< Raw Status for IntSrcTran Interrupt                                   */
  
  union {
    __IO uint32_t  RAWDSTTRAN;                      /*!< Raw Status for IntDstTran Interrupt                                   */
    
    struct {
      __IO uint32_t  RAW        :  8;               /*!< Raw Status for IntDstTran Interrupt                                   */
           uint32_t : 24; // padding
    } RAWDSTTRAN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RAWDSTTRAN_H;                      /*!< Raw Status for IntDstTran Interrupt                                   */
  
  union {
    __IO uint32_t  RAWERR;                          /*!< Raw Status for IntErr Interrupt                                       */
    
    struct {
      __IO uint32_t  RAW        :  8;               /*!< Raw Status for IntErr Interrupt                                       */
           uint32_t : 24; // padding
    } RAWERR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RAWERR_H;                          /*!< Raw Status for IntErr Interrupt                                       */
  
  union {
    __I  uint32_t  STATUSTFR;                       /*!< Status for IntTfr Interrupt                                           */
    
    struct {
      __I  uint32_t  STATUS     :  8;               /*!< Status for IntTfr Interrupt                                           */
           uint32_t : 24; // padding
    } STATUSTFR_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  STATUSTFR_H;                       /*!< Status for IntTfr Interrupt                                           */
  
  union {
    __I  uint32_t  STATUSBLOCK;                     /*!< Status for IntBlock Interrupt                                         */
    
    struct {
      __I  uint32_t  STATUS     :  8;               /*!< Status for IntBlock Interrupt                                         */
           uint32_t : 24; // padding
    } STATUSBLOCK_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  STATUSBLOCK_H;                     /*!< Status for IntBlock Interrupt                                         */
  
  union {
    __I  uint32_t  STATUSSRCTRAN;                   /*!< Status for IntSrcTran Interrupt                                       */
    
    struct {
      __I  uint32_t  STATUS     :  8;               /*!< Status for IntSrcTran Interrupt                                       */
           uint32_t : 24; // padding
    } STATUSSRCTRAN_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  STATUSSRCTRAN_H;                   /*!< Status for IntSrcTran Interrupt                                       */
  
  union {
    __I  uint32_t  STATUSDSTTRAN;                   /*!< Status for IntDstTran Interrupt                                       */
    
    struct {
      __I  uint32_t  STATUS     :  8;               /*!< Status for IntDstTran Interrupt                                       */
           uint32_t : 24; // padding
    } STATUSDSTTRAN_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  STATUSDSTTRAN_H;                   /*!< Status for IntDstTran Interrupt                                       */
  
  union {
    __I  uint32_t  STATUSERR;                       /*!< Status for IntErr Interrupt                                           */
    
    struct {
      __I  uint32_t  STATUS     :  8;               /*!< Status for IntErr Interrupt                                           */
           uint32_t : 24; // padding
    } STATUSERR_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  STATUSERR_H;                       /*!< Status for IntErr Interrupt                                           */
  
  union {
    __IO uint32_t  MASKTFR;                         /*!< Mask for IntTfr Interrupt                                             */
    
    struct {
      __IO uint32_t  INT_MASK   :  8;               /*!< Mask for IntTfr Interrupt 0 = masked 1 = unmasked                     */
      __IO uint32_t  INT_MASK_WE:  8;               /*!< Interrupt Mask Write Enable 0 = write disabled 1 = write enabled      */
           uint32_t : 16; // padding
    } MASKTFR_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  MASKTFR_H;                         /*!< Mask for IntTfr Interrupt                                             */
  
  union {
    __IO uint32_t  MASKBLOCK;                       /*!< Mask for IntBlock Interrupt                                           */
    
    struct {
      __IO uint32_t  INT_MASK   :  8;               /*!< Mask for IntBlock Interrupt                                           */
      __IO uint32_t  INT_MASK_WE:  8;               /*!< Interrupt Mask Write Enable                                           */
           uint32_t : 16; // padding
    } MASKBLOCK_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  MASKBLOCK_H;                       /*!< Mask for IntBlock Interrupt                                           */
  
  union {
    __IO uint32_t  MASKSRCTRAN;                     /*!< Mask for IntSrcTran Interrupt                                         */
    
    struct {
      __IO uint32_t  INT_MASK   :  8;               /*!< Mask for IntSrcTran Interrupt                                         */
      __IO uint32_t  INT_MASK_WE:  8;               /*!< Interrupt Mask Write Enable                                           */
           uint32_t : 16; // padding
    } MASKSRCTRAN_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  MASKSRCTRAN_H;                     /*!< Mask for IntSrcTran Interrupt                                         */
  
  union {
    __IO uint32_t  MASKDSTTRAN;                     /*!< Mask for IntDstTran Interrupt                                         */
    
    struct {
      __IO uint32_t  INT_MASK   :  8;               /*!< Mask for IntDstTran Interrupt                                         */
      __IO uint32_t  INT_MASK_WE:  8;               /*!< Interrupt Mask Write Enable                                           */
           uint32_t : 16; // padding
    } MASKDSTTRAN_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  MASKDSTTRAN_H;                     /*!< Mask for IntDstTran Interrupt                                         */
  
  union {
    __IO uint32_t  MASKERR;                         /*!< Mask for IntErr Interrupt                                             */
    
    struct {
      __IO uint32_t  INT_MASK   :  8;               /*!< Mask for IntErr Interrupt                                             */
      __IO uint32_t  INT_MASK_WE:  8;               /*!< Interrupt Mask Write Enable                                           */
           uint32_t : 16; // padding
    } MASKERR_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  MASKERR_H;                         /*!< Mask for IntErr Interrupt                                             */
  
  union {
    __IO uint32_t  CLEARTFR;                        /*!< Clear for IntTfr Interrupt                                            */
    
    struct {
      __IO uint32_t  CLEAR      :  8;               /*!< Clear for IntTfr Interrupt 0 = no effect 1 = clear interrupt          */
           uint32_t : 24; // padding
    } CLEARTFR_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  CLEARTFR_H;                        /*!< Clear for IntTfr Interrupt                                            */
  
  union {
    __IO uint32_t  CLEARBLOCK;                      /*!< Clear for IntBlock Interrupt                                          */
    
    struct {
      __IO uint32_t  CLEAR      :  8;               /*!< Clear for IntBlock Interrupt                                          */
           uint32_t : 24; // padding
    } CLEARBLOCK_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  CLEARBLOCK_H;                      /*!< Clear for IntBlock Interrupt                                          */
  
  union {
    __IO uint32_t  CLEARSRCTRAN;                    /*!< Clear for IntSrcTran Interrupt                                        */
    
    struct {
      __IO uint32_t  CLEAR      :  8;               /*!< Clear for IntSrcTran Interrupt                                        */
           uint32_t : 24; // padding
    } CLEARSRCTRAN_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  CLEARSRCTRAN_H;                    /*!< Clear for IntSrcTran Interrupt                                        */
  
  union {
    __IO uint32_t  CLEARDSTTRAN;                    /*!< Clear for IntDstTran Interrupt                                        */
    
    struct {
      __IO uint32_t  CLEAR      :  8;               /*!< Clear for IntDstTran Interrupt                                        */
           uint32_t : 24; // padding
    } CLEARDSTTRAN_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  CLEARDSTTRAN_H;                    /*!< Clear for IntDstTran Interrupt                                        */
  
  union {
    __IO uint32_t  CLEARERR;                        /*!< Clear for IntErr Interrupt                                            */
    
    struct {
      __IO uint32_t  CLEAR      :  8;               /*!< Clear for IntErr Interrupt                                            */
           uint32_t : 24; // padding
    } CLEARERR_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  CLEARERR_H;                        /*!< Clear for IntErr Interrupt                                            */
  
  union {
    __I  uint32_t  STATUSINT;                       /*!< Status for each Interrupt type                                        */
    
    struct {
      __I  uint32_t  TFR        :  1;               /*!< OR of the contents of StatusTfr register.                             */
      __I  uint32_t  BLOCK      :  1;               /*!< OR of the contents of StatusBlock register.                           */
      __I  uint32_t  SRCT       :  1;               /*!< OR of the contents of StatusSrcTran register.                         */
      __I  uint32_t  DSTT       :  1;               /*!< OR of the contents of StatusDst register.                             */
      __I  uint32_t  ERR        :  1;               /*!< OR of the contents of StatusErr register.                             */
           uint32_t : 27; // padding
    } STATUSINT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  STATUSINT_H;                       /*!< Status for each Interrupt type                                        */
  
  union {
    __IO uint32_t  REQSRCREG;                       /*!< Source Software Transaction Request register                          */
    
    struct {
      __IO uint32_t  SRC_REQ    :  8;               /*!< Source Software Transaction Request register                          */
      __IO uint32_t  SRC_REQ_WE :  8;               /*!< Source Software Transaction Request write enable 0 = write disabled
                                                         1 = write enabled                                                     */
           uint32_t : 16; // padding
    } REQSRCREG_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  REQSRCREG_H;                       /*!< Source Software Transaction Request register                          */
  
  union {
    __IO uint32_t  REQDSTREG;                       /*!< Destination Software Transaction Request register                     */
    
    struct {
      __IO uint32_t  DST_REQ    :  8;               /*!< Destination Software Transaction Request register                     */
      __IO uint32_t  DST_REQ_WE :  8;               /*!< Destination Software Transaction Request write enable 0 = write
                                                         disabled 1 = write enabled                                            */
           uint32_t : 16; // padding
    } REQDSTREG_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  REQDSTREG_H;                       /*!< Mask for IntBlock Interrupt                                           */
  
  union {
    __IO uint32_t  SGLRQSRCREG;                     /*!< Source Single Transaction Request register                            */
    
    struct {
      __IO uint32_t  SRC_SGLREQ :  8;               /*!< Source Single Transaction Request register                            */
      __IO uint32_t  SRC_SGLREQ_WE:  8;             /*!< Source Single Transaction Request write enable 0 = write disabled
                                                         1 = write enabled                                                     */
           uint32_t : 16; // padding
    } SGLRQSRCREG_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  SGLRQSRCREG_H;                     /*!< Source Single Transaction Request register                            */
  
  union {
    __IO uint32_t  SGLRQDSTREG;                     /*!< Destination Single Transaction Request register                       */
    
    struct {
      __IO uint32_t  DST_SGLREQ :  8;               /*!< Destination Single Transaction Request register                       */
      __IO uint32_t  DST_SGLREQ_WE:  8;             /*!< Destination Single Transaction Request write enable 0 = write
                                                         disabled 1 = write enabled                                            */
           uint32_t : 16; // padding
    } SGLRQDSTREG_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  SGLRQDSTREG_H;                     /*!< Destination Single Transaction Request register                       */
  
  union {
    __IO uint32_t  LSTSRCREG;                       /*!< Source Last Transaction Request register                              */
    
    struct {
      __IO uint32_t  LSTSRC     :  8;               /*!< Source Last Transaction Request register 0 = Not last transaction
                                                         in current block 1 = Last transaction in current block                */
      __IO uint32_t  LSTSRC_WE  :  8;               /*!< Source Last Transaction Request write enable 0 = write disabled
                                                         1 = write enabled                                                     */
           uint32_t : 16; // padding
    } LSTSRCREG_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  LSTSRCREG_H;                       /*!< Source Last Transaction Request register                              */
  
  union {
    __IO uint32_t  LSTDSTREG;                       /*!< Destination Last Transaction Request register                         */
    
    struct {
      __IO uint32_t  DST_SGLREQ :  8;               /*!< Destination Last Transaction Request register 0 = Not last transaction
                                                         in current block 1 = Last transaction in current block                */
      __IO uint32_t  LSTDST_WE  :  8;               /*!< Destination Last Transaction Request write enable 0 = write
                                                         disabled 1 = write enabled                                            */
           uint32_t : 16; // padding
    } LSTDSTREG_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  LSTDSTREG_H;                       /*!< Destination Last Transaction Request register                         */
  
  union {
    __IO uint32_t  DMACFGREG;                       /*!< DMA Configuration Register                                            */
    
    struct {
      __IO uint32_t  DMA_EN     :  1;               /*!< DMA global enable 0 = APL03_DMAC Disabled 1 = APL03_DMAC Enabled.     */
           uint32_t : 31; // padding
    } DMACFGREG_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  DMACFGREG_H;                       /*!< DMA Configuration Register                                            */
  
  union {
    __IO uint32_t  CHENREG;                         /*!< Channel enable register                                               */
    
    struct {
      __IO uint32_t  CH_EN      :  8;               /*!< Enables/Disables the channel. Setting this bit enables a channel;clearing
                                                         this bit disables the channel. 0 = Disable the Channel 1 = Enable
                                                          the Channel                                                          */
      __IO uint32_t  CH_EN_WE   :  8;               /*!< Channel enable write enable.                                          */
           uint32_t : 16; // padding
    } CHENREG_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  CHENREG_H;                         /*!< Channel enable register                                               */
  
  union {
    __I  uint32_t  DMAIDREG;                        /*!< DMA ID register                                                       */
    
    struct {
      __I  uint32_t  DMA_ID     : 32;               /*!< DMA global enable                                                     */
    } DMAIDREG_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  DMAIDREG_H;                        /*!< DMA ID register                                                       */
  
  union {
    __IO uint32_t  DMATESTREG;                      /*!< DMA Test register                                                     */
    
    struct {
      __IO uint32_t  TEST_SLV_IF:  1;               /*!< DMA Test registerPuts the AHB slave interface into test mode.
                                                         In this mode, the readback value of the writable registers always
                                                          matches the value written. This bit does not allow writing to
                                                          read-only registers. 0 = Normal mode 1 = Test mode                   */
           uint32_t : 31; // padding
    } DMATESTREG_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  DMATESTREG_H;                      /*!< DMA Test register                                                     */
  __I  uint32_t  RESERVED0[4];
  __I  uint32_t  DMA_COMP_PARAMS_6;                 /*!< Component Parameters registers                                        */
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_6_H;             /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH7_DTW    :  3;               /*!< CH7_DTWThe value of this register is derived from the DMAH_CH7_DTW
                                                         coreConsultant parameter. 0x0 = NO_HARDCODE 0x1 = 8 0x2 = 16
                                                          0x3 = 32 0x4 = 64 0x5 = 128 0x6 = 256 0x7 = reserved                 */
      __I  uint32_t  CH7_STW    :  3;               /*!< CH7_STWThe value of this register is derived from the DMAH_CH7_STW
                                                         coreConsultant parameter. 0x0 = NO_HARDCODE 0x1 = 8 0x2 = 16
                                                          0x3 = 32 0x4 = 64 0x5 = 128 0x6 = 256 0x7 = reserved                 */
      __I  uint32_t  CH7_STAT_DST:  1;              /*!< CH7_STAT_DSTThe value of this register is derived from the DMAH_CH7_STAT_D
                                                         ST coreConsultant parameter. 0x0 = FALSE 0x1 = TRUE                   */
      __I  uint32_t  CH7_STAT_SRC:  1;              /*!< CH7_STAT_SRCThe value of this register is derived from the DMAH_CH7_STAT_S
                                                         RC coreConsultant parameter. 0x0 = FALSE 0x1 = TRUE                   */
      __I  uint32_t  CH7_DST_SCA_EN:  1;            /*!< CH7_DST_SCA_ENThe value of this register is derived from the
                                                         DMAH_CH7_DST_SCA_EN coreConsultant parameter. 0x0 = FALSE 0x1
                                                          = TRUE                                                               */
      __I  uint32_t  CH7_SRC_GAT_EN:  1;            /*!< CH7_SRC_GAT_ENThe value of this register is derived from the
                                                         DMAH_CH7_SRC_GAT_EN coreConsultant parameter. 0x0 = FALSE 0x1
                                                          = TRUE                                                               */
      __I  uint32_t  CH7_LOCK_EN:  1;               /*!< CH7_LOCK_ENThe value of this register is derived from the DMAH_CH7_LOCK_EN
                                                         coreConsultant parameter. 0x0 = FALSE 0x1 = TRUE                      */
      __I  uint32_t  CH7_MULTI_BLK_EN:  1;          /*!< CH7_MULTI_BLK_ENThe value of this register is derived from the
                                                         DMAH_CH7_MULTI_BLK_EN coreConsultant parameter. 0x0 = FALSE
                                                          0x1 = TRUE                                                           */
      __I  uint32_t  CH7_CTL_WB_EN:  1;             /*!< CH7_CTL_WB_ENThe value of this register is derived from the
                                                         DMAH_CH7_CTL_WB_EN coreConsultant parameter. 0x0 = FALSE 0x1
                                                          = TRUE                                                               */
      __I  uint32_t  CH7_HC_LLP :  1;               /*!< CH7_HC_LLPThe value of this register is derived from the DMAH_CH7_HC_LLP
                                                         coreConsultant parameter. 0x0 = FALSE 0x1 = TRUE                      */
      __I  uint32_t  CH7_FC     :  2;               /*!< CH7_FCThe value of this register is derived from the DMAH_CH7_FC
                                                         coreConsultant parameter. 0x0 = DMA 0x1 = SRC 0x2 = DST 0x3
                                                          = ANY                                                                */
      __I  uint32_t  CH7_MAX_MULT_SIZE:  3;         /*!< CH7_MAX_MULT_SIZEThe value of this register is derived from
                                                         the DMAH_CH7_MULT_SIZE coreConsultant parameter. 0x0 = 4 0x1
                                                          = 8 0x2 = 16 0x3 = 32 0x4 = 64 0x5 = 128 0x6 = 256 0x7 = reserved    */
      __I  uint32_t  CH7_DMS    :  3;               /*!< CH7_DMSThe value of this register is derived from the DMAH_CH7_DMS
                                                         coreConsultant parameter. 0x0 = MASTER_1 0x1 = MASTER_2 0x2
                                                          = MASTER_3 0x3 = MASTER_4 0x4 = NO_HARDCODE                          */
      __I  uint32_t  CH7_LMS    :  3;               /*!< CH7_LMSThe value of this register is derived from the DMAH_CH7_LMS
                                                         coreConsultant parameter. 0x0 = MASTER_1 0x1 = MASTER_2 0x2
                                                          = MASTER_3 0x3 = MASTER_4 0x4 = NO_HARDCODE                          */
      __I  uint32_t  CH7_SMS    :  3;               /*!< CH7_SMSThe value of this register is derived from the DMAH_CH7_SMS
                                                         coreConsultant parameter. 0x0 = MASTER_1 0x1 = MASTER_2 0x2
                                                          = MASTER_3 0x3 = MASTER_4 0x4 = NO_HARDCODE                          */
      __I  uint32_t  CH7_FIFO_DEPTH:  3;            /*!< CH7_FIFO_DEPTHThe value of this register is derived from the
                                                         DMAH_CH7_FIFO_DEPTH coreConsultant parameter. 0x0 = 8 0x1 =
                                                          16 0x2 = 32 0x3 = 64 0x4 = 128                                       */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_6_H_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_5;               /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH6_DTW    :  3;               /*!< CH6_DTW                                                               */
      __I  uint32_t  CH6_STW    :  3;               /*!< CH6_STW                                                               */
      __I  uint32_t  CH6_STAT_DST:  1;              /*!< CH6_STAT_DST                                                          */
      __I  uint32_t  CH6_STAT_SRC:  1;              /*!< CH6_STAT_SRC                                                          */
      __I  uint32_t  CH6_DST_SCA_EN:  1;            /*!< CH6_DST_SCA_EN                                                        */
      __I  uint32_t  CH6_SRC_GAT_EN:  1;            /*!< CH6_SRC_GAT_EN                                                        */
      __I  uint32_t  CH6_LOCK_EN:  1;               /*!< CH6_LOCK_EN                                                           */
      __I  uint32_t  CH6_MULTI_BLK_EN:  1;          /*!< CH6_MULTI_BLK_EN                                                      */
      __I  uint32_t  CH6_CTL_WB_EN:  1;             /*!< CH6_CTL_WB_EN                                                         */
      __I  uint32_t  CH6_HC_LLP :  1;               /*!< CH6_HC_LLP                                                            */
      __I  uint32_t  CH6_FC     :  2;               /*!< CH6_FC                                                                */
      __I  uint32_t  CH6_MAX_MULT_SIZE:  3;         /*!< CH6_MAX_MULT_SIZE                                                     */
      __I  uint32_t  CH6_DMS    :  3;               /*!< CH6_DMS                                                               */
      __I  uint32_t  CH6_LMS    :  3;               /*!< CH6_LMS                                                               */
      __I  uint32_t  CH6_SMS    :  3;               /*!< CH6_SMS                                                               */
      __I  uint32_t  CH6_FIFO_DEPTH:  3;            /*!< CH6_FIFO_DEPTH                                                        */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_5_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_5_H;             /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH5_DTW    :  3;               /*!< CH5_DTW                                                               */
      __I  uint32_t  CH5_STW    :  3;               /*!< CH5_STW                                                               */
      __I  uint32_t  CH5_STAT_DST:  1;              /*!< CH5_STAT_DST                                                          */
      __I  uint32_t  CH5_STAT_SRC:  1;              /*!< CH5_STAT_SRC                                                          */
      __I  uint32_t  CH5_DST_SCA_EN:  1;            /*!< CH5_DST_SCA_EN                                                        */
      __I  uint32_t  CH5_SRC_GAT_EN:  1;            /*!< CH5_SRC_GAT_EN                                                        */
      __I  uint32_t  CH5_LOCK_EN:  1;               /*!< CH5_LOCK_EN                                                           */
      __I  uint32_t  CH5_MULTI_BLK_EN:  1;          /*!< CH5_MULTI_BLK_EN                                                      */
      __I  uint32_t  CH5_CTL_WB_EN:  1;             /*!< CH5_CTL_WB_EN                                                         */
      __I  uint32_t  CH5_HC_LLP :  1;               /*!< CH5_HC_LLP                                                            */
      __I  uint32_t  CH5_FC     :  2;               /*!< CH5_FC                                                                */
      __I  uint32_t  CH5_MAX_MULT_SIZE:  3;         /*!< CH5_MAX_MULT_SIZE                                                     */
      __I  uint32_t  CH5_DMS    :  3;               /*!< CH5_DMS                                                               */
      __I  uint32_t  CH5_LMS    :  3;               /*!< CH5_LMS                                                               */
      __I  uint32_t  CH5_SMS    :  3;               /*!< CH5_SMS                                                               */
      __I  uint32_t  CH5_FIFO_DEPTH:  3;            /*!< CH5_FIFO_DEPTH                                                        */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_5_H_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_4;               /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH4_DTW    :  3;               /*!< CH4_DTW                                                               */
      __I  uint32_t  CH4_STW    :  3;               /*!< CH4_STW                                                               */
      __I  uint32_t  CH4_STAT_DST:  1;              /*!< CH4_STAT_DST                                                          */
      __I  uint32_t  CH4_STAT_SRC:  1;              /*!< CH4_STAT_SRC                                                          */
      __I  uint32_t  CH4_DST_SCA_EN:  1;            /*!< CH4_DST_SCA_EN                                                        */
      __I  uint32_t  CH4_SRC_GAT_EN:  1;            /*!< CH4_SRC_GAT_EN                                                        */
      __I  uint32_t  CH4_LOCK_EN:  1;               /*!< CH4_LOCK_EN                                                           */
      __I  uint32_t  CH4_MULTI_BLK_EN:  1;          /*!< CH4_MULTI_BLK_EN                                                      */
      __I  uint32_t  CH4_CTL_WB_EN:  1;             /*!< CH4_CTL_WB_EN                                                         */
      __I  uint32_t  CH4_HC_LLP :  1;               /*!< CH4_HC_LLP                                                            */
      __I  uint32_t  CH4_FC     :  2;               /*!< CH4_FC                                                                */
      __I  uint32_t  CH4_MAX_MULT_SIZE:  3;         /*!< CH4_MAX_MULT_SIZE                                                     */
      __I  uint32_t  CH4_DMS    :  3;               /*!< CH4_DMS                                                               */
      __I  uint32_t  CH4_LMS    :  3;               /*!< CH4_LMS                                                               */
      __I  uint32_t  CH4_SMS    :  3;               /*!< CH4_SMS                                                               */
      __I  uint32_t  CH4_FIFO_DEPTH:  3;            /*!< CH4_FIFO_DEPTH                                                        */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_4_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_4_H;             /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH3_DTW    :  3;               /*!< CH3_DTW                                                               */
      __I  uint32_t  CH3_STW    :  3;               /*!< CH3_STW                                                               */
      __I  uint32_t  CH3_STAT_DST:  1;              /*!< CH3_STAT_DST                                                          */
      __I  uint32_t  CH3_STAT_SRC:  1;              /*!< CH3_STAT_SRC                                                          */
      __I  uint32_t  CH3_DST_SCA_EN:  1;            /*!< CH3_DST_SCA_EN                                                        */
      __I  uint32_t  CH3_SRC_GAT_EN:  1;            /*!< CH3_SRC_GAT_EN                                                        */
      __I  uint32_t  CH3_LOCK_EN:  1;               /*!< CH3_LOCK_EN                                                           */
      __I  uint32_t  CH3_MULTI_BLK_EN:  1;          /*!< CH3_MULTI_BLK_EN                                                      */
      __I  uint32_t  CH3_CTL_WB_EN:  1;             /*!< CH3_CTL_WB_EN                                                         */
      __I  uint32_t  CH3_HC_LLP :  1;               /*!< CH3_HC_LLP                                                            */
      __I  uint32_t  CH3_FC     :  2;               /*!< CH3_FC                                                                */
      __I  uint32_t  CH3_MAX_MULT_SIZE:  3;         /*!< CH3_MAX_MULT_SIZE                                                     */
      __I  uint32_t  CH3_DMS    :  3;               /*!< CH3_DMS                                                               */
      __I  uint32_t  CH3_LMS    :  3;               /*!< CH3_LMS                                                               */
      __I  uint32_t  CH3_SMS    :  3;               /*!< CH3_SMS                                                               */
      __I  uint32_t  CH3_FIFO_DEPTH:  3;            /*!< CH3_FIFO_DEPTH                                                        */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_4_H_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_3;               /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH2_DTW    :  3;               /*!< CH2_DTW                                                               */
      __I  uint32_t  CH2_STW    :  3;               /*!< CH2_STW                                                               */
      __I  uint32_t  CH2_STAT_DST:  1;              /*!< CH2_STAT_DST                                                          */
      __I  uint32_t  CH2_STAT_SRC:  1;              /*!< CH2_STAT_SRC                                                          */
      __I  uint32_t  CH2_DST_SCA_EN:  1;            /*!< CH2_DST_SCA_EN                                                        */
      __I  uint32_t  CH2_SRC_GAT_EN:  1;            /*!< CH2_SRC_GAT_EN                                                        */
      __I  uint32_t  CH2_LOCK_EN:  1;               /*!< CH2_LOCK_EN                                                           */
      __I  uint32_t  CH2_MULTI_BLK_EN:  1;          /*!< CH2_MULTI_BLK_EN                                                      */
      __I  uint32_t  CH2_CTL_WB_EN:  1;             /*!< CH2_CTL_WB_EN                                                         */
      __I  uint32_t  CH2_HC_LLP :  1;               /*!< CH2_HC_LLP                                                            */
      __I  uint32_t  CH2_FC     :  2;               /*!< CH2_FC                                                                */
      __I  uint32_t  CH2_MAX_MULT_SIZE:  3;         /*!< CH2_MAX_MULT_SIZE                                                     */
      __I  uint32_t  CH2_DMS    :  3;               /*!< CH2_DMS                                                               */
      __I  uint32_t  CH2_LMS    :  3;               /*!< CH2_LMS                                                               */
      __I  uint32_t  CH2_SMS    :  3;               /*!< CH2_SMS                                                               */
      __I  uint32_t  CH2_FIFO_DEPTH:  3;            /*!< CH2_FIFO_DEPTH                                                        */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_3_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_3_H;             /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH1_DTW    :  3;               /*!< CH1_DTW                                                               */
      __I  uint32_t  CH1_STW    :  3;               /*!< CH1_STW                                                               */
      __I  uint32_t  CH1_STAT_DST:  1;              /*!< CH1_STAT_DST                                                          */
      __I  uint32_t  CH1_STAT_SRC:  1;              /*!< CH1_STAT_SRC                                                          */
      __I  uint32_t  CH1_DST_SCA_EN:  1;            /*!< CH1_DST_SCA_EN                                                        */
      __I  uint32_t  CH1_SRC_GAT_EN:  1;            /*!< CH1_SRC_GAT_EN                                                        */
      __I  uint32_t  CH1_LOCK_EN:  1;               /*!< CH1_LOCK_EN                                                           */
      __I  uint32_t  CH1_MULTI_BLK_EN:  1;          /*!< CH1_MULTI_BLK_EN                                                      */
      __I  uint32_t  CH1_CTL_WB_EN:  1;             /*!< CH1_CTL_WB_EN                                                         */
      __I  uint32_t  CH1_HC_LLP :  1;               /*!< CH1_HC_LLP                                                            */
      __I  uint32_t  CH1_FC     :  2;               /*!< CH1_FC                                                                */
      __I  uint32_t  CH1_MAX_MULT_SIZE:  3;         /*!< CH1_MAX_MULT_SIZE                                                     */
      __I  uint32_t  CH1_DMS    :  3;               /*!< CH1_DMS                                                               */
      __I  uint32_t  CH1_LMS    :  3;               /*!< CH1_LMS                                                               */
      __I  uint32_t  CH1_SMS    :  3;               /*!< CH1_SMS                                                               */
      __I  uint32_t  CH1_FIFO_DEPTH:  3;            /*!< CH1_FIFO_DEPTH                                                        */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_3_H_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_2;               /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH0_DTW    :  3;               /*!< CH0_DTW                                                               */
      __I  uint32_t  CH0_STW    :  3;               /*!< CH0_STW                                                               */
      __I  uint32_t  CH0_STAT_DST:  1;              /*!< CH0_STAT_DST                                                          */
      __I  uint32_t  CH0_STAT_SRC:  1;              /*!< CH0_STAT_SRC                                                          */
      __I  uint32_t  CH0_DST_SCA_EN:  1;            /*!< CH0_DST_SCA_EN                                                        */
      __I  uint32_t  CH0_SRC_GAT_EN:  1;            /*!< CH0_SRC_GAT_EN                                                        */
      __I  uint32_t  CH0_LOCK_EN:  1;               /*!< CH0_LOCK_EN                                                           */
      __I  uint32_t  CH0_MULTI_BLK_EN:  1;          /*!< CH0_MULTI_BLK_EN                                                      */
      __I  uint32_t  CH0_CTL_WB_EN:  1;             /*!< CH0_CTL_WB_EN                                                         */
      __I  uint32_t  CH0_HC_LLP :  1;               /*!< CH0_HC_LLP                                                            */
      __I  uint32_t  CH0_FC     :  2;               /*!< CH0_FC                                                                */
      __I  uint32_t  CH0_MAX_MULT_SIZE:  3;         /*!< CH0_MAX_MULT_SIZE                                                     */
      __I  uint32_t  CH0_DMS    :  3;               /*!< CH0_DMS                                                               */
      __I  uint32_t  CH0_LMS    :  3;               /*!< CH0_LMS                                                               */
      __I  uint32_t  CH0_SMS    :  3;               /*!< CH0_SMS                                                               */
      __I  uint32_t  CH0_FIFO_DEPTH:  3;            /*!< CH0_FIFO_DEPTH                                                        */
           uint32_t : 1; // padding
    } DMA_COMP_PARAMS_2_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_2_H;             /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH0_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH0_MULTI_BLK_TYPE                                               */
      __I  uint32_t  CH1_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH1_MULTI_BLK_TYPE                                               */
      __I  uint32_t  CH2_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH2_MULTI_BLK_TYPE                                               */
      __I  uint32_t  CH3_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH3_MULTI_BLK_TYPE                                               */
      __I  uint32_t  CH4_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH4_MULTI_BLK_TYPE                                               */
      __I  uint32_t  CH5_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH5_MULTI_BLK_TYPE                                               */
      __I  uint32_t  CH6_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH6_MULTI_BLK_TYPE                                               */
      __I  uint32_t  CH7_MULTI_BLK_TYPE:  4;        /*!< DMAH_CH7_MULTI_BLK_TYPEThe values of these bit fields are derived
                                                         from the DMAH_CHx_MULTI_BLK_TYPE coreConsultant parameter. 0x0
                                                          = NO_HARDCODE 0x1 = CONT_RELOAD 0x2 = RELOAD_CONT 0x3 = RELOAD_RELOAD
                                                          0x4 = CONT_LLP 0x5 = RELOAD_LLP 0x6 = LLP_CONT 0x7 = LLP_RELOAD
                                                          0x8 = LLP_LLP                                                        */
    } DMA_COMP_PARAMS_2_H_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_1;               /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  CH0_MAX_BLK_SIZE:  4;          /*!< DMAH_CH0_MAX_BLK_SIZE                                                 */
      __I  uint32_t  CH1_MAX_BLK_SIZE:  4;          /*!< DMAH_CH1_MAX_BLK_SIZE                                                 */
      __I  uint32_t  CH2_MAX_BLK_SIZE:  4;          /*!< DMAH_CH2_MAX_BLK_SIZE                                                 */
      __I  uint32_t  CH3_MAX_BLK_SIZE:  4;          /*!< DMAH_CH3_MAX_BLK_SIZE                                                 */
      __I  uint32_t  CH4_MAX_BLK_SIZE:  4;          /*!< DMAH_CH4_MAX_BLK_SIZE                                                 */
      __I  uint32_t  CH5_MAX_BLK_SIZE:  4;          /*!< DMAH_CH5_MAX_BLK_SIZE                                                 */
      __I  uint32_t  CH6_MAX_BLK_SIZE:  4;          /*!< DMAH_CH6_MAX_BLK_SIZE                                                 */
      __I  uint32_t  CH7_MAX_BLK_SIZE:  4;          /*!< DMAH_CH7_MAX_BLK_SIZEThe values of these bit fields are derived
                                                         from the DMAH_CHx_MAX_BLK_SIZE coreConsultant parameter. 0x0
                                                          = 3 0x1 = 7 0x2 =15 0x3 = 31 0x4 = 63 0x5 = 127 0x6 = 255 0x7
                                                          = 511 0x8 = 1023 0x9 = 2047 0xa = 4095                               */
    } DMA_COMP_PARAMS_1_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMA_COMP_PARAMS_1_H;             /*!< Component Parameters registers                                        */
    
    struct {
      __I  uint32_t  DMAH_BIG_ENDIAN :  1;               /*!< DMAH_BIG_ENDIANThe value of this register is derived from the
                                                         DMAH_BIG_ENDIAN coreConsultant parameter. 0 = FALSE 1 = TRUE          */
      __I  uint32_t  INTR_IO    :  2;               /*!< DMAH_INTR_IOThe value of this register is derived from the DMAH_INTR_IO
                                                         coreConsultant parameter. 0x0 = ALL 0x1 = TYPE 0x2 = COMBINED
                                                          0x3 = reserved                                                       */
      __I  uint32_t  MAX_ABRST  :  1;               /*!< DMAH_MAX_ABRSTThe value of this register is derived from the
                                                         DMAH_MABRST coreConsultant parameter. 0 = FALSE 1 = TRUE              */
           uint32_t             :  4;
      __I  uint32_t  NUM_CHANNELS:  3;              /*!< DMAH_NUM_CHANNELSThe value of this register is derived from
                                                         the DMAH_NUM_CHANNELS coreConsultant parameter. 0x0 = 1 to 0x7
                                                          = 8                                                                  */
      __I  uint32_t  NUM_MASTER_INT:  2;            /*!< DMAH_NUM_MASTER_INTThe value of this register is derived from
                                                         the DMAH_NUM_MASTER_INT coreConsultant parameter. 0x0 = 1 to
                                                          0x3 = 4                                                              */
      __I  uint32_t  S_HDATA_WIDTH:  2;             /*!< DMAH_S_HDATA_WIDTHThe value of this register is derived from
                                                         the DMAH_S_HDATA_WIDTH coreConsultant parameter. 0x0 = 32 bits
                                                          0x1 = 64 bits 0x2 = 128 bits 0x3 = 256 bits                          */
      __I  uint32_t  M4_HDATA_WIDTH:  2;            /*!< DMAH_M4_HDATA_WIDTHThe value of this register is derived from
                                                         the DMAH_M4_HDATA_WIDTH coreConsultant parameter. 0x0 = 32 bits
                                                          0x1 = 64 bits 0x2 = 128 bits 0x3 = 256 bits                          */
      __I  uint32_t  M3_HDATA_WIDTH:  2;            /*!< DMAH_M3_HDATA_WIDTHThe value of this register is derived from
                                                         the DMAH_M3_HDATA_WIDTH coreConsultant parameter. 0x0 = 32 bits
                                                          0x1 = 64 bits 0x2 = 128 bits 0x3 = 256 bits                          */
      __I  uint32_t  M2_HDATA_WIDTH:  2;            /*!< DMAH_M2_HDATA_WIDTHThe value of this register is derived from
                                                         the DMAH_M2_HDATA_WIDTH coreConsultant parameter. 0x0 = 32 bits
                                                          0x1 = 64 bits 0x2 = 128 bits 0x3 = 256 bits                          */
      __I  uint32_t  M1_HDATA_WIDTH:  2;            /*!< DMAH_M1_HDATA_WIDTHThe value of this register is derived from
                                                         the DMAH_M1_HDATA_WIDTH coreConsultant parameter. 0x0 = 32 bits
                                                          0x1 = 64 bits 0x2 = 128 bits 0x3 = 256 bits                          */
      __I  uint32_t  NUM_HS_INT :  5;               /*!< DMAH_NUM_HS_INTThe value of this register is derived from the
                                                         DMAH_NUM_HS_INT coreConsultant parameter. . 0x00 = 0 to 0x10
                                                          = 16                                                                 */
      __I  uint32_t  ADD_ENCODED_PARAMS:  1;        /*!< DMAH_ADD_ENCODED_PARAMSThe value of this register is derived
                                                         from the DMAH_ADD_ENCODED_PARAMS coreConsultant parameter. 0
                                                          = FALSE 1 = TRUE                                                     */
      __I  uint32_t  STATIC_ENDIAN_SELECT:  1;      /*!< DMAH_STATIC_ENDIAN_SELECTThe value of this register is derived
                                                         from the DMAH_STATIC_ENDIAN_SELECT coreConsultant parameter.
                                                          0 = FALSE 1 = TRUE                                                   */
           uint32_t : 2; // padding
    } DMA_COMP_PARAMS_1_H_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMACOMPSID;                      /*!< DMA Component ID register                                             */
    
    struct {
      __I  uint32_t  DMA_COMP_TYPE: 32;             /*!< DMA Component identifier - Fixed at `h44571110                        */
    } DMACOMPSID_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DMACOMPSID_H;                    /*!< DMA Component ID register                                             */
    
    struct {
      __I  uint32_t  DMA_COMP_VERSION: 32;          /*!< DMA Component Version                                                 */
    } DMACOMPSID_H_b;                               /*!< BitSize                                                               */
  };
} sdmac_Type;


/* ================================================================================ */
/* ================                       rng                      ================ */
/* ================================================================================ */


/**
  * @brief rng (rng)
  */

typedef struct {                                    /*!< rng Structure                                                         */
  
  union {
    __I  uint32_t  RNDO;                            /*!< Random Number Output Register                                         */
    
    struct {
      __I  uint32_t  RNDO       : 32;               /*!< When [RNDREADY] is 1, 32-bit intrinsic random numbers can be
                                                         read every time data is read.When [RNDREADY] is 0, 0 can be
                                                          read.Although this is 0 immediately after reset cancellation,
                                                          RNDREADY becomes 1 after a while, allowing random numbers to
                                                          be read through this register.                                       */
    } RNDO_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RNDREADY;                        /*!< Random Number Ready Register                                          */
    
    struct {
      __I  uint32_t  RNDREADY   :  1;               /*!< 0b0: 0 can be read through [RNDO] because of random numbers
                                                         being generated. 0b1: Random numbers can be read through [RNDO]
                                                          since random number generation has been completed. This is 0
                                                          immediately after reset cancellation, but becomes 1 after a
                                                          while.                                                               */
           uint32_t : 31; // padding
    } RNDREADY_b;                                   /*!< BitSize                                                               */
  };
} rng_Type;


/* ================================================================================ */
/* ================                      sramc                     ================ */
/* ================================================================================ */


/**
  * @brief sramc (sramc)
  */

typedef struct {                                    /*!< sramc Structure                                                       */
  
  union {
    __IO uint32_t  M2MSTART;                        /*!< M2M activation signal                                                 */
    
    struct {
      __IO uint32_t  START      :  1;               /*!< 1: Activation0: Invalid* '0' is always returned when data is
                                                         read                                                                  */
           uint32_t : 31; // padding
    } M2MSTART_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  M2MSTOP;                         /*!< M2M Stop                                                              */
    
    struct {
      __IO uint32_t  STOP       :  1;               /*!< 1: Stop0: Invalid* '0' is always returned when data is read           */
           uint32_t : 31; // padding
    } M2MSTOP_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  M2MSTATUS;                       /*!< Status                                                                */
    
    struct {
      __I  uint32_t  STATUS     :  2;               /*!< 0b10: Waits for interrupt clearing0b01: In operation0b00: Under
                                                         stop                                                                  */
      __I  uint32_t  SIZE       : 16;               /*!< Size of data being currently transferred (amount of data that
                                                         have been transferred so far)                                         */
           uint32_t : 14; // padding
    } M2MSTATUS_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;
  
  union {
    __IO uint32_t  M2MSRCADDR;                      /*!< Source address                                                        */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  ADDR       : 30;               /*!< Address from which to read dataSet in units of words                  */
    } M2MSRCADDR_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];
  
  union {
    __IO uint32_t  M2MDSTADDR;                      /*!< Destination address                                                   */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  ADDR       : 30;               /*!< Address to which to write dataSet in units of words                   */
    } M2MDSTADDR_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  M2MSIZE;                         /*!< Transfer size                                                         */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  SIZE       : 16;               /*!< Transfer size settings. The source and destination have the
                                                         same transfer size.Set in units of words.                             */
           uint32_t : 14; // padding
    } M2MSIZE_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[2];
  
  union {
    __IO uint32_t  M2MINTEN;                        /*!< Interrupt function ON/OFF                                             */
    
    struct {
      __IO uint32_t  EN         :  1;               /*!< 1: Interrupt function ON0: Interrupt function OFF                     */
           uint32_t : 31; // padding
    } M2MINTEN_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  M2MINTCLR;                       /*!< Interrupt clearing                                                    */
    
    struct {
      __IO uint32_t  CLR        :  1;               /*!< 1: Activation0: Invalid* '0' is always returned when data is
                                                         read.                                                                 */
           uint32_t : 31; // padding
    } M2MINTCLR_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[2];
  
  union {
    __IO uint32_t  ERRINTEN;                        /*!< Error interrupt output function ON/OFF                                */
    
    struct {
      __IO uint32_t  EN         :  1;               /*!< 1: Error interrupt output function ON0: Error interrupt output
                                                         function OFF                                                          */
           uint32_t : 31; // padding
    } ERRINTEN_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  ERRSTATUS;                       /*!< Error cause                                                           */
    
    struct {
      __I  uint32_t  STATUS     :  4;               /*!< Error cause indication[3]=1:Error4 occurs[2]=1:Error3 occurs[1]=1:Error2
                                                         occurs[0]=1:Error1 occurs                                             */
           uint32_t : 28; // padding
    } ERRSTATUS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  ERR1LOG;                         /*!< Error1 cause                                                          */
    
    struct {
      __I  uint32_t  STATUS     :  3;               /*!< Error1 occurrence cause I/F0b101:S2M0b100:M2M0b010:Bus(AHB Port2)0b001:Bus
                                                         (AHB Port1)0b000:Bus(AHB Port0)                                       */
           uint32_t             :  7;
      __I  uint32_t  ADDR       : 22;               /*!< Error1 occurrence access globus address (in units of 1kB)             */
    } ERR1LOG_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  ERR2LOG;                         /*!< Error2 cause                                                          */
    
    struct {
      __I  uint32_t  STATUS     :  3;               /*!< Error2 occurrence cause I/F0b100:M2M0b010:Bus(AHB Port2)0b001:Bus(AHB
                                                         Port1)0b000:Bus(AHB Port0)                                            */
           uint32_t             :  7;
      __I  uint32_t  ADDR       : 22;               /*!< Error2 occurrence access globus address (in units of 1kB)             */
    } ERR2LOG_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ERRCLR;                          /*!< Error cause detection clearing                                        */
    
    struct {
      __IO uint32_t  CLR        :  4;               /*!< [3]: Clears detection of Error4 cause[2]: Clears detection of
                                                         Error3 cause[1]: Clears detection of Error2 cause[0]: Clears
                                                          detection of Error1 cause* '0' is always returned when data
                                                          is read.                                                             */
           uint32_t : 28; // padding
    } ERRCLR_b;                                     /*!< BitSize                                                               */
  };
} sramc_Type;


/* ================================================================================ */
/* ================                       evm                      ================ */
/* ================================================================================ */


/**
  * @brief evm (evm)
  */

typedef struct {                                    /*!< evm Structure                                                         */
  
  union {
    __IO uint32_t  EVM_EN;                          /*!< EVM_EN                                                                */
    
    struct {
      __IO uint32_t  evm_enable :  1;               /*!< Enable signal for this block0: Stop1: Operation                       */
           uint32_t : 31; // padding
    } EVM_EN_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[3];
  
  union {
    __IO uint32_t  TRIGGER_CH0;                     /*!< TRIGGER_CH0                                                           */
    
    struct {
      __IO uint32_t  trigger_enable:  1;            /*!< Trigger operation enable signal0: Stop1: Operation                    */
           uint32_t             :  7;
      __IO uint32_t  event_sel  :  4;               /*!< Event signal selectionWritable only when bit0 (trigger enable)
                                                         is 'L'.Ignored if written when the bit is 'H'.0000: Selects
                                                          event 0.0001: Selects event 1.0010: Selects event 2.0011: Selects
                                                          event 3.0100: Selects event 4.0101: Selects event 5.0110: Selects
                                                          event 6.0111: Selects event 7.1000: Selects event 8.1001: Selects
                                                          event 9.If the setting is other than the above, the trigger
                                                          signal is fixed at Low Level.                                        */
           uint32_t             : 19;
      __I  uint32_t  status     :  1;               /*!< Indicates the trigger status.0: Trigger signal is Low.1: Trigger
                                                         signal is High.                                                       */
    } TRIGGER_CH0_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TRIGGER_CH1;                     /*!< TRIGGER_CH1                                                           */
    
    struct {
      __IO uint32_t  trigger_enable:  1;            /*!< Trigger operation enable signal0: Stop1: Operation                    */
           uint32_t             :  7;
      __IO uint32_t  event_sel  :  4;               /*!< Event signal selectionWritable only when bit0 (trigger enable)
                                                         is 'L'.Ignored if written when the bit is 'H'.0000: Selects
                                                          event 0.0001: Selects event 1.0010: Selects event 2.0011: Selects
                                                          event 3.0100: Selects event 4.0101: Selects event 5.0110: Selects
                                                          event 6.0111: Selects event 7.1000: Selects event 8.1001: Selects
                                                          event 9.If the setting is other than the above, the trigger
                                                          signal is fixed at Low Level.                                        */
           uint32_t             : 19;
      __I  uint32_t  status     :  1;               /*!< Indicates the trigger status.0: Trigger signal is Low.1: Trigger
                                                         signal is High.                                                       */
    } TRIGGER_CH1_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TRIGGER_CH2;                     /*!< TRIGGER_CH2                                                           */
    
    struct {
      __IO uint32_t  trigger_enable:  1;            /*!< Trigger operation enable signal0: Stop1: Operation                    */
           uint32_t             :  7;
      __IO uint32_t  event_sel  :  4;               /*!< Event signal selectionWritable only when bit0 (trigger enable)
                                                         is 'L'.Ignored if written when the bit is 'H'.0000: Selects
                                                          event 0.0001: Selects event 1.0010: Selects event 2.0011: Selects
                                                          event 3.0100: Selects event 4.0101: Selects event 5.0110: Selects
                                                          event 6.0111: Selects event 7.1000: Selects event 8.1001: Selects
                                                          event 9.If the setting is other than the above, the trigger
                                                          signal is fixed at Low Level.                                        */
           uint32_t             : 19;
      __I  uint32_t  status     :  1;               /*!< Indicates the trigger status.0: Trigger signal is Low.1: Trigger
                                                         signal is High.                                                       */
    } TRIGGER_CH2_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TRIGGER_CH3;                     /*!< TRIGGER_CH3                                                           */
    
    struct {
      __IO uint32_t  trigger_enable:  1;            /*!< Trigger operation enable signal0: Stop1: Operation                    */
           uint32_t             :  7;
      __IO uint32_t  event_sel  :  4;               /*!< Event signal selectionWritable only when bit0 (trigger enable)
                                                         is 'L'.Ignored if written when the bit is 'H'.0000: Selects
                                                          event 0.0001: Selects event 1.0010: Selects event 2.0011: Selects
                                                          event 3.0100: Selects event 4.0101: Selects event 5.0110: Selects
                                                          event 6.0111: Selects event 7.1000: Selects event 8.1001: Selects
                                                          event 9.If the setting is other than the above, the trigger
                                                          signal is fixed at Low Level.                                        */
           uint32_t             : 19;
      __I  uint32_t  status     :  1;               /*!< Indicates the trigger status.0: Trigger signal is Low.1: Trigger
                                                         signal is High.                                                       */
    } TRIGGER_CH3_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TRIGGER_CH4;                     /*!< TRIGGER_CH4                                                           */
    
    struct {
      __IO uint32_t  trigger_enable:  1;            /*!< Trigger operation enable signal0: Stop1: Operation                    */
           uint32_t             :  7;
      __IO uint32_t  event_sel  :  4;               /*!< Event signal selectionWritable only when bit0 (trigger enable)
                                                         is 'L'.Ignored if written when the bit is 'H'.0000: Selects
                                                          event 0.0001: Selects event 1.0010: Selects event 2.0011: Selects
                                                          event 3.0100: Selects event 4.0101: Selects event 5.0110: Selects
                                                          event 6.0111: Selects event 7.1000: Selects event 8.1001: Selects
                                                          event 9.If the setting is other than the above, the trigger
                                                          signal is fixed at Low Level.                                        */
           uint32_t             : 19;
      __I  uint32_t  status     :  1;               /*!< Indicates the trigger status.0: Trigger signal is Low.1: Trigger
                                                         signal is High.                                                       */
    } TRIGGER_CH4_b;                                /*!< BitSize                                                               */
  };
} evm_Type;


/* ================================================================================ */
/* ================                      rtclv                     ================ */
/* ================================================================================ */


/**
  * @brief rtclv (rtclv)
  */

typedef struct {                                    /*!< rtclv Structure                                                       */
  
  union {
    __IO uint32_t  RTC_TIMESET1;                    /*!< Time Set 1 Register                                                   */
    
    struct {
      __IO uint32_t  SECSET_UNDER10:  4;            /*!< Sets the second counter (ones place).The settable values are
                                                         0 to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
      __IO uint32_t  SECSET_OVER10:  3;             /*!< Sets the second counter (tens place).The settable values are
                                                         0 to 5 (0b000 to 0b101).No other values can be set (writing
                                                          disable).                                                            */
           uint32_t             :  1;
      __IO uint32_t  MINSET_UNDER10:  4;            /*!< Sets the minute counter (ones place).The settable values are
                                                         0 to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
      __IO uint32_t  MINSET_OVER10:  3;             /*!< Sets the minute counter (tens place).The settable values are
                                                         0 to 5 (0b000 to 0b101).No other values can be set (writing
                                                          disable).                                                            */
           uint32_t : 17; // padding
    } RTC_TIMESET1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_TIMESET2;                    /*!< Time Set 2 Register                                                   */
    
    struct {
      __IO uint32_t  HOURSET_UNDER10:  4;           /*!< Sets the hour counter (ones place).The settable values are 0
                                                         to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
      __IO uint32_t  HOURSET_OVER10:  2;            /*!< Sets the hour counter (tens place).The settable values are 0
                                                         to 3 (0b00 to 0b11).(Note) In 12-hour mode, bit5 is used to
                                                          differentiate AM/PM. So, to set the time in the afternoon, set
                                                          bit5 to '1'.                                                         */
           uint32_t             :  2;
      __IO uint32_t  DAYSET_UNDER10:  4;            /*!< Sets the day counter (ones place).The settable values are 0
                                                         to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
      __IO uint32_t  DAYSET_OVER10:  2;             /*!< Sets the day counter (tens place).The settable values are 0
                                                         to 3 (0b00 to 0b11).                                                  */
           uint32_t : 18; // padding
    } RTC_TIMESET2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_TIMESET3;                    /*!< Time Set 3 Register                                                   */
    
    struct {
      __IO uint32_t  MONTHSET_UNDER10:  4;          /*!< Sets the month counter (ones place).The settable values are
                                                         0 to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
      __IO uint32_t  MONTHSET_OVER10:  1;           /*!< Sets the month counter (tens place).The settable values are
                                                         0 and 1 (0b0 to 0b1).                                                 */
      __IO uint32_t  WEEKSET    :  3;               /*!< Sets the day-of-week counter.0b000: Sunday0b001: Monday0b010:
                                                         Tuesday0b011: Wednesday0b100: Thursday0b101: Friday0b110: Saturday0b111:
                                                          Reserved (unsettable (writing disable))                              */
      __IO uint32_t  YEARSET_UNDER10:  4;           /*!< Sets the year counter (ones place).The settable values are 0
                                                         to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
      __IO uint32_t  YEARSET_OVER10:  4;            /*!< Sets the year counter (tens place).The settable values are 0
                                                         to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
           uint32_t : 16; // padding
    } RTC_TIMESET3_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_TIMESET4;                    /*!< Time Set 4 Register                                                   */
    
    struct {
      __IO uint32_t  LEAP       :  2;               /*!< Sets the leap year ('0': leap year)The settable values are 0
                                                         to 3 (0b00 to 0b11).                                                  */
           uint32_t : 30; // padding
    } RTC_TIMESET4_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_CTRL;                        /*!< Control Register                                                      */
    
    struct {
      __IO uint32_t  ALRST      :  1;               /*!< Loads the alarm setting.After loading of setting data is complete,
                                                         0 is automatically set.At writing: 0b1: Starts loading of the
                                                          setting data. 0b0: No operationAt reading: 0b1: Loading of the
                                                          setting data is in progress. 0b0: Loading of the setting data
                                                          is complete.                                                         */
      __IO uint32_t  ALEN       :  1;               /*!< Alarm function enable0b1: Enable0b0: Disable                          */
      __IO uint32_t  PRRST      :  1;               /*!< Loads the periodic interrupt setting.After loading of setting
                                                         data is complete, 0 is automatically set.At writing: 0b1: Starts
                                                          loading of the setting data. 0b0: No operationAt reading: 0b1:
                                                          Loading of the setting data is in progress. 0b0: Loading of
                                                          the setting data is complete.                                        */
      __IO uint32_t  PREN       :  1;               /*!< Periodic interrupt function enable0b1: Enable0b0: Disable             */
      __IO uint32_t  ADJUST     :  1;               /*!< Time count adjustmentAfter adjustment is complete, 0 is automatically
                                                         set.At writing: 0b1: Starts adjustment. 0b0: No operationAt
                                                          reading: 0b1: Adjustment in progress 0b0: Adjustment completed       */
      __IO uint32_t  HR24_12    :  1;               /*!< 24/12Hr selection0b1: 24-hour notation0b0: 12-hour notation           */
      __IO uint32_t  TMRST      :  1;               /*!< Loading the time counter with TIMESET1 to 4 register settingsAfter
                                                         loading of setting data to the time counter is complete, 0 is
                                                          automatically set.At writing: 0b1: Starts loading of setting
                                                          data. 0b0: No operationAt reading: 0b1: Loading of the setting
                                                          data is in progress. 0b0: Loading of setting data is complete.       */
      __IO uint32_t  TMEN       :  1;               /*!< RTC operation enable0b1: Enable0b0: Disable                           */
      __IO uint32_t  INTVALRST  :  1;               /*!< Loads the interval timer setting.After setting data loading
                                                         is complete, 0 is automatically set.At writing: 0b1: Starts
                                                          loading of the setting data. 0b0: No operationAt reading: 0b1:
                                                          Loading of the setting data is in progress. 0b0: Loading of
                                                          the setting data is complete.                                        */
      __IO uint32_t  INTVALEN   :  1;               /*!< Interval timer enable0b1: Enable0b0: Disable                          */
           uint32_t : 22; // padding
    } RTC_CTRL_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RTC_STATUS;                      /*!< RTC_STATUS                                                            */
    
    struct {
      __I  uint32_t  RTC_READY  :  1;               /*!< If the RTC counter value becomes ready to be read, 1 is automatically
                                                         set.                                                                  */
           uint32_t : 31; // padding
    } RTC_STATUS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RTC_CTRL_WIP;                    /*!< Control Register write access status                                  */
    
    struct {
      __I  uint32_t  ALRST      :  1;               /*!< [RTC_CTRL].ALRST bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  ALEN       :  1;               /*!< [RTC_CTRL].ALEN bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  PRRST      :  1;               /*!< [RTC_CTRL].PRRST bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  PREN       :  1;               /*!< [RTC_CTRL].PREN bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  ADJUST     :  1;               /*!< [RTC_CTRL].ADJUST bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  HR24_12    :  1;               /*!< [RTC_CTRL].HR24_12 bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  TMRST      :  1;               /*!< [RTC_CTRL].TMRST bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  TMEN       :  1;               /*!< [RTC_CTRL].TMEN bit status of write access 0b0:writable 0b1:not
                                                         writable                                                              */
      __I  uint32_t  INTVALRST  :  1;               /*!< [RTC_CTRL].INTVALRST bit status of write access 0b0:writable
                                                         0b1:not writable                                                      */
      __I  uint32_t  INTVALEN   :  1;               /*!< [RTC_CTRL].INTVALEN bit status of write access 0b0:writable
                                                         0b1:not writable                                                      */
           uint32_t : 22; // padding
    } RTC_CTRL_WIP_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;
  
  union {
    __I  uint32_t  RTC_RIS;                         /*!< Raw Interrupt Status Register                                         */
    
    struct {
      __I  uint32_t  ALARM_INTRAWST:  1;            /*!< Alarm interrupt status0b1: Interrupt request available0b0: No
                                                         interrupt request                                                     */
      __I  uint32_t  PERIOD_INTRAWST:  1;           /*!< Periodic interrupt status0b1: Interrupt request available0b0:
                                                         No interrupt request                                                  */
      __I  uint32_t  INTVAL_INTRAWST:  1;           /*!< Interval-timer interrupt status0b1: Interrupt request available0b0:
                                                         No interrupt request                                                  */
           uint32_t : 29; // padding
    } RTC_RIS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RTC_MIS;                         /*!< Masked Interrupt Status Register                                      */
    
    struct {
      __I  uint32_t  ALARM_INTMASKST:  1;           /*!< Alarm interrupt status0b1: Interrupt request available0b0: No
                                                         interrupt requestNot set when ALARM_INTMASK=0.                        */
      __I  uint32_t  PERIOD_INTMASKST:  1;          /*!< Periodic interrupt status0b1: Interrupt request available0b0:
                                                         No interrupt requestNot set when PERIOD_INTMASK=0.                    */
      __I  uint32_t  INTVAL_INTMASKST:  1;          /*!< Interval-timer interrupt status0b1: Interrupt request available0b0:
                                                         No interrupt requestNot set when INTVAL_INTMASK=0.                    */
           uint32_t : 29; // padding
    } RTC_MIS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_INTMASK;                     /*!< Interrupt Mask Register                                               */
    
    struct {
      __IO uint32_t  ALARM_INTMASK:  1;             /*!< Alarm interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
      __IO uint32_t  PERIOD_INTMASK:  1;            /*!< Periodic interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
      __IO uint32_t  INTVAL_INTMASK:  1;            /*!< Interval-timer interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
           uint32_t : 29; // padding
    } RTC_INTMASK_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_PERIODIC;                    /*!< Periodic Interrupt Set Register                                       */
    
    struct {
      __IO uint32_t  PERIODIC_INTSET:  4;           /*!< Sets the periodic interrupt (every second, every minute, every
                                                         hour, every day, every month)0b0000: No periodic interrupt occurrence0b000
                                                         1: Every second (at the same time with second counting-up)0b0010:
                                                          00 second every minute0b0011: 00 minute 00 second every hour0b0100:
                                                          00 hour 00 minute 00 second every day0b0101: 00 hour 00 minute
                                                          00 second every month0b0110: Reserved (unsettable (writing disable))0b0111
                                                         : Reserved (unsettable (writing disable))0b1000: Every 1/2 second0b1001:
                                                          Every 1/4 second0b1010: Every                                        */
           uint32_t : 28; // padding
    } RTC_PERIODIC_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_PERIOD_INTCLR;               /*!< Periodic Interrupt Clear                                              */
    
    struct {
      __IO uint32_t  PERIOD_INTCLR: 32;             /*!< Clears the periodic interrupt.If a value is written to this
                                                         register, the periodic interrupt is cleared, regardless of the
                                                          value to be written.                                                 */
    } RTC_PERIOD_INTCLR_b;                          /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_ALARM_INTCLR;                /*!< Alarm Interrupt Clear                                                 */
    
    struct {
      __IO uint32_t  ALARM_INTCLR: 32;              /*!< Clears the alarm interrupt.If a value is written to this register,
                                                         the alarm interrupt is cleared, regardless of the value to be
                                                          written.                                                             */
    } RTC_ALARM_INTCLR_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_INTVAL_INTCLR;               /*!< Interval Interrupt Clear                                              */
    
    struct {
      __IO uint32_t  INTVAL_INTCLR: 32;             /*!< Clears the interval-timer interrupt.If a value is written to
                                                         this register, the interval-timer interrupt is cleared, regardless
                                                          of the value to be written.                                          */
    } RTC_INTVAL_INTCLR_b;                          /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1;
  
  union {
    __I  uint32_t  RTC_CURRENT1;                    /*!< Current Time 1 Register                                               */
    
    struct {
      __I  uint32_t  SECVAL_UNDER10:  4;            /*!< Current value of the second counter (ones place)                      */
      __I  uint32_t  SECVAL_OVER10:  3;             /*!< Current value of the second counter (tens place)                      */
           uint32_t             :  1;
      __I  uint32_t  MINVAL_UNDER10:  4;            /*!< Current value of the minute counter (ones place)                      */
      __I  uint32_t  MINVAL_OVER10:  3;             /*!< Current value of the minute counter (tens place)                      */
           uint32_t : 17; // padding
    } RTC_CURRENT1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RTC_CURRENT2;                    /*!< Current Time 2 Register                                               */
    
    struct {
      __I  uint32_t  HOURVAL_UNDER10:  4;           /*!< Current value of the hour counter (ones place)                        */
      __I  uint32_t  HOURVAL_OVER10:  2;            /*!< Current value of the hour counter (tens place)                        */
           uint32_t             :  2;
      __I  uint32_t  DAYVAL_UNDER10:  4;            /*!< Current value of the day counter (ones place)                         */
      __I  uint32_t  DAYVAL_OVER10:  2;             /*!< Current value of the day counter (tens place)                         */
           uint32_t : 18; // padding
    } RTC_CURRENT2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RTC_CURRENT3;                    /*!< Current Time 3 Register                                               */
    
    struct {
      __I  uint32_t  MONTHVAL_UNDER10:  4;          /*!< Current value of the month counter (ones place)                       */
      __I  uint32_t  MONTHVAL_OVER10:  1;           /*!< Current value of the month counter (tens place)                       */
      __I  uint32_t  WEEKVAL    :  3;               /*!< Current value of the day-of-week counter                              */
      __I  uint32_t  YEARVAL_UNDER10:  4;           /*!< Current value of the year counter (ones place)                        */
      __I  uint32_t  YEARVAL_OVER10:  4;            /*!< Current value of the year counter (tens place)                        */
           uint32_t : 16; // padding
    } RTC_CURRENT3_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RTC_CURRENT4;                    /*!< Current Time 4 Register                                               */
    
    struct {
      __I  uint32_t  LEAP       :  2;               /*!< Current value of the leap year counter                                */
           uint32_t : 30; // padding
    } RTC_CURRENT4_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_ALARM1;                      /*!< Alarm Set 1 Register                                                  */
    
    struct {
           uint32_t             :  8;
      __IO uint32_t  AL_MINSET_UNDER10:  4;         /*!< Sets the minute counter (ones place) for alarm.The settable
                                                         values are 0 to 9 ((0b0000 to 0b1001).No other values can be
                                                          set (writing disable).                                               */
      __IO uint32_t  AL_MINSET_OVER10:  3;          /*!< Sets the minute counter (tens place) for alarm.The settable
                                                         values are 0 to 5 ((0b000 to 0b101).No other values can be set
                                                          (writing disable).                                                   */
           uint32_t : 17; // padding
    } RTC_ALARM1_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_ALARM2;                      /*!< Alarm Set 2 Register                                                  */
    
    struct {
      __IO uint32_t  AL_HOURSET_UNDER10:  4;        /*!< Sets the hour counter (ones place) for alarm.The settable values
                                                         are 0 to 9 (0b0000 to 0b1001).No other values can be set (writing
                                                          disable).                                                            */
      __IO uint32_t  AL_HOURSET_OVER10:  2;         /*!< Sets the hour counter (tens place) for alarm.The settable values
                                                         are 0 to 3 (0b00 to 0b11).(Note) In 12-hour mode, bit5 is used
                                                          to differentiate AM/PM. So, to set the time in the afternoon,
                                                          set bit5 to '1'.                                                     */
           uint32_t             :  2;
      __IO uint32_t  AL_DAYSET_UNDER10:  4;         /*!< Sets the minute counter (ones place) for alarm.The settable
                                                         values are 0 to 9 (0b0000 to 0b1001).No other values can be
                                                          set (writing disable).                                               */
      __IO uint32_t  AL_DAYSET_OVER10:  2;          /*!< Sets the day counter (tens place) for alarm.The settable values
                                                         are 0 to 3 (0b00 to 0b11).                                            */
           uint32_t : 18; // padding
    } RTC_ALARM2_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RTC_ALARM3;                      /*!< Alarm Set 3 Register                                                  */
    
    struct {
           uint32_t             :  5;
      __IO uint32_t  AL_WEEKSET :  3;               /*!< Sets the day-of-week counter for alarm.0b000: Sunday0b001: Monday0b010:
                                                         Tuesday0b011: Wednesday0b100: Thursday0b101: Friday0b110: Saturday0b111:
                                                          Reserved                                                             */
           uint32_t : 24; // padding
    } RTC_ALARM3_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;
  
  union {
    __IO uint32_t  RTC_INTVAL_SET;                  /*!< Interval Timer Set Register                                           */
    
    struct {
      __IO uint32_t  INTVAL_SET : 16;               /*!< Sets the interval-timer interrupt generation time.This value
                                                         is set with the number of cycles of the source clock (2.048kHz)
                                                          of the timer. The time of (setting value + 1) cycles is the
                                                          period that continues until interrupt generation.Setting of
                                                          0x0000 is prohibited.                                                */
           uint32_t : 16; // padding
    } RTC_INTVAL_SET_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RTC_INTVAL_TMR;                  /*!< RTC_INTVAL_TMR                                                        */
    
    struct {
      __I  uint32_t  COUNT_VAL  : 16;               /*!< Current value of interval-timer counter can be read.                  */
           uint32_t : 16; // padding
    } RTC_INTVAL_TMR_b;                             /*!< BitSize                                                               */
  };
} rtclv_Type;


/* ================================================================================ */
/* ================                     advtmr                     ================ */
/* ================================================================================ */


/**
  * @brief advtmr (advtmr)
  */

typedef struct {                                    /*!< advtmr Structure                                                      */
  
  union {
    __IO uint32_t  T0LOAD;                          /*!< T0 Load Register                                                      */
    
    struct {
      __IO uint32_t  Load       : 16;               /*!< Initial or reload value of the counter (0x0001 to 0xFFFF settable)The
                                                         0x0000 setting does not operate the counter. Setting any numeric
                                                          value other than that enables counting.(Note) Writing to this
                                                          register writes the same value to Timer0BGLoad.                      */
           uint32_t : 16; // padding
    } T0LOAD_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0VALUE;                         /*!< T0 Current value Register                                             */
    
    struct {
      __I  uint32_t  value      : 16;               /*!< Count value of the counter at the current time                        */
           uint32_t : 16; // padding
    } T0VALUE_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CONTROL;                       /*!< T0 Control Register                                                   */
    
    struct {
      __IO uint32_t  Clock_divid:  3;               /*!< Prescaler (clock frequency division) 0b111: 1/1024 frequency
                                                         division 0b110: 1/512 frequency division 0b101: 1/128 frequency
                                                          division 0b100: 1/32 frequency division 0b011: 1/8 frequency
                                                          division 0b010: 1/4 frequency division 0b001: 1/2 frequency
                                                          division 0x0: No frequency division (same magnification)             */
      __IO uint32_t  Timer_size :  1;               /*!< Timer bit width selection 0x1: Operation as a 16-bit timer 0x0:
                                                         Operation as an 8-bit timer (high-order bits not used)                */
      __IO uint32_t  One_Shot_Count:  1;            /*!< Timer wrapping/one-shot selection 1: One-shot (one time only)
                                                         0: Wrapping (wrapping)                                                */
      __IO uint32_t  Periodic_Mode:  1;             /*!< Timer operation mode 1: Periodic timer (periodic timer) 0: Free-run
                                                         timer (free-run timer)                                                */
      __IO uint32_t  Interrupt_Enable:  1;          /*!< Interrupt control 1: Interrupt enable 0: Interrupt disable            */
      __IO uint32_t  Enable     :  1;               /*!< Timer operation control 1: Enable 0: Disable                          */
      __IO uint32_t  Event_Mode :  2;               /*!< Event counter operation control 0b11: Event timer (event timer)
                                                         count source: External terminal T0EVCNTSRC 0b10:Event timer
                                                          (event timer) count source: Internal prescaler 0b0*: Normal
                                                          timer (normal timer)                                                 */
           uint32_t : 22; // padding
    } T0CONTROL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0INTCLR;                        /*!< T0 Interrupt clear Register                                           */
    
    struct {
      __IO uint32_t  IntClr     : 32;               /*!< Interrupt clearAfter the T0TIMINT interrupt occurs, it can be
                                                         cleared by write access to this register.                             */
    } T0INTCLR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0RIS;                           /*!< T0 Raw Interrupt Status Register                                      */
    
    struct {
      __I  uint32_t  RIS        :  1;               /*!< A timer interrupt before masking (T0TIMINT) is occurring. (The
                                                         interrupt occurs when the counter becomes 0x0000.) 1: Interrupt
                                                          request available 0: No interrupt request                            */
           uint32_t : 31; // padding
    } T0RIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0MIS;                           /*!< T0 Masked Interrupt Status Register                                   */
    
    struct {
      __I  uint32_t  MIS        :  1;               /*!< A timer interrupt after masking (T0TIMINT) is occurring. 1:
                                                         Interrupt request available 0: No interrupt request                   */
           uint32_t : 31; // padding
    } T0MIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0BGLOAD;                        /*!< T0 BackGround Load Register                                           */
    
    struct {
      __IO uint32_t  BGLoad     : 16;               /*!< Background Load registerA count value set in this register is
                                                         reloaded after the counter becomes 0x0000 (terminal count).The
                                                          count value to be reloaded can be changed safely during counting.(Note)
                                                          Writing to this register does not allow writing to Timer0Load.       */
           uint32_t : 16; // padding
    } T0BGLOAD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0INTCNT;                        /*!< T0 Interrupt Count Register                                           */
    
    struct {
      __IO uint32_t  IntCount   :  8;               /*!< Count value for the number of times it became a terminal count
                                                         of the counter main body.<At read> A count value for the number
                                                          of times it became a terminal count can be read.<At write> A
                                                          counter value of Timer0IntCnt can be made to become 0x00 by
                                                          write access to this register with regard to the timer interrupt
                                                          generation counter.This register is not cleared by write access
                                                          of Timer0IntClr. It is not affected by the Timer0Control:Interrupt
                                                          Enable bit.                                                          */
           uint32_t : 24; // padding
    } T0INTCNT_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0CAPTURE;                       /*!< T0 Capture value Register                                             */
    
    struct {
      __I  uint32_t  CapReg     : 16;               /*!< Stores a count value when the T0CAPREQ signal is input.If the
                                                         T0CAPREQ[x] signal is input during capture data reading, the
                                                          count value is immediately stored after capture data reading
                                                          ends.                                                                */
           uint32_t : 16; // padding
    } T0CAPTURE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[7];
  
  union {
    __IO uint32_t  T0CAPINTCLR;                     /*!< T0 Capture Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CapIntClr  : 32;               /*!< After a capture interrupt (T0CAPINT[x]) occurs, it can be cleared
                                                         by write access to this register.                                     */
    } T0CAPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[7];
  
  union {
    __I  uint32_t  T0CAPRIS;                        /*!< T0 Capture Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CapRIS     :  1;               /*!< A capture interrupt before masking (T0CAPINT[x]) is occurring.
                                                         1: Interrupt request available 0: No interrupt request                */
           uint32_t : 31; // padding
    } T0CAPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0CAPMIS;                        /*!< T0 Capture Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CapMIS     :  1;               /*!< A capture interrupt after masking (T0CAPINTx) is occurring.
                                                         1: Interrupt request available 0: No interrupt request                */
           uint32_t : 31; // padding
    } T0CAPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CAPINTEN;                      /*!< T0 Capture Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CapIntEn   :  1;               /*!< Capture operation interrupt control 1: Interrupt enable 0: Interrupt
                                                         disable                                                               */
           uint32_t : 31; // padding
    } T0CAPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CAPEN;                         /*!< T0 Capture Enable Register                                            */
    
    struct {
      __IO uint32_t  CapEn      :  1;               /*!< Capture operation control 1: Capture enable 0: Capture disable        */
           uint32_t : 31; // padding
    } T0CAPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;
  
  union {
    __IO uint32_t  T0CAPRELOAD;                     /*!< T0 Capture Reload Register                                            */
    
    struct {
      __IO uint32_t  CapReload  :  1;               /*!< Capture operation reload control. A counter value is reloaded
                                                         to Timer0Load(Timer0BGLoad) due to capture generation. 1: Reloads
                                                          the counter value upon capture generation. 0: Does not reload
                                                          the counter value upon capture generation.                           */
           uint32_t : 31; // padding
    } T0CAPRELOAD_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CAPCTRL;                       /*!< T0 Capture Control Register                                           */
    
    struct {
      __IO uint32_t  CapCtrl0   :  2;               /*!< Selection of capture input operation 0b11: Capture operation
                                                         at both the rising and falling edges 0b10: Capture operation
                                                          at the falling edge 0b01: Capture operation at the rising edge
                                                          0b00: Capture operation with pulse input                             */
           uint32_t : 30; // padding
    } T0CAPCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CAPSYNC;                       /*!< T0 Capture Synchronization Register                                   */
    
    struct {
      __IO uint32_t  CapSync    :  1;               /*!< Capture input synchronization control 0b1: Synchronizes capture
                                                         input (for external input with clock not synchronized) 0b0:
                                                          Does not synchronize capture input (for external input with
                                                          clock synchronized)                                                  */
           uint32_t : 31; // padding
    } T0CAPSYNC_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0BGCOMPARE;                     /*!< T0 BackGround Compare Register                                        */
    
    struct {
      __IO uint32_t  BGCompare  : 16;               /*!< Background compare register that stores a compare value to be
                                                         compared with a count valueA count value set in this register
                                                          is reloaded after the counter becomes 0 (terminal count).The
                                                          count value to be reloaded can be changed safely during counting.(Note)
                                                          Writing to this register does not allow writing to Timer0Compare.    */
      __IO uint32_t  BGLoad     : 16;               /*!< Background load registerThis register is the same as the 0x018
                                                         register. However, it is write-only. It is set in this area
                                                          for DMA transfer. It can be accessed only for TCDMASelx=1.(Note)
                                                          This register appears on the memory map only for TCDMASelx=1.(Note)
                                                          This register can be accessed from either of the CPU and DMAC.(Note)
                                                          If this register is accessed in halfword units, a wrong value
                                                          is written to a register not accessed. So, only access in word
                                                          units is permitted.                                                  */
    } T0BGCOMPARE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[7];
  
  union {
    __IO uint32_t  T0COMPARE;                       /*!< T0 Compare value Register                                             */
    
    struct {
      __IO uint32_t  CmpReg     : 16;               /*!< Stores a compare value to be compared with a count value.(Note)
                                                         This register cannot be read immediately after writing to it
                                                          because a transfer to other clocks (PCLK->TIMCLK) is required.
                                                          Reading after writing is required for up to one cycle of TIMCLK.(Note)
                                                          Writing to the Timer0Compare register writes the same value
                                                          to Timer0BGCompare.                                                  */
           uint32_t : 16; // padding
    } T0COMPARE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[7];
  
  union {
    __IO uint32_t  T0CMPINTCLR;                     /*!< T0 Compare Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CmpIntClr  : 32;               /*!< After a compare interrupt occurs, it can be cleared by write
                                                         access to this register.                                              */
    } T0CMPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[7];
  
  union {
    __I  uint32_t  T0CMPRIS;                        /*!< T0 Compare Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CmpRIS     :  1;               /*!< A compare interrupt before masking (T0CMPINTx) is occurring.
                                                         1: Interrupt request available 0: No interrupt request                */
           uint32_t : 31; // padding
    } T0CMPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0CMPMIS;                        /*!< T0 Compare Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CmpMIS     :  1;               /*!< A compare interrupt after masking (T0CMPINT) is occurring. 1:
                                                         Interrupt request available 0: No interrupt request                   */
           uint32_t : 31; // padding
    } T0CMPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CMPINTEN;                      /*!< T0 Compare Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CmpIntEn   :  1;               /*!< Compare operation interrupt control 1: Interrupt enable 0: Interrupt
                                                         disable                                                               */
           uint32_t : 31; // padding
    } T0CMPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CMPEN;                         /*!< T0 Compare Enable Register                                            */
    
    struct {
      __IO uint32_t  CmpEn      :  1;               /*!< Compare operation control 1: Compare enable 0: Compare disable        */
           uint32_t : 31; // padding
    } T0CMPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[4];
  
  union {
    __IO uint32_t  T1LOAD;                          /*!< T1 Load Register                                                      */
    
    struct {
      __IO uint32_t  Load       : 16;               /*!< Initial or reload value of the counter (0x0001 to 0xFFFF settable)    */
           uint32_t : 16; // padding
    } T1LOAD_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1VALUE;                         /*!< T1 Current value Register                                             */
    
    struct {
      __I  uint32_t  value      : 16;               /*!< Count value of the counter at the current time                        */
           uint32_t : 16; // padding
    } T1VALUE_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CONTROL;                       /*!< T1 Control Register                                                   */
    
    struct {
      __IO uint32_t  Clock_divid:  3;               /*!< Prescaler (clock frequency division)                                  */
      __IO uint32_t  Timer_size :  1;               /*!< Selection of timer bit width                                          */
      __IO uint32_t  One_Shot_Count:  1;            /*!< Selection of timer wrapping and one-shot                              */
      __IO uint32_t  Periodic_Mode:  1;             /*!< Timer operation mode                                                  */
      __IO uint32_t  Interrupt_Enable:  1;          /*!< Interrupt control                                                     */
      __IO uint32_t  Enable     :  1;               /*!< Timer operation control                                               */
      __IO uint32_t  Event_Mode :  2;               /*!< Event counter operation control                                       */
           uint32_t : 22; // padding
    } T1CONTROL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1INTCLR;                        /*!< T1 Interrupt clear Register                                           */
    
    struct {
      __IO uint32_t  IntClr     : 32;               /*!< Interrupt clear                                                       */
    } T1INTCLR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1RIS;                           /*!< T1 Raw Interrupt Status Register                                      */
    
    struct {
      __I  uint32_t  RIS        :  1;               /*!< A timer interrupt before masking (T1TIMINT) is occurring. (The
                                                         interrupt occurs when the counter becomes 0x0000.)                    */
           uint32_t : 31; // padding
    } T1RIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1MIS;                           /*!< T1 Masked Interrupt Status Register                                   */
    
    struct {
      __I  uint32_t  MIS        :  1;               /*!< A timer interrupt after masking (T1TIMINT) is occurring.              */
           uint32_t : 31; // padding
    } T1MIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1BGLOAD;                        /*!< T1 BackGround Load Register                                           */
    
    struct {
      __IO uint32_t  BGLoad     : 16;               /*!< Background Load register                                              */
           uint32_t : 16; // padding
    } T1BGLOAD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1INTCNT;                        /*!< T1 Interrupt Count Register                                           */
    
    struct {
      __IO uint32_t  IntCount   :  8;               /*!< Count value for the number of times it became a terminal count
                                                         of the counter main body                                              */
           uint32_t : 24; // padding
    } T1INTCNT_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1CAPTURE;                       /*!< T1 Capture value Register                                             */
    
    struct {
      __I  uint32_t  CapReg     : 16;               /*!< Stores a count value when the T1CAPREQ signal is input.               */
           uint32_t : 16; // padding
    } T1CAPTURE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7[7];
  
  union {
    __IO uint32_t  T1CAPINTCLR;                     /*!< T1 Capture Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CapIntClr  : 32;               /*!< After a capture interrupt occurs, it can be cleared by write
                                                         access to this register.                                              */
    } T1CAPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8[7];
  
  union {
    __I  uint32_t  T1CAPRIS;                        /*!< T1 Capture Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CapRIS     :  1;               /*!< A capture interrupt before masking (T1CAPINT[x]) is occurring.        */
           uint32_t : 31; // padding
    } T1CAPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1CAPMIS;                        /*!< T1 Capture Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CapMIS     :  1;               /*!< A capture interrupt after masking (T1CAPINTx) is occurring.           */
           uint32_t : 31; // padding
    } T1CAPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CAPINTEN;                      /*!< T1 Capture Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CapIntEn   :  1;               /*!< Capture operation interrupt control                                   */
           uint32_t : 31; // padding
    } T1CAPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CAPEN;                         /*!< T1 Capture Enable Register                                            */
    
    struct {
      __IO uint32_t  CapEn      :  1;               /*!< Capture operation control                                             */
           uint32_t : 31; // padding
    } T1CAPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED9;
  
  union {
    __IO uint32_t  T1CAPRELOAD;                     /*!< T1 Capture Reload Register                                            */
    
    struct {
      __IO uint32_t  CapReload  :  1;               /*!< Capture operation reload control. A counter value is reloaded
                                                         to Timer1Load(Timer1BGLoad) due to capture generation.                */
           uint32_t : 31; // padding
    } T1CAPRELOAD_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CAPCTRL;                       /*!< T1 Capture Control Register                                           */
    
    struct {
      __IO uint32_t  CapCtrl0   :  2;               /*!< Capture input operation selection                                     */
           uint32_t : 30; // padding
    } T1CAPCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CAPSYNC;                       /*!< T1 Capture Synchronization Register                                   */
    
    struct {
      __IO uint32_t  CapSync    :  1;               /*!< Capture input synchronization control                                 */
           uint32_t : 31; // padding
    } T1CAPSYNC_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1BGCOMPARE;                     /*!< T1 BackGround Compare Register                                        */
    
    struct {
      __IO uint32_t  BGCompare  : 16;               /*!< Background compare register. Stores a compare value to be compared
                                                         with a count value.                                                   */
      __IO uint32_t  BGLoad     : 16;               /*!< Background Load register                                              */
    } T1BGCOMPARE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED10[7];
  
  union {
    __IO uint32_t  T1COMPARE;                       /*!< T1 Compare value Register                                             */
    
    struct {
      __IO uint32_t  CmpReg     : 16;               /*!< Stores a compare value to be compared with a count value.             */
           uint32_t : 16; // padding
    } T1COMPARE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED11[7];
  
  union {
    __IO uint32_t  T1CMPINTCLR;                     /*!< T1 Compare Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CmpIntClr  : 32;               /*!< After a compare interrupt occurs, it can be cleared by write
                                                         access to this register.                                              */
    } T1CMPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED12[7];
  
  union {
    __I  uint32_t  T1CMPRIS;                        /*!< T1 Compare Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CmpRIS     :  1;               /*!< A compare interrupt before masking (T1CMPINTx) is occurring.          */
           uint32_t : 31; // padding
    } T1CMPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1CMPMIS;                        /*!< T1 Compare Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CmpMIS     :  1;               /*!< A compare interrupt before masking (T1CMPINT) is occurring.           */
           uint32_t : 31; // padding
    } T1CMPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CMPINTEN;                      /*!< T1 Compare Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CmpIntEn   :  1;               /*!< Compare operation interrupt control                                   */
           uint32_t : 31; // padding
    } T1CMPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CMPEN;                         /*!< T1 Compare Enable Register                                            */
    
    struct {
      __IO uint32_t  CmpEn      :  1;               /*!< Compare operation control                                             */
           uint32_t : 31; // padding
    } T1CMPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED13[4];
  
  union {
    __IO uint32_t  T2LOAD;                          /*!< T2 Load Register                                                      */
    
    struct {
      __IO uint32_t  Load       : 16;               /*!< Initial or reload value of the counter (0x0001 to 0xFFFF settable)
                                                                                                                               */
           uint32_t : 16; // padding
    } T2LOAD_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2VALUE;                         /*!< T2 Current value Register                                             */
    
    struct {
      __I  uint32_t  value      : 16;               /*!< Count value of the counter at the current time                        */
           uint32_t : 16; // padding
    } T2VALUE_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CONTROL;                       /*!< T2 Control Register                                                   */
    
    struct {
      __IO uint32_t  Clock_divid:  3;               /*!< Prescaler (clock frequency division)                                  */
      __IO uint32_t  Timer_size :  1;               /*!< Selection of timer bit width                                          */
      __IO uint32_t  One_Shot_Count:  1;            /*!< Selection of timer wrapping and one-shot                              */
      __IO uint32_t  Periodic_Mode:  1;             /*!< Timer operation mode                                                  */
      __IO uint32_t  Interrupt_Enable:  1;          /*!< Interrupt control                                                     */
      __IO uint32_t  Enable     :  1;               /*!< Timer operation control                                               */
      __IO uint32_t  Event_Mode :  2;               /*!< Event counter operation control                                       */
           uint32_t : 22; // padding
    } T2CONTROL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2INTCLR;                        /*!< T2 Interrupt clear Register                                           */
    
    struct {
      __IO uint32_t  IntClr     : 32;               /*!< Interrupt clear                                                       */
    } T2INTCLR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2RIS;                           /*!< T2 Raw Interrupt Status Register                                      */
    
    struct {
      __I  uint32_t  RIS        :  1;               /*!< A timer interrupt before masking (T2TIMINT) is occurring. (The
                                                         interrupt occurs when the counter becomes 0x0000.)                    */
           uint32_t : 31; // padding
    } T2RIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2MIS;                           /*!< T2 Masked Interrupt Status Register                                   */
    
    struct {
      __I  uint32_t  MIS        :  1;               /*!< A timer interrupt after masking (T2TIMINT) is occurring.              */
           uint32_t : 31; // padding
    } T2MIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2BGLOAD;                        /*!< T2 BackGround Load Register                                           */
    
    struct {
      __IO uint32_t  BGLoad     : 16;               /*!< Background Load register                                              */
           uint32_t : 16; // padding
    } T2BGLOAD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2INTCNT;                        /*!< T2 Interrupt Count Register                                           */
    
    struct {
      __IO uint32_t  IntCount   :  8;               /*!< Count value for the number of times it became a terminal count
                                                         of the counter main body                                              */
           uint32_t : 24; // padding
    } T2INTCNT_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2CAPTURE;                       /*!< T2 Capture value Register                                             */
    
    struct {
      __I  uint32_t  CapReg     : 16;               /*!< Stores a count value when the T2CAPREQ signal is input.               */
           uint32_t : 16; // padding
    } T2CAPTURE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED14[7];
  
  union {
    __IO uint32_t  T2CAPINTCLR;                     /*!< T2 Capture Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CapIntClr  : 32;               /*!< After a capture interrupt occurs, it can be cleared by write
                                                         access to this register.                                              */
    } T2CAPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED15[7];
  
  union {
    __I  uint32_t  T2CAPRIS;                        /*!< T2 Capture Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CapRIS     :  1;               /*!< A capture interrupt before masking (T2CAPINT[x]) is occurring.        */
           uint32_t : 31; // padding
    } T2CAPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2CAPMIS;                        /*!< T2 Capture Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CapMIS     :  1;               /*!< A capture interrupt after masking (T2CAPINTx) is occurring.           */
           uint32_t : 31; // padding
    } T2CAPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CAPINTEN;                      /*!< T2 Capture Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CapIntEn   :  1;               /*!< Capture operation interrupt control                                   */
           uint32_t : 31; // padding
    } T2CAPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CAPEN;                         /*!< T2 Capture Enable Register                                            */
    
    struct {
      __IO uint32_t  CapEn      :  1;               /*!< Capture operation control                                             */
           uint32_t : 31; // padding
    } T2CAPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED16;
  
  union {
    __IO uint32_t  T2CAPRELOAD;                     /*!< T2 Capture Reload Register                                            */
    
    struct {
      __IO uint32_t  CapReload  :  1;               /*!< Capture operation reload control. A counter value is reloaded
                                                         to Timer2Load(Timer2BGLoad) due to capture generation.                */
           uint32_t : 31; // padding
    } T2CAPRELOAD_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CAPCTRL;                       /*!< T2 Capture Control Register                                           */
    
    struct {
      __IO uint32_t  CapCtrl0   :  2;               /*!< Capture input operation selection                                     */
           uint32_t : 30; // padding
    } T2CAPCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CAPSYNC;                       /*!< T2 Capture Synchronization Register                                   */
    
    struct {
      __IO uint32_t  CapSync    :  1;               /*!< Capture input synchronization control                                 */
           uint32_t : 31; // padding
    } T2CAPSYNC_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2BGCOMPARE;                     /*!< T2 BackGround Compare Register                                        */
    
    struct {
      __IO uint32_t  BGCompare  : 16;               /*!< Background compare register. Stores a compare value to be compared
                                                         with a count value.                                                   */
      __IO uint32_t  BGLoad     : 16;               /*!< Background Load register                                              */
    } T2BGCOMPARE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED17[7];
  
  union {
    __IO uint32_t  T2COMPARE;                       /*!< T2 Compare value Register                                             */
    
    struct {
      __IO uint32_t  CmpReg     : 16;               /*!< Stores a compare value to be compared with a count value.             */
           uint32_t : 16; // padding
    } T2COMPARE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED18[7];
  
  union {
    __IO uint32_t  T2CMPINTCLR;                     /*!< T2 Compare Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CmpIntClr  : 32;               /*!< After a compare interrupt occurs, it can be cleared by write
                                                         access to this register.                                              */
    } T2CMPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED19[7];
  
  union {
    __I  uint32_t  T2CMPRIS;                        /*!< T2 Compare Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CmpRIS     :  1;               /*!< A compare interrupt before masking (T2CMPINTx) is occurring.
                                                                                                                               */
           uint32_t : 31; // padding
    } T2CMPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2CMPMIS;                        /*!< T2 Compare Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CmpMIS     :  1;               /*!< A compare interrupt after masking (T2CMPINT) is occurring.            */
           uint32_t : 31; // padding
    } T2CMPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CMPINTEN;                      /*!< T2 Compare Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CmpIntEn   :  1;               /*!< Compare operation interrupt control                                   */
           uint32_t : 31; // padding
    } T2CMPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CMPEN;                         /*!< T2 Compare Enable Register                                            */
    
    struct {
      __IO uint32_t  CmpEn      :  1;               /*!< Compare operation control                                             */
           uint32_t : 31; // padding
    } T2CMPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED20[4];
  
  union {
    __IO uint32_t  T3LOAD;                          /*!< T3 Load Register                                                      */
    
    struct {
      __IO uint32_t  Load       : 16;               /*!< Initial or reload value of the counter (0x0001 to 0xFFFF settable)
                                                                                                                               */
           uint32_t : 16; // padding
    } T3LOAD_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3VALUE;                         /*!< T3 Current value Register                                             */
    
    struct {
      __I  uint32_t  value      : 16;               /*!< Count value of the counter at the current time                        */
           uint32_t : 16; // padding
    } T3VALUE_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CONTROL;                       /*!< T3 Control Register                                                   */
    
    struct {
      __IO uint32_t  Clock_divid:  3;               /*!< Prescaler (clock frequency division)                                  */
      __IO uint32_t  Timer_size :  1;               /*!< Selection of timer bit width                                          */
      __IO uint32_t  One_Shot_Count:  1;            /*!< Selection of timer wrapping and one-shot                              */
      __IO uint32_t  Periodic_Mode:  1;             /*!< Timer operation mode                                                  */
      __IO uint32_t  Interrupt_Enable:  1;          /*!< Interrupt control                                                     */
      __IO uint32_t  Enable     :  1;               /*!< Timer operation control                                               */
      __IO uint32_t  Event_Mode :  2;               /*!< Event counter operation control                                       */
           uint32_t : 22; // padding
    } T3CONTROL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3INTCLR;                        /*!< T3 Interrupt clear Register                                           */
    
    struct {
      __IO uint32_t  IntClr     : 32;               /*!< Interrupt clear                                                       */
    } T3INTCLR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3RIS;                           /*!< T3 Raw Interrupt Status Register                                      */
    
    struct {
      __I  uint32_t  RIS        :  1;               /*!< A timer interrupt before masking (T3TIMINT) is occurring. (The
                                                         interrupt occurs when the counter becomes 0x0000.)                    */
           uint32_t : 31; // padding
    } T3RIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3MIS;                           /*!< T3 Masked Interrupt Status Register                                   */
    
    struct {
      __I  uint32_t  MIS        :  1;               /*!< A timer interrupt after masking (T3TIMINT) is occurring.              */
           uint32_t : 31; // padding
    } T3MIS_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3BGLOAD;                        /*!< T3 BackGround Load Register                                           */
    
    struct {
      __IO uint32_t  BGLoad     : 16;               /*!< Background load register                                              */
           uint32_t : 16; // padding
    } T3BGLOAD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3INTCNT;                        /*!< T3 Interrupt Count Register                                           */
    
    struct {
      __IO uint32_t  IntCount   :  8;               /*!< Count value for the number of times it became a terminal count
                                                         of the counter main body                                              */
           uint32_t : 24; // padding
    } T3INTCNT_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3CAPTURE;                       /*!< T3 Capture value Register                                             */
    
    struct {
      __I  uint32_t  CapReg     : 16;               /*!< Stores a count value when the T3CAPREQ signal is input.               */
           uint32_t : 16; // padding
    } T3CAPTURE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED21[7];
  
  union {
    __IO uint32_t  T3CAPINTCLR;                     /*!< T3 Capture Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CapIntClr  : 32;               /*!< After a capture interrupt occurs, it can be cleared by write
                                                         access to this register.                                              */
    } T3CAPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED22[7];
  
  union {
    __I  uint32_t  T3CAPRIS;                        /*!< T3 Capture Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CapRIS     :  1;               /*!< A capture interrupt before masking (T3CAPINT[x]) is occurring.        */
           uint32_t : 31; // padding
    } T3CAPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3CAPMIS;                        /*!< T3 Capture Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CapMIS     :  1;               /*!< A capture interrupt after masking (T3CAPINTx) is occurring.           */
           uint32_t : 31; // padding
    } T3CAPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CAPINTEN;                      /*!< T3 Capture Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CapIntEn   :  1;               /*!< Capture operation interrupt control                                   */
           uint32_t : 31; // padding
    } T3CAPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CAPEN;                         /*!< T3 Capture Enable Register                                            */
    
    struct {
      __IO uint32_t  CapEn      :  1;               /*!< Capture operation control                                             */
           uint32_t : 31; // padding
    } T3CAPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED23;
  
  union {
    __IO uint32_t  T3CAPRELOAD;                     /*!< T3 Capture Reload Register                                            */
    
    struct {
      __IO uint32_t  CapReload  :  1;               /*!< Capture operation reload control. A counter value is reloaded
                                                         to Timer3Load(Timer3BGLoad) due to capture generation.                */
           uint32_t : 31; // padding
    } T3CAPRELOAD_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CAPCTRL;                       /*!< T3 Capture Control Register                                           */
    
    struct {
      __IO uint32_t  CapCtrl0   :  2;               /*!< Capture input operation selection                                     */
           uint32_t : 30; // padding
    } T3CAPCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CAPSYNC;                       /*!< T3 Capture Synchronization Register                                   */
    
    struct {
      __IO uint32_t  CapSync    :  1;               /*!< Capture input synchronization control                                 */
           uint32_t : 31; // padding
    } T3CAPSYNC_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3BGCOMPARE;                     /*!< T3 BackGround Compare Register                                        */
    
    struct {
      __IO uint32_t  BGCompare  : 16;               /*!< Background compare register. Stores a compare value to be compared
                                                         with a count value.                                                   */
      __IO uint32_t  BGLoad     : 16;               /*!< Background load register                                              */
    } T3BGCOMPARE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED24[7];
  
  union {
    __IO uint32_t  T3COMPARE;                       /*!< T3 Compare value Register                                             */
    
    struct {
      __IO uint32_t  CmpReg     : 16;               /*!< Stores a compare value to be compared with a count value.             */
           uint32_t : 16; // padding
    } T3COMPARE_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED25[7];
  
  union {
    __IO uint32_t  T3CMPINTCLR;                     /*!< T3 Compare Interrupt clear Register                                   */
    
    struct {
      __IO uint32_t  CmpIntClr  : 32;               /*!< After a compare interrupt occurs, it can be cleared by write
                                                         access to this register.                                              */
    } T3CMPINTCLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED26[7];
  
  union {
    __I  uint32_t  T3CMPRIS;                        /*!< T3 Compare Raw Interrupt Status Register                              */
    
    struct {
      __I  uint32_t  CmpRIS     :  1;               /*!< A compare interrupt before masking (T3CMPINTx) is occurring.
                                                                                                                               */
           uint32_t : 31; // padding
    } T3CMPRIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3CMPMIS;                        /*!< T3 Compare Masked Interrupt Status Register                           */
    
    struct {
      __I  uint32_t  CmpMIS     :  1;               /*!< A compare interrupt after masking (T3CMPINT) is occurring.            */
           uint32_t : 31; // padding
    } T3CMPMIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CMPINTEN;                      /*!< T3 Compare Interrupt Enable Register                                  */
    
    struct {
      __IO uint32_t  CmpIntEn   :  1;               /*!< Compare operation interrupt control                                   */
           uint32_t : 31; // padding
    } T3CMPINTEN_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CMPEN;                         /*!< T3 Compare Enable Register                                            */
    
    struct {
      __IO uint32_t  CmpEn      :  1;               /*!< Compare operation control                                             */
           uint32_t : 31; // padding
    } T3CMPEN_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED27[4];
  
  union {
    __IO uint32_t  T0TFFEN;                         /*!< T0 TFF Enable Register                                                */
    
    struct {
      __IO uint32_t  TFFEn      :  1;               /*!< TFF (Toggle Flip-Flop) operation control 1: TFF function enable
                                                         0: TFF function disable (TFF output is fixed at 0.)                   */
           uint32_t : 31; // padding
    } T0TFFEN_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0TFFSTAT;                       /*!< T0 TFF Status Register                                                */
    
    struct {
      __I  uint32_t  TFFStat    :  1;               /*!< TFF (Toggle Flip-Flop) output status (indicating the status
                                                         before the last stage of Timer0TFFInv) 1: High TFF output 0:
                                                          Low TFF output                                                       */
           uint32_t : 31; // padding
    } T0TFFSTAT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0TFFZERO;                       /*!< T0 TFF Zero Register                                                  */
    
    struct {
      __IO uint32_t  TFFZero    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (to select whether
                                                         to toggle TFF at a falling edge when the Timer counter is 0)This
                                                          setting is required for PWM operation. 1: Toggle with Compare
                                                          and Timer counter 0x0000 (terminal count) (the Timer0TFFCtrl
                                                          setting disabled) 0: Toggle only with Compare (the Timer0TFFCtrl
                                                          setting enabled)                                                     */
           uint32_t : 31; // padding
    } T0TFFZERO_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0TFFINV;                        /*!< T0 TFF Invert Register                                                */
    
    struct {
      __IO uint32_t  TFFInv     :  1;               /*!< TFF (Toggle Flip-Flop) operation control (to select whether
                                                         the output is reversed at its last stage) 1: Reverses the TFF
                                                          output at its last stage for output. 0: TFF output without reverse.  */
           uint32_t : 31; // padding
    } T0TFFINV_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0TFFCTRL;                       /*!< T0 TFF Control Register                                               */
    
    struct {
      __IO uint32_t  TFFCtrl    :  2;               /*!< Selection of TFF (Toggle Flip-Flop) output operation 0b11: Pulse
                                                         operation. Compare output becomes TFF output as is. 0b10: Toggle
                                                          operation. TFF output is reversed for the relevant Compare output.
                                                          0b01: Operation for becoming '1'. No change for TFF=1. 0b00:
                                                          Operation for becoming '0'. No change for TFF=0.                     */
           uint32_t : 30; // padding
    } T0TFFCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0TFFINIT;                       /*!< T0 TFF Iniit Register                                                 */
    
    struct {
      __IO uint32_t  TFFInit    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of output
                                                         initial value) 1: Sets the initial value of TFF output to 1.
                                                          0: Sets the initial value of TFF output to 0.                        */
           uint32_t : 31; // padding
    } T0TFFINIT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED28[2];
  
  union {
    __IO uint32_t  T0EVCONTROL;                     /*!< T0 Event Control Register                                             */
    
    struct {
      __IO uint32_t  EventEn    :  1;               /*!< Event counter control 1: Event counter enable 0: Event counter
                                                         disable                                                               */
      __IO uint32_t  EvDelay    :  1;               /*!< Selection of count start delay of the event counter 1: Start
                                                         delay by 1 TIMCLK 0: No start delay                                   */
           uint32_t             :  1;
      __IO uint32_t  EvSync     :  1;               /*!< Selection of event counter input synchronization 1: Synchronized
                                                         0: Not synchronized                                                   */
      __IO uint32_t  Event_Select:  2;              /*!< Event counter operation selection 0b11: EventEn + external terminal
                                                         input (edge) 0b10: EventEn + external terminal input (level)
                                                          0b0*: EventEn bit only                                               */
           uint32_t : 26; // padding
    } T0EVCONTROL_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED29[3];
  
  union {
    __IO uint32_t  T0EVSEL;                         /*!< T0 EV Select Control Register                                         */
    
    struct {
      __IO uint32_t  EVCNTEN_Sel:  3;               /*!< EVCNTEN I/O control Input selection signal: Generation of the
                                                         output level of the T0EVENSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T2TFFOUT 0b101:ADVTMR:T1TFFOUT 0b100:ADVTMR:T3TIMINT(ch3->ch0
                                                          cascade connect) 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2) 0b010:PIN:MCU_I2C
                                                         0_DATA(Pin share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin share=FMOD2)
                                                          , PIN:MCU_GPIO_13(Pin share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_12(Pin share=FMOD3)                      */
           uint32_t             :  1;
      __IO uint32_t  EVCNTSRC_Sel:  3;              /*!< EVCNTSRC I/O control Input selection signal: Generation of the
                                                         output level of the T0EVSRCSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T2TFFOUT 0b101:ADVTMR:T1TFFOUT 0b100:ADVTMR:T3TIMINT(ch3->ch0
                                                          cascade connect) 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2) 0b010:PIN:MCU_I2C
                                                         0_DATA(Pin share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin share=FMOD2)
                                                          , PIN:MCU_GPIO_13(Pin share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_12(Pin share=FMOD3)                      */
           uint32_t : 25; // padding
    } T0EVSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0IOSEL;                         /*!< T0 IO Select Control Register                                         */
    
    struct {
      __IO uint32_t  IOSel      :  1;               /*!< T0TFFOUT I/O control 1: T0TFFOUT output 0: Input from external
                                                         pin or not output                                                     */
           uint32_t : 31; // padding
    } T0IOSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CAPSEL;                        /*!< T0 Capture Select Register                                            */
    
    struct {
      __IO uint32_t  CapSel     :  3;               /*!< Capture input selection Input selection signal: Generates the
                                                         output level of the T0CAPSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T2TFFOUT 0b101:ADVTMR:T1TFFOUT 0b100:EVM:evm_advtimer_capture
                                                         [0] 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2) 0b010:PIN:MCU_I2C0_DATA(Pin
                                                          share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin share=FMOD2) , PIN:MCU_GPIO_13(Pin
                                                          share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin share=FMOD2) , PIN:MCU_GPIO_12(Pin
                                                          share=FMOD3)                                                         */
           uint32_t : 29; // padding
    } T0CAPSEL_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED30[17];
  
  union {
    __IO uint32_t  T0CAPDMAEN;                      /*!< T0 CapDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CapDMAEn   :  1;               /*!< T0CAPDMAREQ control 1: CapDMA request enable 0: CapDMA request
                                                         disable                                                               */
           uint32_t : 31; // padding
    } T0CAPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED31[3];
  
  union {
    __I  uint32_t  T0CAPDMASTAT;                    /*!< T0 CapDMA Status Register                                             */
    
    struct {
      __I  uint32_t  CapDMAStat :  1;               /*!< CapDMA transfer statusAfter start of DMA transfer, status '1'
                                                         continues until T0CAPDMACTC arrives. It changes to '0' after
                                                          T0CAPDMACTC arrives. 1: DMA request in progress 0: No DMA request    */
           uint32_t : 31; // padding
    } T0CAPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED32;
  
  union {
    __IO uint32_t  T0CMPDMASTAT;                    /*!< T0 CmpDMA Status Register                                             */
    
    struct {
      __IO uint32_t  CmpDMAStat :  1;               /*!< CmpDMA transfer statusAfter start of DMA transfer, status '1'
                                                         continues until T0CMPDMACTC arrives. It changes to '0' after
                                                          T0CMPDMACTC arrives. 1: DMA request in progress 0: No DMA request    */
           uint32_t : 31; // padding
    } T0CMPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0TCDMASEL;                      /*!< T0 Terminal Count DMA Request Select Register                         */
    
    struct {
      __IO uint32_t  TCDMASel   :  1;               /*!< Selection of a T0CMPDMAREQ signal request condition 1: Sets
                                                         a T0CMPDMAREQ signal request at terminal count occurrence. 0:
                                                          Sets a T0CMPDMAREQ signal request at compare occurrence.             */
           uint32_t : 31; // padding
    } T0TCDMASEL_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CMPDMAEN;                      /*!< T0 CmpDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CmpDMAEn   :  1;               /*!< T0CMPDMAREQ control 1: CmpDMA request enable 0: CmpDMA request
                                                         disable                                                               */
           uint32_t : 31; // padding
    } T0CMPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED33[5];
  
  union {
    __IO uint32_t  T0CAPDMASYNC;                    /*!< T0 CapDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CapDMASync :  1;               /*!< Synchronization control of T0CAPDMACLR and T0CAPDMATC 1: Synchronizes
                                                         input (for external input with clock not synchronized) 0: Does
                                                          not synchronize input (for external input with clock synchronized)   */
           uint32_t : 31; // padding
    } T0CAPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CMPDMASYNC;                    /*!< T0 CmpDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CmpDMASync :  1;               /*!< Synchronization control of T0CMPDMACLR and T0CMPDMATC 1: Synchronizes
                                                         input (for external input with clock not synchronized) 0: Does
                                                          not synchronize input (for external input with clock synchronized)   */
           uint32_t : 31; // padding
    } T0CMPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED34[12];
  
  union {
    __IO uint32_t  T0CAPDMACLR;                     /*!< T0 CapDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CapDMAClr  :  1;               /*!< Can forcibly clear a generated CapDMA request. 1: Clears the
                                                         DMA request. 0: Does nothing. (The request can be cleared only
                                                          for CAPDMAEN=1.)                                                     */
           uint32_t : 31; // padding
    } T0CAPDMACLR_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T0CMPDMACLR;                     /*!< T0 CmpDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CmpDMAClr  :  1;               /*!< Can forcibly clear a generated CmpDMA request. 1: Clears the
                                                         DMA request. 0: Does nothing. (The request can be cleared only
                                                          for CMPDMAEN=1.)                                                     */
           uint32_t : 31; // padding
    } T0CMPDMACLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED35[2];
  
  union {
    __IO uint32_t  T1TFFEN;                         /*!< T1 TFF Enable Register                                                */
    
    struct {
      __IO uint32_t  TFFEn      :  1;               /*!< TFF (Toggle Flip-Flop) operation control                              */
           uint32_t : 31; // padding
    } T1TFFEN_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1TFFSTAT;                       /*!< T1 TFF Status Register                                                */
    
    struct {
      __I  uint32_t  TFFStat    :  1;               /*!< TFF (Toggle Flip-Flop) output status (indicating the status
                                                         before the last stage of Timer1TFFInv)                                */
           uint32_t : 31; // padding
    } T1TFFSTAT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1TFFZERO;                       /*!< T1 TFF Zero Register                                                  */
    
    struct {
      __IO uint32_t  TFFZero    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of whether
                                                         or not TFF is toggled at the falling edge when the timer counter
                                                          is 0)                                                                */
           uint32_t : 31; // padding
    } T1TFFZERO_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1TFFINV;                        /*!< T1 TFF Invert Register                                                */
    
    struct {
      __IO uint32_t  TFFInv     :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of whether
                                                         or not the output is reversed at its last stage)                      */
           uint32_t : 31; // padding
    } T1TFFINV_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1TFFCTRL;                       /*!< T1 TFF Control Register                                               */
    
    struct {
      __IO uint32_t  TFFCtrl    :  2;               /*!< Selection of TFF (Toggle Flip-Flop) output operation                  */
           uint32_t : 30; // padding
    } T1TFFCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1TFFINIT;                       /*!< T1 TFF Iniit Register                                                 */
    
    struct {
      __IO uint32_t  TFFInit    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of output
                                                         initial value)                                                        */
           uint32_t : 31; // padding
    } T1TFFINIT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED36[2];
  
  union {
    __IO uint32_t  T1EVCONTROL;                     /*!< T1 Event Control Register                                             */
    
    struct {
      __IO uint32_t  EventEn    :  1;               /*!< Event counter control                                                 */
      __IO uint32_t  EvDelay    :  1;               /*!< Selection of event counter count start delay                          */
           uint32_t             :  1;
      __IO uint32_t  EvSync     :  1;               /*!< Selection of event counter input synchronization                      */
      __IO uint32_t  Event_Select:  2;              /*!< Event counter operation selection                                     */
           uint32_t : 26; // padding
    } T1EVCONTROL_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED37[3];
  
  union {
    __IO uint32_t  T1EVSEL;                         /*!< T1 EV Select Control Register                                         */
    
    struct {
      __IO uint32_t  EVCNTEN_Sel:  3;               /*!< EVCNTEN I/O control Input selection signal: Generation of the
                                                         output level of the T1EVENSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T2TFFOUT 0b101:ADVTMR:T0TIMINT(ch0->ch1 cascade
                                                          connect) 0b100:ADVTMR:T0TFFOUT 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2)
                                                          0b010:PIN:MCU_I2C0_DATA(Pin share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_13(Pin share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_12(Pin share=FMOD3)                      */
           uint32_t             :  1;
      __IO uint32_t  EVCNTSRC_Sel:  3;              /*!< EVCNTSRC I/O control Input selection signal: Generation of the
                                                         output level of the T1EVSRCSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T2TFFOUT 0b101:ADVTMR:T0TIMINT(ch0->ch1 cascade
                                                          connect) 0b100:ADVTMR:T0TFFOUT 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2)
                                                          0b010:PIN:MCU_I2C0_DATA(Pin share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_13(Pin share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_12(Pin share=FMOD3)                      */
           uint32_t : 25; // padding
    } T1EVSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1IOSEL;                         /*!< T1 IO Select Control Register                                         */
    
    struct {
      __IO uint32_t  IOSel      :  1;               /*!< T1TFFOUT I/O control 1: T1TFFOUT output 0: Input from external
                                                         pin or not output                                                     */
           uint32_t : 31; // padding
    } T1IOSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CAPSEL;                        /*!< T1 Capture Select Register                                            */
    
    struct {
      __IO uint32_t  CapSel     :  3;               /*!< Capture input selection Input selection signal: Generates the
                                                         output level of the T1CAPSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T2TFFOUT 0b101:EVM:evm_advtimer_capture[1] 0b100:ADVTMR:T0TFF
                                                         OUT 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2) 0b010:PIN:MCU_I2C0_DATA(Pin
                                                          share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin share=FMOD2) , PIN:MCU_GPIO_13(Pin
                                                          share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin share=FMOD2) , PIN:MCU_GPIO_12(Pin
                                                          share=FMOD3)                                                         */
           uint32_t : 29; // padding
    } T1CAPSEL_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED38[17];
  
  union {
    __IO uint32_t  T1CAPDMAEN;                      /*!< T1 CapDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CapDMAEn   :  1;               /*!< T1CAPDMAREQ control                                                   */
           uint32_t : 31; // padding
    } T1CAPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED39[3];
  
  union {
    __I  uint32_t  T1CAPDMASTAT;                    /*!< T1 CapDMA Status Register                                             */
    
    struct {
      __I  uint32_t  CapDMAStat :  1;               /*!< CapDMA transfer status                                                */
           uint32_t : 31; // padding
    } T1CAPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED40;
  
  union {
    __I  uint32_t  T1CMPDMASTAT;                    /*!< T1 CmpDMA Status Register                                             */
    
    struct {
      __I  uint32_t  CmpDMAStat :  1;               /*!< CmpDMA transfer status                                                */
           uint32_t : 31; // padding
    } T1CMPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1TCDMASEL;                      /*!< T1 Terminal Count DMA Request Select Register                         */
    
    struct {
      __IO uint32_t  TCDMASel   :  1;               /*!< Selection of a T1CMPDMAREQ signal request condition                   */
           uint32_t : 31; // padding
    } T1TCDMASEL_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CMPDMAEN;                      /*!< T1 CmpDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CmpDMAEn   :  1;               /*!< T1CMPDMAREQ control                                                   */
           uint32_t : 31; // padding
    } T1CMPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED41[5];
  
  union {
    __IO uint32_t  T1CAPDMASYNC;                    /*!< T1 CapDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CapDMASync :  1;               /*!< Synchronization control of T1CAPDMACLR and T1CAPDMATC inputs          */
           uint32_t : 31; // padding
    } T1CAPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CMPDMASYNC;                    /*!< T1 CmpDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CmpDMASync :  1;               /*!< Synchronization control of T1CMPDMACLR and T1CMPDMATC inputs          */
           uint32_t : 31; // padding
    } T1CMPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED42[12];
  
  union {
    __IO uint32_t  T1CAPDMACLR;                     /*!< T1 CapDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CapDMAClr  :  1;               /*!< Can clear a CapDMA request forcibly.                                  */
           uint32_t : 31; // padding
    } T1CAPDMACLR_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1CMPDMACLR;                     /*!< T1 CmpDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CmpDMAClr  :  1;               /*!< Can clear a CmpDMA request forcibly.                                  */
           uint32_t : 31; // padding
    } T1CMPDMACLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED43[2];
  
  union {
    __IO uint32_t  T2TFFEN;                         /*!< T2 TFF Enable Register                                                */
    
    struct {
      __IO uint32_t  TFFEn      :  1;               /*!< TFF (Toggle Flip-Flop) operation control                              */
           uint32_t : 31; // padding
    } T2TFFEN_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2TFFSTAT;                       /*!< T2 TFF Status Register                                                */
    
    struct {
      __I  uint32_t  TFFStat    :  1;               /*!< TFF (Toggle Flip-Flop) output status (indicating the status
                                                         before the last stage of Timer2TFFInv)                                */
           uint32_t : 31; // padding
    } T2TFFSTAT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2TFFZERO;                       /*!< T2 TFF Zero Register                                                  */
    
    struct {
      __IO uint32_t  TFFZero    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of whether
                                                         or not TFF is toggled at the falling edge when the timer counter
                                                          is 0)                                                                */
           uint32_t : 31; // padding
    } T2TFFZERO_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2TFFINV;                        /*!< T2 TFF Invert Register                                                */
    
    struct {
      __IO uint32_t  TFFInv     :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of whether
                                                         or not the output is reversed at its last stage)                      */
           uint32_t : 31; // padding
    } T2TFFINV_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2TFFCTRL;                       /*!< T2 TFF Control Register                                               */
    
    struct {
      __IO uint32_t  TFFCtrl    :  2;               /*!< Selection of TFF (Toggle Flip-Flop) output operation                  */
           uint32_t : 30; // padding
    } T2TFFCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2TFFINIT;                       /*!< T2 TFF Iniit Register                                                 */
    
    struct {
      __IO uint32_t  TFFInit    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of output
                                                         initial value)                                                        */
           uint32_t : 31; // padding
    } T2TFFINIT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED44[2];
  
  union {
    __IO uint32_t  T2EVCONTROL;                     /*!< T2 Event Control Register                                             */
    
    struct {
      __IO uint32_t  EventEn    :  1;               /*!< Event counter control                                                 */
      __IO uint32_t  EvDelay    :  1;               /*!< Selection of event counter count start delay                          */
           uint32_t             :  1;
      __IO uint32_t  EvSync     :  1;               /*!< Selection of event counter input synchronization                      */
      __IO uint32_t  Event_Select:  2;              /*!< Event counter operation selection                                     */
           uint32_t : 26; // padding
    } T2EVCONTROL_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED45[3];
  
  union {
    __IO uint32_t  T2EVSEL;                         /*!< T2 EV Select Control Register                                         */
    
    struct {
      __IO uint32_t  EVCNTEN_Sel:  3;               /*!< EVCNTEN I/O control Input selection signal: Generation of the
                                                         output level of the T2EVENSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T1TIMINT(ch1->ch2 cascade connect) 0b101:ADVTMR:T1TFFOUT
                                                          0b100:ADVTMR:T0TFFOUT 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2)
                                                          0b010:PIN:MCU_I2C0_DATA(Pin share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_13(Pin share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_12(Pin share=FMOD3)                      */
           uint32_t             :  1;
      __IO uint32_t  EVCNTSRC_Sel:  3;              /*!< EVCNTSRC I/O control Input selection signal: Generation of the
                                                         output level of the T2EVSRCSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T1TIMINT(ch1->ch2 cascade connect) 0b101:ADVTMR:T1TFFOUT
                                                          0b100:ADVTMR:T0TFFOUT 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2)
                                                          0b010:PIN:MCU_I2C0_DATA(Pin share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_13(Pin share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_12(Pin share=FMOD3)                      */
           uint32_t : 25; // padding
    } T2EVSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2IOSEL;                         /*!< T2 IO Select Control Register                                         */
    
    struct {
      __IO uint32_t  IOSel      :  1;               /*!< T2TFFOUT I/O control 1: T2TFFOUT output 0: Input from external
                                                         pin or not output                                                     */
           uint32_t : 31; // padding
    } T2IOSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CAPSEL;                        /*!< T2 Capture Select Register                                            */
    
    struct {
      __IO uint32_t  CapSel     :  3;               /*!< Capture input selection Input selection signal: Generates the
                                                         output level of the T2CAPSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:EVM:evm_advtimer_capture[2] 0b101:ADVTMR:T1TFFOUT 0b100:ADVTMR:T0TFF
                                                         OUT 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2) 0b010:PIN:MCU_I2C0_DATA(Pin
                                                          share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin share=FMOD2) , PIN:MCU_GPIO_13(Pin
                                                          share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin share=FMOD2) , PIN:MCU_GPIO_12(Pin
                                                          share=FMOD3)                                                         */
           uint32_t : 29; // padding
    } T2CAPSEL_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED46[17];
  
  union {
    __IO uint32_t  T2CAPDMAEN;                      /*!< T2 CapDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CapDMAEn   :  1;               /*!< T2CAPDMAREQ control                                                   */
           uint32_t : 31; // padding
    } T2CAPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED47[3];
  
  union {
    __I  uint32_t  T2CAPDMASTAT;                    /*!< T2 CapDMA Status Register                                             */
    
    struct {
      __I  uint32_t  CapDMAStat :  1;               /*!< CapDMA transfer status                                                */
           uint32_t : 31; // padding
    } T2CAPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED48;
  
  union {
    __I  uint32_t  T2CMPDMASTAT;                    /*!< T2 CmpDMA Status Register                                             */
    
    struct {
      __I  uint32_t  CmpDMAStat :  1;               /*!< CmpDMA transfer status                                                */
           uint32_t : 31; // padding
    } T2CMPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2TCDMASEL;                      /*!< T2 Terminal Count DMA Request Select Register                         */
    
    struct {
      __IO uint32_t  TCDMASel   :  1;               /*!< Selection of a T2CMPDMAREQ signal request condition                   */
           uint32_t : 31; // padding
    } T2TCDMASEL_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CMPDMAEN;                      /*!< T2 CmpDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CmpDMAEn   :  1;               /*!< T2CMPDMAREQ control                                                   */
           uint32_t : 31; // padding
    } T2CMPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED49[5];
  
  union {
    __IO uint32_t  T2CAPDMASYNC;                    /*!< T2 CapDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CapDMASync :  1;               /*!< Synchronization control of T2CAPDMACLR and T2CAPDMATC inputs          */
           uint32_t : 31; // padding
    } T2CAPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CMPDMASYNC;                    /*!< T2 CmpDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CmpDMASync :  1;               /*!< Synchronization control of T2CMPDMACLR and T2CMPDMATC inputs          */
           uint32_t : 31; // padding
    } T2CMPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED50[12];
  
  union {
    __IO uint32_t  T2CAPDMACLR;                     /*!< T2 CapDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CapDMAClr  :  1;               /*!< Can clear a CapDMA request forcibly.                                  */
           uint32_t : 31; // padding
    } T2CAPDMACLR_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2CMPDMACLR;                     /*!< T2 CmpDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CmpDMAClr  :  1;               /*!< Can clear a CmpDMA request forcibly.                                  */
           uint32_t : 31; // padding
    } T2CMPDMACLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED51[2];
  
  union {
    __IO uint32_t  T3TFFEN;                         /*!< T3 TFF Enable Register                                                */
    
    struct {
      __IO uint32_t  TFFEn      :  1;               /*!< TFF (Toggle Flip-Flop) operation control                              */
           uint32_t : 31; // padding
    } T3TFFEN_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3TFFSTAT;                       /*!< T3 TFF Status Register                                                */
    
    struct {
      __I  uint32_t  TFFStat    :  1;               /*!< TFF (Toggle Flip-Flop) output status (indicating the status
                                                         before the last stage of Timer3TFFInv)                                */
           uint32_t : 31; // padding
    } T3TFFSTAT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3TFFZERO;                       /*!< T3 TFF Zero Register                                                  */
    
    struct {
      __IO uint32_t  TFFZero    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of whether
                                                         or not TFF is toggled at the falling edge when the timer counter
                                                          is 0)                                                                */
           uint32_t : 31; // padding
    } T3TFFZERO_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3TFFINV;                        /*!< T3 TFF Invert Register                                                */
    
    struct {
      __IO uint32_t  TFFInv     :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of whether
                                                         or not the output is reversed at its last stage)                      */
           uint32_t : 31; // padding
    } T3TFFINV_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3TFFCTRL;                       /*!< T3 TFF Control Register                                               */
    
    struct {
      __IO uint32_t  TFFCtrl    :  2;               /*!< Selection of TFF (Toggle Flip-Flop) output operation                  */
           uint32_t : 30; // padding
    } T3TFFCTRL_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3TFFINIT;                       /*!< T3 TFF Iniit Register                                                 */
    
    struct {
      __IO uint32_t  TFFInit    :  1;               /*!< TFF (Toggle Flip-Flop) operation control (selection of output
                                                         initial value)                                                        */
           uint32_t : 31; // padding
    } T3TFFINIT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED52[2];
  
  union {
    __IO uint32_t  T3EVCONTROL;                     /*!< T3 Event Control Register                                             */
    
    struct {
      __IO uint32_t  EventEn    :  1;               /*!< Event counter control                                                 */
      __IO uint32_t  EvDelay    :  1;               /*!< Selection of event counter count start delay                          */
           uint32_t             :  1;
      __IO uint32_t  EvSync     :  1;               /*!< Selection of event counter input synchronization                      */
      __IO uint32_t  Event_Select:  2;              /*!< Event counter operation selection                                     */
           uint32_t : 26; // padding
    } T3EVCONTROL_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED53[3];
  
  union {
    __IO uint32_t  T3EVSEL;                         /*!< T3 EV Select Control Register                                         */
    
    struct {
      __IO uint32_t  EVCNTEN_Sel:  3;               /*!< EVCNTEN I/O control Input selection signal: Generation of the
                                                         output level of the T3EVENSEL signals. 0b111:ADVTMR:T3TFFOUT
                                                          0b110:ADVTMR:T2TFFOUT 0b101:ADVTMR:T1TFFOUT 0b100:ADVTMR:T0TFFOUT
                                                          0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2) 0b010:PIN:MCU_I2C0_DATA(Pin
                                                          share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin share=FMOD2) , PIN:MCU_GPIO_13(Pin
                                                          share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin share=FMOD2) , PIN:MCU_GPIO_12(Pin
                                                          share=FMOD3)                                                         */
           uint32_t             :  1;
      __IO uint32_t  EVCNTSRC_Sel:  3;              /*!< EVCNTSRC I/O control Input selection signal: Generation of the
                                                         output level of the T3EVSRCSEL signals. 0b111:ADVTMR:T2TIMINT(ch2->ch3
                                                          cascade connect) 0b110:ADVTMR:T2TFFOUT 0b101:ADVTMR:T1TFFOUT
                                                          0b100:ADVTMR:T0TFFOUT 0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2)
                                                          0b010:PIN:MCU_I2C0_DATA(Pin share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_13(Pin share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin
                                                          share=FMOD2) , PIN:MCU_GPIO_12(Pin share=FMOD3)                      */
           uint32_t : 25; // padding
    } T3EVSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3IOSEL;                         /*!< T3 IO Select Control Register                                         */
    
    struct {
      __IO uint32_t  IOSel      :  1;               /*!< T3TFFOUT I/O control                                                  */
           uint32_t : 31; // padding
    } T3IOSEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CAPSEL;                        /*!< T3 Capture Select Register                                            */
    
    struct {
      __IO uint32_t  CapSel     :  3;               /*!< Capture input selection Input selection signal: Generates the
                                                         output level of the T3CAPSEL signals. 0b111:EVM:evm_advtimer_capture[3]
                                                          0b110:ADVTMR:T3TFFOUT 0b101:ADVTMR:T1TFFOUT 0b100:ADVTMR:T0TFFOUT
                                                          0b011:PIN:MCU_I2C0_CLK(Pin share=FMOD2) 0b010:PIN:MCU_I2C0_DATA(Pin
                                                          share=FMOD2) 0b001:PIN:MCU_UA0_TXD(Pin share=FMOD2) , PIN:MCU_GPIO_13(Pin
                                                          share=FMOD3) 0b000:PIN:MCU_UA0_RXD(Pin share=FMOD2) , PIN:MCU_GPIO_12(Pin
                                                          share=FMOD3)                                                         */
           uint32_t : 29; // padding
    } T3CAPSEL_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED54[17];
  
  union {
    __IO uint32_t  T3CAPDMAEN;                      /*!< T3 CapDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CapDMAEn   :  1;               /*!< T3CAPDMAREQ control 1: T3TFFOUT output 0: Input from external
                                                         pin or not output                                                     */
           uint32_t : 31; // padding
    } T3CAPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED55[3];
  
  union {
    __I  uint32_t  T3CAPDMASTAT;                    /*!< T3 CapDMA Status Register                                             */
    
    struct {
      __I  uint32_t  CapDMAStat :  1;               /*!< CapDMA transfer status                                                */
           uint32_t : 31; // padding
    } T3CAPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED56;
  
  union {
    __I  uint32_t  T3CMPDMASTAT;                    /*!< T3 CmpDMA Status Register                                             */
    
    struct {
      __I  uint32_t  CmpDMAStat :  1;               /*!< CmpDMA transfer status                                                */
           uint32_t : 31; // padding
    } T3CMPDMASTAT_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3TCDMASEL;                      /*!< T3 Terminal Count DMA Request Select Register                         */
    
    struct {
      __IO uint32_t  TCDMASel   :  1;               /*!< Selection of a T3CMPDMAREQ signal request condition                   */
           uint32_t : 31; // padding
    } T3TCDMASEL_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CMPDMAEN;                      /*!< T3 CmpDMA Enable Register                                             */
    
    struct {
      __IO uint32_t  CmpDMAEn   :  1;               /*!< T3CMPDMAREQ control                                                   */
           uint32_t : 31; // padding
    } T3CMPDMAEN_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED57[5];
  
  union {
    __IO uint32_t  T3CAPDMASYNC;                    /*!< T3 CapDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CapDMASync :  1;               /*!< Synchronization control of T3CAPDMACLR and T3CAPDMATC inputs          */
           uint32_t : 31; // padding
    } T3CAPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CMPDMASYNC;                    /*!< T3 CmpDMAC signals Synchronization Register                           */
    
    struct {
      __IO uint32_t  CmpDMASync :  1;               /*!< Synchronization control of T3CMPDMACLR and T3CMPDMATC inputs          */
           uint32_t : 31; // padding
    } T3CMPDMASYNC_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED58[12];
  
  union {
    __IO uint32_t  T3CAPDMACLR;                     /*!< T3 CapDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CapDMAClr  :  1;               /*!< Can clear a CapDMA request forcibly.                                  */
           uint32_t : 31; // padding
    } T3CAPDMACLR_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3CMPDMACLR;                     /*!< T3 CmpDMA clear Register                                              */
    
    struct {
      __IO uint32_t  CmpDMAClr  :  1;               /*!< Can clear a CmpDMA request forcibly.                                  */
           uint32_t : 31; // padding
    } T3CMPDMACLR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED59[450];
  
  union {
    __IO uint32_t  TITCR;                           /*!< Timer Integration test control Register                               */
    
    struct {
      __IO uint32_t  Test_Mode_Enable:  1;          /*!< Test mode control 1: Test mode status 0: Normal operation status      */
           uint32_t : 31; // padding
    } TITCR_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TITOP;                           /*!< Timer Integration test output set Register                            */
    
    struct {
      __IO uint32_t  TestT0TIMINT:  1;              /*!< T0TIMINT signal output (only in test mode) 1: T0TIMINT='1' 0:
                                                         T0TIMINT='0'                                                          */
      __IO uint32_t  TestT1TIMINT:  1;              /*!< T1TIMINT signal output (only in test mode) 1: T1TIMINT='1' 0:
                                                         T1TIMINT='0'                                                          */
      __IO uint32_t  TestT2TIMINT:  1;              /*!< T2TIMINT signal output (only in test mode) 1: T2TIMINT='1' 0:
                                                         T2TIMINT='0'                                                          */
      __IO uint32_t  TestT3TIMINT:  1;              /*!< T3TIMINT signal output (only in test mode) 1: T3TIMINT='1' 0:
                                                         T3TIMINT='0'                                                          */
           uint32_t : 28; // padding
    } TITOP_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED60[2];
  
  union {
    __IO uint32_t  TOTSYNC;                         /*!< Timer Other Timer Synchronization Register                            */
    
    struct {
      __IO uint32_t  OTSync     :  8;               /*!< Controls TIMCLKEN of other timers.The timer that can be controlled
                                                         depends on connection. To establish synchronization with multiple
                                                          timers, OTSYNC[x] output from this timer should be connected
                                                          to TxTIMCLKEN of each timer. TxTIMCLKEN of this timer should
                                                          be connected to OTSYNC[x]. Each timer should have the same setting
                                                          value. The timer can be synchronously operated by writing 1
                                                          to connected OTSYNC[x:x] at the same time. (The following shows
                                                          a connection of TZ1000.) OTSYNC[0]-->ADVTMR:T0TIMCLKEN OTSYNC[1]-    */
           uint32_t : 24; // padding
    } TOTSYNC_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED61[3];
  
  union {
    __IO uint32_t  T0ITCMPCAPINT;                   /*!< T0 ITCompare_Capture Interrupt set Register                           */
    
    struct {
      __IO uint32_t  TestT0CAPINT:  1;              /*!< T0CAPINT output control 1: T0CAMPINT='1' 0: T0CAPINT='0'              */
           uint32_t             :  7;
      __IO uint32_t  TestT0CMPINT:  1;              /*!< T0CMPINT output control 1: T0CMPINT='1' 0: T0CMPINT='0'               */
           uint32_t : 23; // padding
    } T0ITCMPCAPINT_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1ITCMPCAPINT;                   /*!< T1 ITCompare_Capture Interrupt set Register                           */
    
    struct {
      __IO uint32_t  TestT1CAPINT:  1;              /*!< T1CAPINT output control 1: T1CAPINT='1' 0: T1CAPINT='0'               */
           uint32_t             :  7;
      __IO uint32_t  TestT1CMPINT:  1;              /*!< T1CMPINT output control 1: T1CMPINT='1' 0: T1CMPINT='0'               */
           uint32_t : 23; // padding
    } T1ITCMPCAPINT_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2ITCMPCAPINT;                   /*!< T2 ITCompare_Capture Interrupt set Register                           */
    
    struct {
      __IO uint32_t  TestT2CAPINT:  1;              /*!< T2CAPINT output control 1: T2CAPINT='1' 0: T2CAPINT='0'               */
           uint32_t             :  7;
      __IO uint32_t  TestT2CMPINT:  1;              /*!< T2CMPINT output control 1: T2CMPINT='1' 0: T2CMPINT='0'               */
           uint32_t : 23; // padding
    } T2ITCMPCAPINT_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3ITCMPCAPINT;                   /*!< T3 ITCompare_Capture Interrupt set Register                           */
    
    struct {
      __IO uint32_t  TestT3CAPINT:  1;              /*!< T3CAPINT output control 1: T3CAPINT='1' 0: T3CAPINT='0'               */
           uint32_t             :  7;
      __IO uint32_t  TestT3CMPINT:  1;              /*!< T3CMPINT output control 1: T3CMPINT='1' 0: T3CMPINT='0'               */
           uint32_t : 23; // padding
    } T3ITCMPCAPINT_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED62[4];
  
  union {
    __I  uint32_t  T0ITEVCNT;                       /*!< T0 ITEVCNT Input Register                                             */
    
    struct {
      __I  uint32_t  Test_T0EVCNTEN:  1;            /*!< T0EVCNTEN input status 1: T0EVCNTEN='1' 0: T0EVCNTEN='0'              */
      __I  uint32_t  Test_T0EVCNTSRC:  1;           /*!< T0EVCNTSRC input status 1: T0EVCNTSRC='1' 0: T0EVCNTSRC='0'           */
           uint32_t : 30; // padding
    } T0ITEVCNT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1ITEVCNT;                       /*!< T1 ITEVCNT Input Register                                             */
    
    struct {
      __I  uint32_t  Test_T1EVCNTEN:  1;            /*!< T1EVCNTEN input status 1: T1EVCNTEN='1' 0: T1EVCNTEN='0'              */
      __I  uint32_t  Test_T1EVCNTSRC:  1;           /*!< T1EVCNTSRC input status 1: T1EVCNTSRC='1' 0: T1EVCNTSRC='0'           */
           uint32_t : 30; // padding
    } T1ITEVCNT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2ITEVCNT;                       /*!< T2 ITEVCNT Input Register                                             */
    
    struct {
      __I  uint32_t  Test_T2EVCNTEN:  1;            /*!< T2EVCNTEN input status 1: T2EVCNTEN='1' 0: T2EVCNTEN='0'              */
      __I  uint32_t  Test_T2EVCNTSRC:  1;           /*!< T2EVCNTSRC input status 1: T2EVCNTSRC='1' 0: T2EVCNTSRC='0'           */
           uint32_t : 30; // padding
    } T2ITEVCNT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3ITEVCNT;                       /*!< T3 ITEVCNT Input Register                                             */
    
    struct {
      __I  uint32_t  Test_T3EVCNTEN:  1;            /*!< T3EVCNTEN input status 1: T3EVCNTEN='1' 0: T3EVCNTEN='0'              */
      __I  uint32_t  Test_T3EVCNTSRC:  1;           /*!< T3EVCNTSRC input status 1: T3EVCNTSRC='1' 0: T3EVCNTSRC='0'           */
           uint32_t : 30; // padding
    } T3ITEVCNT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED63[4];
  
  union {
    __IO uint32_t  T0ITCAPDRQCAPRQ;                 /*!< T0 ITCAPDMAREQ_CAPREQ Register                                        */
    
    struct {
      __I  uint32_t  TestT0CAPREQ:  1;              /*!< T0CAPREQ input status 1: T0CAPREQ='1' 0: T0CAPREQ='0'                 */
           uint32_t             :  7;
      __IO uint32_t  TestT0CAPDREQ:  1;             /*!< T0CAPDREQ output control 1: T0CAPDMAREQ='1' 0: T0CAPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T0ITCAPDRQCAPRQ_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0ITCAPDTCDCLR;                  /*!< T0 ITCAPDMATC_CAPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT0CAPDCLR:  1;             /*!< T0CAPDCLR input status 1: T0CAPDMACLR='1' 0: T0CAPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT0CAPDTC:  1;              /*!< T0CAPDTC input status 1: T0CAPDMATC='1' 0: T0CAPDMATC='0'             */
           uint32_t : 23; // padding
    } T0ITCAPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1ITCAPDRQCAPRQ;                 /*!< T1 ITCAPDMAREQ_CAPREQ Register                                        */
    
    struct {
      __I  uint32_t  TestT1CAPREQ:  1;              /*!< T1CAPREQ input status 1: T1CAPREQ='1' 0: T1CAPREQ='0'                 */
           uint32_t             :  7;
      __IO uint32_t  TestT1CAPDREQ:  1;             /*!< T1CAPDREQ output control 1: T1CAPDMAREQ='1' 0: T1CAPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T1ITCAPDRQCAPRQ_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1ITCAPDTCDCLR;                  /*!< T1 ITCAPDMATC_CAPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT1CAPDCLR:  1;             /*!< T1CAPDCLR input status 1: T1CAPDMACLR='1' 0: T1CAPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT1CAPDTC:  1;              /*!< T1CAPDTC input status 1: T1CAPDMATC='1' 0: T1CAPDMATC='0'             */
           uint32_t : 23; // padding
    } T1ITCAPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2ITCAPDRQCAPRQ;                 /*!< T2 ITCAPDMAREQ_CAPREQ Register                                        */
    
    struct {
      __I  uint32_t  TestT2CAPREQ:  1;              /*!< T2CAPREQ input status 1: T2CAPREQ='1' 0: T2CAPREQ='0'                 */
           uint32_t             :  7;
      __IO uint32_t  TestT2CAPDREQ:  1;             /*!< T2CAPDREQ output control 1: T2CAPDMAREQ='1' 0: T2CAPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T2ITCAPDRQCAPRQ_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2ITCAPDTCDCLR;                  /*!< T2 ITCAPDMATC_CAPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT2CAPDCLR:  1;             /*!< T2CAPDCLR input status 1: T2CAPDMACLR='1' 0: T2CAPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT2CAPDTC:  1;              /*!< T2CAPDTC input status 1: T2CAPDMATC='1' 0: T2CAPDMATC='0'             */
           uint32_t : 23; // padding
    } T2ITCAPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3ITCAPDRQCAPRQ;                 /*!< T3 ITCAPDMAREQ_CAPREQ Register                                        */
    
    struct {
      __I  uint32_t  TestT3CAPREQ:  1;              /*!< T3CAPREQ input status 1: T3CAPREQ='1' 0: T3CAPREQ='0'                 */
           uint32_t             :  7;
      __IO uint32_t  TestT3CAPDREQ:  1;             /*!< T3CAPDREQ output control 1: T3CAPDMAREQ='1' 0: T3CAPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T3ITCAPDRQCAPRQ_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3ITCAPDTCDCLR;                  /*!< T3 ITCAPDMATC_CAPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT3CAPDCLR:  1;             /*!< T3CAPDCLR input status 1: T3CAPDMACLR='1' 0: T3CAPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT3CAPDTC:  1;              /*!< T3CAPDTC input status 1: T3CAPDMATC='1' 0: T3CAPDMATC='0'             */
           uint32_t : 23; // padding
    } T3ITCAPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED64[8];
  
  union {
    __IO uint32_t  T0ITCMPDRQTFF;                   /*!< T0 ITCMPDMAREQ_TFFOUT Register                                        */
    
    struct {
      __IO uint32_t  TestT0TFFOUT:  1;              /*!< T0TFFOUT output control 1: T0TFFOUT='1' 0: T0TFFOUT='0'               */
           uint32_t             :  7;
      __IO uint32_t  TestT0CMPDREQ:  1;             /*!< T0CMPDREQ output control 1: T0CMPDMAREQ='1' 0: T0CMPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T0ITCMPDRQTFF_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T0ITCMPDTCDCLR;                  /*!< T0 ITCMPDMATC_CMPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT0CMPDCLR:  1;             /*!< T0CMPDCLR input status 1: T0CMPDMACLR='1' 0: T0CMPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT0CMPDTC:  1;              /*!< T0CMPDTC input status 1: T0CMPDMATC='1' 0: T0CMPDMATC='0'             */
           uint32_t : 23; // padding
    } T0ITCMPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T1ITCMPDRQTFF;                   /*!< T1 ITCMPDMAREQ_TFFOUT Register                                        */
    
    struct {
      __IO uint32_t  TestT1TFFOUT:  1;              /*!< T1TFFOUT output control 1: T1TFFOUT='1' 0: T1TFFOUT='0'               */
           uint32_t             :  7;
      __IO uint32_t  TestT1CMPDREQ:  1;             /*!< T1CMPDREQ output control 1: T1CMPDMAREQ='1' 0: T1CMPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T1ITCMPDRQTFF_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T1ITCMPDTCDCLR;                  /*!< T1 ITCMPDMATC_CMPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT1CMPDCLR:  1;             /*!< T1CMPDCLR input status 1: T1CMPDMACLR='1' 0: T1CMPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT1CMPDTC:  1;              /*!< T1CMPDTC input status 1: T1CMPDMATC='1' 0: T1CMPDMATC='0'             */
           uint32_t : 23; // padding
    } T1ITCMPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T2ITCMPDRQTFF;                   /*!< T2 ITCMPDMAREQ_TFFOUT Register                                        */
    
    struct {
      __IO uint32_t  TestT2TFFOUT:  1;              /*!< T2TFFOUT output control 1: T2TFFOUT='1' 0: T2TFFOUT='0'               */
           uint32_t             :  7;
      __IO uint32_t  TestT2CMPDREQ:  1;             /*!< T2CMPDREQ output control 1: T2CMPDMAREQ='1' 0: T2CMPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T2ITCMPDRQTFF_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T2ITCMPDTCDCLR;                  /*!< T2 ITCMPDMATC_CMPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT2CMPDCLR:  1;             /*!< T2CMPDCLR input status 1: T2CMPDMACLR='1' 0: T2CMPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT2CMPDTC:  1;              /*!< T2CMPDTC input status 1: T2CMPDMATC='1' 0: T2CMPDMATC='0'             */
           uint32_t : 23; // padding
    } T2ITCMPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  T3ITCMPDRQTFF;                   /*!< T3 ITCMPDMAREQ_TFFOUT Register                                        */
    
    struct {
      __IO uint32_t  TestT3TFFOUT:  1;              /*!< T3TFFOUT output control 1: T3TFFOUT='1' 0: T3TFFOUT='0'               */
           uint32_t             :  7;
      __IO uint32_t  TestT3CMPDREQ:  1;             /*!< T3CMPDREQ output control 1: T3CMPDMAREQ='1' 0: T3CMPDMAREQ='0'        */
           uint32_t : 23; // padding
    } T3ITCMPDRQTFF_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  T3ITCMPDTCDCLR;                  /*!< T3 ITCMPDMATC_CMPDMACLR Register                                      */
    
    struct {
      __I  uint32_t  TestT3CMPDCLR:  1;             /*!< T3CMPDCLR input status 1: T3CMPDMACLR='1' 0: T3CMPDMACLR='0'          */
           uint32_t             :  7;
      __I  uint32_t  TestT3CMPDTC:  1;              /*!< T3CMPDTC input status 1: T3CMPDMATC='1' 0: T3CMPDMATC='0'             */
           uint32_t : 23; // padding
    } T3ITCMPDTCDCLR_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED65[8];
  
  union {
    __I  uint32_t  TPERIPHID0;                      /*!< Timer Peripheral ID0 Register                                         */
    
    struct {
      __I  uint32_t  Partnumber0:  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Lower) SP804=>04                                */
           uint32_t : 24; // padding
    } TPERIPHID0_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TPERIPHID1;                      /*!< Timer Peripheral ID1 Register                                         */
    
    struct {
      __I  uint32_t  Partnumber1:  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Lower) SP804=>8                                 */
      __I  uint32_t  Designer0  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Lower) 54=>4                                      */
           uint32_t : 24; // padding
    } TPERIPHID1_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TPERIPHID2;                      /*!< Timer Peripheral ID2 Register                                         */
    
    struct {
      __I  uint32_t  Designer1  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Upper) 54=>5                                      */
      __I  uint32_t  Revision_number:  4;           /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Revision: 2nd=>2                                           */
           uint32_t : 24; // padding
    } TPERIPHID2_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TPERIPHID3;                      /*!< Timer Peripheral ID3 Register                                         */
    
    struct {
      __I  uint32_t  Configuration: 16;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Configuration: ba6 => 0216                                 */
           uint32_t : 16; // padding
    } TPERIPHID3_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TPCELLID0;                       /*!< Timer PrimeCell ID0 Register                                          */
    
    struct {
      __I  uint32_t  ADVTMR_TPCellID0:  8;          /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TPCELLID0_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TPCELLID1;                       /*!< Timer PrimeCell ID1 Register                                          */
    
    struct {
      __I  uint32_t  ADVTMR_TPCellID1:  8;          /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TPCELLID1_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TPCELLID2;                       /*!< Timer PrimeCell ID2 Register                                          */
    
    struct {
      __I  uint32_t  ADVTMR_TPCellID2:  8;          /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TPCELLID2_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TPCELLID3;                       /*!< Timer PrimeCell ID3 Register                                          */
    
    struct {
      __I  uint32_t  TimerPCellID3:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TPCELLID3_b;                                  /*!< BitSize                                                               */
  };
} advtmr_Type;


/* ================================================================================ */
/* ================                       tmr                      ================ */
/* ================================================================================ */


/**
  * @brief tmr (tmr)
  */

typedef struct {                                    /*!< tmr Structure                                                         */
  
  union {
    __IO uint32_t  TIMER0LOAD;                      /*!< Timer0 Load Register                                                  */
    
    struct {
      __IO uint32_t  Load       : 32;               /*!< Initial or reload value of the counter (0x00000001 to 0xFFFFFFFF
                                                         settable)The 0x00000000 setting does not operate the counter.
                                                          Setting any numeric value other than that enables counting.(Note)
                                                          Writing to this register writes the same value to Timer0BGLoad.      */
    } TIMER0LOAD_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMER0VALUE;                     /*!< Timer0 Current value Register                                         */
    
    struct {
      __I  uint32_t  value      : 32;               /*!< Count value of the counter at the current time                        */
    } TIMER0VALUE_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TIMER0CONTROL;                   /*!< Timer0 Control Register                                               */
    
    struct {
      __IO uint32_t  One_Shot_Count:  1;            /*!< Timer wrapping/one-shot selection 1: One-shot (only one time)
                                                         0: Wrapping (repetition)                                              */
      __IO uint32_t  Timer_size :  1;               /*!< Timer size selection 0x1: Operation as a 32-bit timer 0x0: Operation
                                                         as a 16-bit timer (high-order bits not used)                          */
      __IO uint32_t  Clock_divid:  2;               /*!< Prescaler (clock frequency division) 0x3: Reserved 0x2: 1/256
                                                         frequency division 0x1: 1/16 frequency division 0x0: No frequency
                                                          division (same magnification)                                        */
           uint32_t             :  1;
      __IO uint32_t  Interrupt_Enable:  1;          /*!< Interrupt control 1: Interrupt enable 0: Interrupt disable            */
      __IO uint32_t  Periodic_Mode:  1;             /*!< Timer operation mode 1: Periodic Timer (periodic timer) 0: Free-run
                                                         Timer (free-run timer)                                                */
      __IO uint32_t  Enable     :  1;               /*!< Timer operation control 1: Enable 0: Disable                          */
           uint32_t : 24; // padding
    } TIMER0CONTROL_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TIMER0INTCLR;                    /*!< Timer0 Interrupt clear Register                                       */
    
    struct {
      __IO uint32_t  IntClr     : 32;               /*!< Interrupt clearAfter the TIMINT0 interrupt occurs, it can be
                                                         cleared by write access to this register.                             */
    } TIMER0INTCLR_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMER0RIS;                       /*!< Timer0 Raw Interrupt Status Register                                  */
    
    struct {
      __I  uint32_t  RIS        :  1;               /*!< A timer interrupt (TIMINT0) before masking is occurring. (The
                                                         interrupt occurs when the counter becomes 0x00000000.) 1: Interrupt
                                                          request available 0: No interrupt request                            */
           uint32_t : 31; // padding
    } TIMER0RIS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMER0MIS;                       /*!< Timer0 Masked Interrupt Status Register                               */
    
    struct {
      __I  uint32_t  MIS        :  1;               /*!< A timer interrupt (TIMINT0) after masking is occurring. 1: Interrupt
                                                         request available 0: No interrupt request                             */
           uint32_t : 31; // padding
    } TIMER0MIS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TIMER0BGLOAD;                    /*!< Timer0 BackGround Load Register                                       */
    
    struct {
      __IO uint32_t  BGLoad     : 32;               /*!< Background Load registerA count value set in this register is
                                                         reloaded after the counter becomes 0x00000000 (terminal count).The
                                                          count value to be reloaded can be changed safely during counting.(Note)
                                                          Writing to this register does not allow writing to Timer0Load.       */
    } TIMER0BGLOAD_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;
  
  union {
    __IO uint32_t  TIMER1LOAD;                      /*!< Timer1 Load Register                                                  */
    
    struct {
      __IO uint32_t  Load       : 32;               /*!< Initial or reload value of the counter                                */
    } TIMER1LOAD_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMER1VALUE;                     /*!< Timer1 Current value Register                                         */
    
    struct {
      __I  uint32_t  value      : 32;               /*!< Count value of the counter at the current time                        */
    } TIMER1VALUE_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TIMER1CONTROL;                   /*!< Timer1 Control Register                                               */
    
    struct {
      __IO uint32_t  One_Shot_Count:  1;            /*!< Selection of timer wrapping and one-shot                              */
      __IO uint32_t  Timer_size :  1;               /*!< Timer size selection                                                  */
      __IO uint32_t  Clock_divid:  2;               /*!< Prescaler (clock frequency division)                                  */
           uint32_t             :  1;
      __IO uint32_t  Interrupt_Enable:  1;          /*!< Interrupt control                                                     */
      __IO uint32_t  Periodic_Mode:  1;             /*!< Timer operation mode                                                  */
      __IO uint32_t  Enable     :  1;               /*!< Timer operation control                                               */
           uint32_t : 24; // padding
    } TIMER1CONTROL_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TIMER1INTCLR;                    /*!< Timer1 Interrupt clear Register                                       */
    
    struct {
      __IO uint32_t  IntClr     : 32;               /*!< Interrupt clear                                                       */
    } TIMER1INTCLR_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMER1RIS;                       /*!< Timer1 Raw Interrupt Status Register                                  */
    
    struct {
      __I  uint32_t  RIS        :  1;               /*!< A timer interrupt (TIMINT1) after masking is occurring. (The
                                                         interrupt occurs when the counter becomes 0x00000000.)                */
           uint32_t : 31; // padding
    } TIMER1RIS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMER1MIS;                       /*!< Timer1 Masked Interrupt Status Register                               */
    
    struct {
      __I  uint32_t  MIS        :  1;               /*!< A timer interrupt (TIMINT1) after masking is occurring.               */
           uint32_t : 31; // padding
    } TIMER1MIS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TIMER1BGLOAD;                    /*!< Timer1 BackGround Load Register                                       */
    
    struct {
      __IO uint32_t  BGLoad     : 32;               /*!< Background load register                                              */
    } TIMER1BGLOAD_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[945];
  
  union {
    __IO uint32_t  TIMERITCR;                       /*!< Timer Integration test control Register                               */
    
    struct {
      __IO uint32_t  Test_Mode_Enable:  1;          /*!< Test mode control 1: Test mode status 0: Normal operation status      */
           uint32_t : 31; // padding
    } TIMERITCR_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TIMERITOP;                       /*!< Timer Integration test output set Register                            */
    
    struct {
      __IO uint32_t  TestTIMINT0:  1;               /*!< Outputs the TIMINT0 signal (only in test mode, write-only) 1:
                                                         TIMINT0='1' 0: TIMINT0='0'If this register is read, the TMR_TIMERITCR
                                                          value appears.                                                       */
      __IO uint32_t  TestTIMINT1:  1;               /*!< Outputs the TIMINT1 signal (only in test mode, write-only) 1:
                                                         TIMINT1='1' 0: TIMINT1='0'If this register is read, the TMR_TIMERITCR
                                                          value appears.                                                       */
           uint32_t : 30; // padding
    } TIMERITOP_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[54];
  
  union {
    __I  uint32_t  TIMERPERIPHID0;                  /*!< Timer Peripheral ID0 Register                                         */
    
    struct {
      __I  uint32_t  Partnumber0:  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Lower) 804=>04                                  */
           uint32_t : 24; // padding
    } TIMERPERIPHID0_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMERPERIPHID1;                  /*!< Timer Peripheral ID1 Register                                         */
    
    struct {
      __I  uint32_t  Partnumber1:  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Lower) 804=>8                                   */
      __I  uint32_t  Designer0  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Lower) 41=>1                                      */
           uint32_t : 24; // padding
    } TIMERPERIPHID1_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMERPERIPHID2;                  /*!< Timer Peripheral ID2 Register                                         */
    
    struct {
      __I  uint32_t  Designer1  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Upper) 41=>4                                      */
      __I  uint32_t  Revision_number:  4;           /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Revision: 1st=>1                                           */
           uint32_t : 24; // padding
    } TIMERPERIPHID2_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMERPERIPHID3;                  /*!< Timer Peripheral ID3 Register                                         */
    
    struct {
      __I  uint32_t  Configuration:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Configuration: 00                                          */
           uint32_t : 24; // padding
    } TIMERPERIPHID3_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMERPCELLID0;                   /*!< Timer PrimeCell ID0 Register                                          */
    
    struct {
      __I  uint32_t  TimerPCellID0:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TIMERPCELLID0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMERPCELLID1;                   /*!< Timer PrimeCell ID1 Register                                          */
    
    struct {
      __I  uint32_t  TimerPCellID1:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TIMERPCELLID1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMERPCELLID2;                   /*!< Timer PrimeCell ID2 Register                                          */
    
    struct {
      __I  uint32_t  TimerPCellID2:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TIMERPCELLID2_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TIMERPCELLID3;                   /*!< Timer PrimeCell ID3 Register                                          */
    
    struct {
      __I  uint32_t  TimerPCellID3:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } TIMERPCELLID3_b;                              /*!< BitSize                                                               */
  };
} tmr_Type;


/* ================================================================================ */
/* ================                       wdt                      ================ */
/* ================================================================================ */


/**
  * @brief wdt (wdt)
  */

typedef struct {                                    /*!< wdt Structure                                                         */
  
  union {
    __IO uint32_t  WDOGLOAD;                        /*!< Wdog Watchdog load Register                                           */
    
    struct {
      __IO uint32_t  Load       : 32;               /*!< Value to be loaded to the Wdog counter (min 0x0000_0001)For
                                                         the 0x00000000 setting, the counter does not operate. Setting
                                                          other numeric values enable counting.                                */
    } WDOGLOAD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGVALUE;                       /*!< Wdog The current value for the watchdog counter Register              */
    
    struct {
      __I  uint32_t  Value      : 32;               /*!< Counter value of the Wdog counter at the current time                 */
    } WDOGVALUE_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  WDOGCONTROL;                     /*!< Wdog Control Register                                                 */
    
    struct {
      __IO uint32_t  INTEN      :  1;               /*!< Wdog interrupt enable0b1: Enable0b0: Disable(Note) For the generation
                                                         timing of WDOGRES and Wdog interrupts, the Wdog interrupt first
                                                          occurs and then the WDOGRES interrupt occurs when the value
                                                          of the Wdog counter becomes 0 again with the interrupt not cleared.  */
      __IO uint32_t  RESEN      :  1;               /*!< WDOGRES output enable0b1: Enable0b0: Disable                          */
           uint32_t : 30; // padding
    } WDOGCONTROL_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  WDOGINTCLR;                      /*!< Wdog Interrupt clear Register                                         */
    
    struct {
      __IO uint32_t  IntClr     : 32;               /*!< Interrupt clearAfter the Wdog interrupt occurs, it can be cleared
                                                         by write access to this register.                                     */
    } WDOGINTCLR_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGRIS;                         /*!< Wdog Raw Interrupt Status Register                                    */
    
    struct {
      __I  uint32_t  RIS        :  1;               /*!< Wdog interrupt before masking is occurring.0b1: Interrupt request
                                                         available0b0: No interrupt request                                    */
           uint32_t : 31; // padding
    } WDOGRIS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGMIS;                         /*!< Wdog Masked Interrupt Status Register                                 */
    
    struct {
      __I  uint32_t  MIS        :  1;               /*!< Wdog interrupt after masking is occurring.0b1: Interrupt request
                                                         available0b0: No interrupt request                                    */
           uint32_t : 31; // padding
    } WDOGMIS_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[762];
  
  union {
    __IO uint32_t  WDOGLOCK;                        /*!< Wdog Lock Register                                                    */
    
    struct {
      __IO uint32_t  WLOCK      :  1;               /*!< Register writing disable control<Write>If 0x1ACCE551 is written
                                                         in this register, register writing is enabled.If any value other
                                                          than 0x1ACCE551 is written, register writing is disabled.<Read>Register
                                                          writing disable status0b1: Writing disable0b0: Writing enable        */
           uint32_t : 31; // padding
    } WDOGLOCK_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[191];
  
  union {
    __IO uint32_t  WDOGITCR;                        /*!< Timer Integration test control Register                               */
    
    struct {
      __IO uint32_t  ITEN       :  1;               /*!< Test mode control0b1: Test mode0b0: Normal operation                  */
           uint32_t : 31; // padding
    } WDOGITCR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  WDOGITOP;                        /*!< Timer Integration test output set Register                            */
    
    struct {
      __IO uint32_t  TestWDOGRES:  1;               /*!< Outputs the WDOGRES signal (only in test mode, write-only)0b1:
                                                         WDOGRES='1'0b0: WDOGRES='0'If this register is read, the WDT_WDOGITCR
                                                          value appears.                                                       */
      __IO uint32_t  TestWDOGINT:  1;               /*!< Outputs the WDOGINT signal (only in test mode, write-only)0b1:
                                                         WDOGINT='1'0b0: WDOGINT='0'If this register is read, the WDT_WDOGITCR
                                                          value appears.                                                       */
           uint32_t : 30; // padding
    } WDOGITOP_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[54];
  
  union {
    __I  uint32_t  WDOGPERIPHID0;                   /*!< Wdog Peripheral ID0 Register                                          */
    
    struct {
      __I  uint32_t  Partnumber0:  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Lower) 804=>04                                  */
           uint32_t : 24; // padding
    } WDOGPERIPHID0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGPERIPHID1;                   /*!< Wdog Peripheral ID1 Register                                          */
    
    struct {
      __I  uint32_t  Partnumber1:  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Lower) 805=>8                                   */
      __I  uint32_t  Designer0  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Lower) 41=>1                                      */
           uint32_t : 24; // padding
    } WDOGPERIPHID1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGPERIPHID2;                   /*!< Wdog Peripheral ID2 Register                                          */
    
    struct {
      __I  uint32_t  Designer1  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Upper) 41=>4                                      */
      __I  uint32_t  Revision_number:  4;           /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Revision: 1st=>1                                           */
           uint32_t : 24; // padding
    } WDOGPERIPHID2_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGPERIPHID3;                   /*!< Wdog Peripheral ID3 Register                                          */
    
    struct {
      __I  uint32_t  Configuration:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Configuration: 00                                          */
           uint32_t : 24; // padding
    } WDOGPERIPHID3_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGPCELLID0;                    /*!< Wdog PrimeCell ID0 Register                                           */
    
    struct {
      __I  uint32_t  PCellID0   :  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } WDOGPCELLID0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGPCELLID1;                    /*!< Wdog PrimeCell ID1 Register                                           */
    
    struct {
      __I  uint32_t  PCellID1   :  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } WDOGPCELLID1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGPCELLID2;                    /*!< Wdog PrimeCell ID2 Register                                           */
    
    struct {
      __I  uint32_t  PCellID2   :  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } WDOGPCELLID2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  WDOGPCELLID3;                    /*!< Wdog PrimeCell ID3 Register                                           */
    
    struct {
      __I  uint32_t  PCellID3   :  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)                                                           */
           uint32_t : 24; // padding
    } WDOGPCELLID3_b;                               /*!< BitSize                                                               */
  };
} wdt_Type;


/* ================================================================================ */
/* ================                      i2c2                      ================ */
/* ================================================================================ */


/**
  * @brief i2c2 (i2c2)
  */

typedef struct {                                    /*!< i2c2 Structure                                                        */
  
  union {
    __IO uint32_t  IC_CON;                          /*!< I2C Control Register                                                  */
    
    struct {
      __IO uint32_t  MASTER_MODE:  1;               /*!< This bit controls whether the I2C master is enabled. 0: master
                                                         disabled 1: master enabledNOTE: Software should ensure that
                                                          if this bit is written with 1,then bit 6 should also be written
                                                          with a 1.                                                            */
      __IO uint32_t  SPEED      :  2;               /*!< These bits control at which speed the I2C operates; its setting
                                                         is relevant only if one is operating the I2C in master mode.
                                                          Hardware protects against illegal values being programmed by
                                                          software. This register should be programmed only with a value
                                                          in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware
                                                          updates this register with the value of IC_MAX_SPEED_MODE.-
                                                          1: standard mode (0 to 100 kbit/s)- 2: fast mode (less than
                                                          or equal to 400 kbit/s)- 3: high speed mode (less than or equal
                                                          to 3.4 Mbit/s)                                                       */
      __IO uint32_t  IC_10BITADDR_SLAVE:  1;        /*!< When acting as a slave, this bit controls whether the I2C responds
                                                         to 7- or 10-bit addresses. 0: 7-bit addressing.The I2C ignores
                                                          transactions that involve 10-bit addressing; for 7-bit addressing,
                                                          only the lower 7 bitsof the IC_SAR register are compared. 1:
                                                          10-bit addressing.The I2C responds to only 10-bit addressing
                                                          transfers that match the full 10 bits of the IC_SAR register.        */
      __I  uint32_t  IC_10BITADDR_MASTER:  1;       /*!< the function of this bit is handled by bit 12 of IC_TAR register,
                                                         and becomes a read-only copy called IC_10BITADDR_MASTER_rd_only.
                                                          0: 7-bit addressing 1: 10-bit addressing                             */
      __IO uint32_t  IC_RESTART_EN:  1;             /*!< Determines whether RESTART conditionsmay be sent when acting
                                                         as a master.Some older slaves do not support handling RESTART
                                                          conditions; however, RESTART conditions are used in several
                                                          I2C operations. 0: disable 1: enableWhen the RESTART is disabled,
                                                          the I2C master is incapable of performing the following functions:-
                                                          Sending a START BYTE- Performing any high-speed mode operation-
                                                          Performing direction changes in combined format mode- Performing
                                                          a read operation with a 10-bit addressBy replacing RESTART condit    */
      __IO uint32_t  IC_SLAVE_DISABLE:  1;          /*!< This bit controls whether I2C has its slave disabledwhich means
                                                         once the presetn signal is applied, then this bit takes on the
                                                          value of the configuration parameter IC_SLAVE_DISABLE. You have
                                                          the choice of having the slave enabled or disabled after reset
                                                          is applied, which means software does not have to configure
                                                          the slave. By default, the slave is always enabled (in reset
                                                          state as well). If you need to disable it after reset, set this
                                                          bit to 1. If this bit is set (slave is disabled), I2C functions
                                                          only as                                                              */
      __IO uint32_t  STOP_DET_IFADDRESSED:  1;      /*!< In slave mode: 1: issues the STOP_DET interrrupt only when it
                                                         is addressed. 0: issues the STOP_DET irrespective of whether
                                                          its addressed or not. Dependencies: This register bit value
                                                          is applicable in the slave mode only (MASTER_MODE = 1b0) Reset
                                                          value: 0x0 NOTE: During a general call address, this slave does
                                                          not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED =
                                                          1b1, even if the slave responds to the general call address
                                                          by generating ACK. The STOP_DET interrupt is generated only
                                                          when the transmitted                                                 */
      __IO uint32_t  TX_EMPTY_CTRL:  1;             /*!< This bit controls the generation of the TX_EMPTY interrupt,
                                                         as described in the IC_RAW_INTR_STAT register.                        */
           uint32_t : 23; // padding
    } IC_CON_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_TAR;                          /*!< I2C Target Address Register                                           */
    
    struct {
      __IO uint32_t  IC_TAR     : 10;               /*!< This is the target address for any master transaction.When transmitting
                                                         a General Call, these bits are ignored. To generate a START
                                                          BYTE, the CPU needs to write only once into these bits.If the
                                                          IC_TAR and IC_SAR are the same, loopback exists but the FIFOs
                                                          are shared between master and slave, so full loopback is not
                                                          feasible. Only one direction loopback mode is supported (simplex),
                                                          not duplex. A master cannot transmit to itself; it can transmit
                                                          to only a slave.                                                     */
      __IO uint32_t  GC_OR_START:  1;               /*!< If bit 11 (SPECIAL) is set to 1, then this bit indicates whether
                                                         a General Call or START byte command is to be performed by the
                                                          I2C.- 0: General Call Address - after issuing a General Call,
                                                          only writes may be performed. Attempting to issue a read command
                                                          results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register.
                                                          The I2C remains in General Call mode until the SPECIAL bit value
                                                          (bit 11) is cleared.- 1: START BYTE                                  */
      __IO uint32_t  SPECIAL    :  1;               /*!< This bit indicates whether software performs a General Call
                                                         or START BYTE command.- 0: ignore bit 10 GC_OR_START and use
                                                          IC_TAR normally- 1: perform special I2C command as specified
                                                          in GC_OR_START bit                                                   */
      __IO uint32_t  IC_10BITADDR_MASTER:  1;       /*!< This bit controls whether I2C starts its transfers in 7-or 10-bit
                                                         addressing mode when acting as a master- 0: 7-bit addressing-
                                                          1: 10-bit addressing                                                 */
           uint32_t : 19; // padding
    } IC_TAR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_SAR;                          /*!< I2C Slave Address Register                                            */
    
    struct {
      __IO uint32_t  IC_SAR     : 10;               /*!< The IC_SAR holds the slave address when the I2C is operating
                                                         as a slave.For 7-bit addressing, only IC_SAR[6:0] is used.This
                                                          register can be written only when the I2C interface is disabled,
                                                          which corresponds to IC_ENABLE[0] being set to 0. Writes at
                                                          other times have no effect.Note The default values cannot be
                                                          any of the reserved address locations:that is, 0x00 to 0x07,
                                                          or 0x78 to 0x7f. The correct operation of the device is not
                                                          guaranteed if you program the IC_SAR or IC_TAR to a reserved
                                                          value.                                                               */
           uint32_t : 22; // padding
    } IC_SAR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;
  
  union {
    __IO uint32_t  IC_DATA_CMD;                     /*!< I2C Rx/Tx Data Buffer and Command Register                            */
    
    struct {
      __IO uint32_t  DAT        :  8;               /*!< This register contains the data to be transmitted or received
                                                         on the I2C bus. If you are writing to this register and want
                                                          to perform a read, bits 7:0 (DAT) are ignored by the I2C. However,
                                                          when you read this register, these bits return the value of
                                                          data received on the I2C interface.                                  */
      __IO uint32_t  CMD        :  1;               /*!< This bit controls whether a read or a write is performed. This
                                                         bit does not control the direction when the I2C acts as a slave.
                                                          It controls only the direction when it acts as a master.- 1
                                                          = Read- 0 = WriteWhen a command is entered in the TX FIFO, this
                                                          bit distinguishes the write and read commands. In slave-receiver
                                                          mode, this bit is a 'dont care' because writes to this register
                                                          are not required. In slave-transmitter mode, a '0' indicates
                                                          that the data in IC_DATA_CMD is to be transmitted.When programming
                                                          th                                                                   */
      __IO uint32_t  STOP       :  1;               /*!< This bit controls whether a STOP is issued after the byte is
                                                         sent or received. This bit is available only if IC_EMPTYFIFO_HOLD_MASTER_E
                                                         N is configured to 1.- 1 - STOP is issued after this byte, regardless
                                                          of whether or not the Tx FIFO is empty. If the Tx FIFO is not
                                                          empty, the master immediately tries to start a new transfer
                                                          by issuing a START and arbitrating for the bus.- 0 - STOP is
                                                          not issued after this byte, regardless of whether or not the
                                                          Tx FIFO is empty. If the Tx FIFO is not empty, the master cont       */
      __IO uint32_t  RESTART    :  1;               /*!< This bit controls whether a RESTART is issued before the byte
                                                         is sent or received. This bit is available only if IC_EMPTYFIFO_HOLD_MASTE
                                                         R_EN is configured to 1.- 1 - If IC_RESTART_EN is 1, a RESTART
                                                          is issued before the data is sent/received (according to the
                                                          value of CMD), regardless of whether or not the transfer direction
                                                          is changing from the previous command; if IC_RESTART_EN is 0,
                                                          a STOP followed by a START is issued instead.- 0 - If IC_RESTART_EN
                                                          is 1, a RESTART is issued only if the transfer directi               */
           uint32_t : 21; // padding
    } IC_DATA_CMD_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_SS_SCL_HCNT;                  /*!< Standard Speed I2C Clock SCL High Count Register                      */
    
    struct {
      __IO uint32_t  IC_SS_SCL_HCNT: 16;            /*!< This register must be set before any I2C bus transaction can
                                                         take place to ensure proper I/O timing. This register sets the
                                                          SCL clock high-period count for standard speed.This register
                                                          can be written only when the I2C interface is disabled which
                                                          corresponds to IC_ENABLE[0] being set to 0. Writes at other
                                                          times have no effect.The minimum valid value is 6; hardware
                                                          prevents values less than this being written, and if attempted
                                                          results in 6 being set. For designs with APB_DATA_WIDTH = 8,
                                                          the order of programm                                                */
           uint32_t : 16; // padding
    } IC_SS_SCL_HCNT_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_SS_SCL_LCNT;                  /*!< Standard Speed I2C Clock SCL Low Count Register                       */
    
    struct {
      __IO uint32_t  IC_SS_SCL_LCNT: 16;            /*!< This register must be set before any I2C bus transaction can
                                                         take place to ensure proper I/O timing. This register sets the
                                                          SCL clock low period count for standard speed.This register
                                                          can be written only when the I2C interface is disabled which
                                                          corresponds to IC_ENABLE[0] being set to 0. Writes at other
                                                          times have no effect.The minimum valid value is 8; hardware
                                                          prevents values less than this being written, and if attempted,
                                                          results in 8 being set. For designs with APB_DATA_WIDTH = 8,
                                                          the order of programm                                                */
           uint32_t : 16; // padding
    } IC_SS_SCL_LCNT_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_FS_SCL_HCNT;                  /*!< Fast Speed I2C Clock SCL High Count Register                          */
    
    struct {
      __IO uint32_t  IC_FS_SCL_HCNT: 16;            /*!< This register must be set before any I2C bus transaction can
                                                         take place to ensure proper I/O timing. This register sets the
                                                          SCL clock high-period count for fast speed. It is used in high-speed
                                                          mode to send the Master Code and START BYTE or General CALL.This
                                                          register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE
                                                          = standard. This register can be written only when the I2C interface
                                                          is disabled, which corresponds to IC_ENABLE[0] being set to
                                                          0. Writes at other times have no effect.The minim                    */
           uint32_t : 16; // padding
    } IC_FS_SCL_HCNT_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_FS_SCL_LCNT;                  /*!< Fast Speed I2C Clock SCL Low Count Register                           */
    
    struct {
      __IO uint32_t  IC_FS_SCL_LCNT: 16;            /*!< This register must be set before any I2C bus transaction can
                                                         take place toensure proper I/O timing. This register sets the
                                                          SCL clock low period count for fast speed. It is used in high-speed
                                                          mode to send the Master Code and START BYTE or General CALL.This
                                                          register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE
                                                          = standard.This register can be written only when the I2C interface
                                                          is disabled, which corresponds to IC_ENABLE[0] being set to
                                                          0. Writes at other times have no effect.The minimum                  */
           uint32_t : 16; // padding
    } IC_FS_SCL_LCNT_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[2];
  
  union {
    __I  uint32_t  IC_INTR_STAT;                    /*!< I2C Interrupt Status Register                                         */
    
    struct {
      __I  uint32_t  R_RX_UNDER :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_RX_OVER  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_RX_FULL  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_TX_OVER  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_TX_EMPTY :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_RD_REQ   :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_TX_ABRT  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_RX_DONE  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_ACTIVITY :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_STOP_DET :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_START_DET:  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_GEN_CALL :  1;               /*!< Each bit in this register has a corresponding mask bit in the
                                                         IC_INTR_MASK register.See 'IC_RAW_INTR_STAT'.                         */
      __I  uint32_t  R_RESTART_DET:  1;             /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __I  uint32_t  R_MASTER_ON_HOLD:  1;          /*!< See 'IC_RAW_INTR_STAT'.                                               */
           uint32_t : 18; // padding
    } IC_INTR_STAT_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_INTR_MASK;                    /*!< I2C Interrupt Mask Register                                           */
    
    struct {
      __IO uint32_t  M_RX_UNDER :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_RX_OVER  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_RX_FULL  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_TX_OVER  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_TX_EMPTY :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_RD_REQ   :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_TX_ABRT  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_RX_DONE  :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_ACTIVITY :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_STOP_DET :  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_START_DET:  1;               /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_GEN_CALL :  1;               /*!< These bits mask their corresponding interrupt status bits. This
                                                         register is active low; a value of 0 masks the interrupt, whereas
                                                          a value of 1 unmasks the interrupt.See 'IC_RAW_INTR_STAT'.           */
      __I  uint32_t  M_RESTART_DET:  1;             /*!< See 'IC_RAW_INTR_STAT'.                                               */
      __IO uint32_t  M_MASTER_ON_HOLD:  1;          /*!< See 'IC_RAW_INTR_STAT'.                                               */
           uint32_t : 18; // padding
    } IC_INTR_MASK_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_RAW_INTR_STAT;                /*!< I2C Raw Interrupt Status Register                                     */
    
    struct {
      __I  uint32_t  RX_UNDER   :  1;               /*!< Set if the processor attempts to read the receive buffer when
                                                         it is empty by reading from the IC_DATA_CMD register. If the
                                                          module is disabled (IC_ENABLE[0]=0), this bit keeps its level
                                                          until the master or slave state machines go into idle, and when
                                                          ic_en goes to 0, this interrupt is cleared.                          */
      __I  uint32_t  RX_OVER    :  1;               /*!< Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH
                                                         and an additional byte is received from an external I2C device.
                                                          The I2C acknowledges this, but any data bytes received after
                                                          the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0),
                                                          this bit keeps its level until the master or slave state machines
                                                          go into idle, and when ic_en goes to 0, this interrupt is cleared.   */
      __I  uint32_t  RX_FULL    :  1;               /*!< Set when the receive buffer reaches or goes above the RX_TL
                                                         threshold in the IC_RX_TL register.It is automatically cleared
                                                          by hardware when buffer level goes below the threshold. If the
                                                          module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed
                                                          and held in reset; therefore the RX FIFO is not full. So this
                                                          bit is cleared once the IC_ENABLE bit 0 is programmed with a
                                                          0, regardless of the activity that continues.                        */
      __I  uint32_t  TX_OVER    :  1;               /*!< Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH
                                                         and the processor attempts to issue another I2C command by writing
                                                          to the IC_DATA_CMD register.When the module is disabled, this
                                                          bit keeps its level until the master or slave state machines
                                                          go into idle, and when ic_en goes to 0, this interrupt is cleared.
                                                                                                                               */
      __I  uint32_t  TX_EMPTY   :  1;               /*!< This bit is set to 1 when the transmit buffer is at or below
                                                         the threshold value set in the IC_TX_TL register.It is automatically
                                                          cleared by hardware when the buffer level goes above the threshold.
                                                          When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held
                                                          in reset. There the TX FIFO looks like it has no data within
                                                          it, so this bit is set to 1, provided there is activity in the
                                                          master or slave state machines. When there is no longer activity,
                                                          then with ic_en=0, this bit is set to 0.                             */
      __I  uint32_t  RD_REQ     :  1;               /*!< This bit is set to 1 when I2C is acting as a slave and another
                                                         I2C master is attempting to read data from I2C.The I2C holds
                                                          the I2C bus in a wait state (SCL=0) until this interrupt is
                                                          serviced, which means that the slave has been addressed by a
                                                          remote master that is asking for data to be transferred. The
                                                          processor must respond to this interrupt and then write the
                                                          requested data to the IC_DATA_CMD register. This bit is set
                                                          to 0 just after the processor reads the IC_CLR_RD_REQ register.      */
      __I  uint32_t  TX_ABRT    :  1;               /*!< This bit indicates if I2C, as an I2C transmitter, is unable
                                                         to complete the intended actions on the contents of the transmit
                                                          FIFO.This situation can occur both as an I2C master or an I2C
                                                          slave, and is referred to as a transmit abort. When this bit
                                                          is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason
                                                          why the transmit abort takes places.NOTE: The I2C flushes/resets/empties
                                                          the TX FIFO whenever this bit is set. The TX FIFO remains in
                                                          this flushed state until the register IC_CLR_TX_ABRT is read.
                                                          On                                                                   */
      __I  uint32_t  RX_DONE    :  1;               /*!< When the I2C is acting as a slave-transmitter, this bit is set
                                                         to 1 if the master does not acknowledge a transmitted byte.
                                                          This occurs on the last byte of the transmission, indicating
                                                          that the transmission is done.                                       */
      __I  uint32_t  ACTIVITY   :  1;               /*!< This bit captures I2C activity and stays set until it is clearedcleared.
                                                         There are four ways to clear it:- Disabling the I2C- Reading
                                                          the IC_CLR_ACTIVITY register- Reading the IC_CLR_INTR register-
                                                          System resetOnce this bit is set, it stays set unless one of
                                                          the four methods is used to clear it. Even if the I2C module
                                                          is idle, this bit remains set until cleared, indicating that
                                                          there was activity on the bus.                                       */
      __I  uint32_t  STOP_DET   :  1;               /*!< Indicates whether a STOP condition has occurred on the I2C interface
                                                         regardless of whether I2C is operating in slave or master mode.       */
      __I  uint32_t  START_DET  :  1;               /*!< Indicates whether a START or RESTART condition has occurred
                                                         on the I2C interface regardless of whether I2C is operating
                                                          in slave or master mode.                                             */
      __I  uint32_t  GEN_CALL   :  1;               /*!< Set only when a General Call address is received and it is acknowledged.It
                                                         stays set until it is cleared either by disabling I2C or when
                                                          the CPU reads bit 0 of the IC_CLR_GEN_CALL register. I2C stores
                                                          the received data in the Rx buffer.                                  */
      __I  uint32_t  RESTART_DET:  1;               /*!< Indicates whether a RESTART condition has occurred on the I2C
                                                         interface when I2C is operating in Slave mode and the slave
                                                          is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.
                                                          (Note:Following are exceptions where the Restart interrupt will
                                                          not get generated. In the case of High speed Mode or Startbyte
                                                          transfer, where the Restart comes before the Address field as
                                                          per the I2C protocol defined format, the Slave is still not
                                                          in the addressed mode and hence will not generate the RESTART_DET
                                                          interrupt.)                                                          */
      __I  uint32_t  MASTER_ON_HOLD:  1;            /*!< Indicates whether master is holding the bus and TX FIFO is empty.
                                                         Enabled only when I2C_DYNAMIC_TAR_UPDATE=1 and IC_EMPTYFIFO_HOLD_MASTER_EN
                                                         =1.                                                                   */
           uint32_t : 18; // padding
    } IC_RAW_INTR_STAT_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_RX_TL;                        /*!< I2C Receive FIFO Threshold Register                                   */
    
    struct {
      __IO uint32_t  RX_TL      :  8;               /*!< Receive FIFO Threshold LevelControls the level of entries (or
                                                         above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT
                                                          register). The valid range is 0-255, with the additional restriction
                                                          that hardware does not allow this value to be set to a value
                                                          larger than the depth of the buffer. If an attempt is made to
                                                          do that, the actual value set will be the maximum depth of the
                                                          buffer.A value of 0 sets the threshold for 1 entry, and a value
                                                          of 255 sets the threshold for 256 entries.                           */
           uint32_t : 24; // padding
    } IC_RX_TL_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_TX_TL;                        /*!< I2C Transmit FIFO Threshold Register                                  */
    
    struct {
      __IO uint32_t  TX_TL      :  8;               /*!< Transmit FIFO Threshold LevelControls the level of entries (or
                                                         below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT
                                                          register). The valid range is 0-255, with the additional restriction
                                                          that it may not be set to value larger than the depth of the
                                                          buffer. If an attempt is made to do that, the actual value set
                                                          will be the maximum depth of the buffer.A value of 0 sets the
                                                          threshold for 0 entries, and a value of 255 sets the threshold
                                                          for 255 entries.                                                     */
           uint32_t : 24; // padding
    } IC_TX_TL_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_INTR;                     /*!< Clear Combined and Individual Interrupt Register                      */
    
    struct {
      __I  uint32_t  CLR_INTR   :  1;               /*!< Read this register to clear the combined interrupt, all individual
                                                         interrupts, and the IC_TX_ABRT_SOURCE register. This bit does
                                                          not clear hardware clearable interrupts but software clearable
                                                          interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register
                                                          for an exception to clearing IC_TX_ABRT_SOURCE.                      */
           uint32_t : 31; // padding
    } IC_CLR_INTR_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_RX_UNDER;                 /*!< Clear RX_UNDER Interrupt Register                                     */
    
    struct {
      __I  uint32_t  CLR_RX_UNDER:  1;              /*!< Read this register to clear the RX_UNDER interrupt (bit 0) of
                                                         the IC_RAW_INTR_STAT register.                                        */
           uint32_t : 31; // padding
    } IC_CLR_RX_UNDER_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_RX_OVER;                  /*!< Clear RX_OVER Interrupt Register                                      */
    
    struct {
      __I  uint32_t  CLR_RX_OVER:  1;               /*!< Read this register to clear the RX_OVER interrupt (bit 1) of
                                                         the IC_RAW_INTR_STAT register.                                        */
           uint32_t : 31; // padding
    } IC_CLR_RX_OVER_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_TX_OVER;                  /*!< Clear TX_OVER Interrupt Register                                      */
    
    struct {
      __I  uint32_t  CLR_TX_OVER:  1;               /*!< Read this register to clear the TX_OVER interrupt (bit 3) of
                                                         the IC_RAW_INTR_STAT register.                                        */
           uint32_t : 31; // padding
    } IC_CLR_TX_OVER_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_RD_REQ;                   /*!< Clear RD_REQ Interrupt Register                                       */
    
    struct {
      __I  uint32_t  CLR_RD_REQ :  1;               /*!< Read this register to clear the RD_REQ interrupt (bit 5) of
                                                         the IC_RAW_INTR_STAT register.                                        */
           uint32_t : 31; // padding
    } IC_CLR_RD_REQ_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_TX_ABRT;                  /*!< Clear TX_ABRT Interrupt Register                                      */
    
    struct {
      __I  uint32_t  CLR_TX_ABRT:  1;               /*!< Read this register to clear the TX_ABRT interrupt (bit 6) of
                                                         the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register.
                                                          This also releases the TX FIFO from the flushed/reset state,
                                                          allowing more writes to the TX FIFO.Refer to Bit 9 of the IC_TX_ABRT_SOURC
                                                         E register for an exception to clearing IC_TX_ABRT_SOURCE.            */
           uint32_t : 31; // padding
    } IC_CLR_TX_ABRT_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_RX_DONE;                  /*!< Clear RX_DONE Interrupt Register                                      */
    
    struct {
      __I  uint32_t  CLR_RX_DONE:  1;               /*!< Read this register to clear the RX_DONE interrupt (bit 7) of
                                                         the IC_RAW_INTR_STAT register.                                        */
           uint32_t : 31; // padding
    } IC_CLR_RX_DONE_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_ACTIVITY;                 /*!< Clear ACTIVITY Interrupt Register                                     */
    
    struct {
      __I  uint32_t  CLR_ACTIVITY:  1;              /*!< Reading this register clears the ACTIVITY interrupt if the I2C
                                                         is not active anymore. If the I2C module is still active on
                                                          the bus, the ACTIVITY interrupt bit continues to be set. It
                                                          is automatically cleared by hardware if the module is disabled
                                                          and if there is no further activity on the bus. The value read
                                                          from this register to get status of the ACTIVITY interrupt (bit
                                                          8) of the IC_RAW_INTR_STAT register.                                 */
           uint32_t : 31; // padding
    } IC_CLR_ACTIVITY_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_STOP_DET;                 /*!< Clear STOP_DET Interrupt Register                                     */
    
    struct {
      __I  uint32_t  CLR_STOP_DET:  1;              /*!< Read this register to clear the STOP_DET interrupt (bit 9) of
                                                         the IC_RAW_INTR_STAT register.                                        */
           uint32_t : 31; // padding
    } IC_CLR_STOP_DET_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_START_DET;                /*!< Clear START_DET Interrupt Register                                    */
    
    struct {
      __I  uint32_t  CLR_START_DET:  1;             /*!< Read this register to clear the START_DET interrupt (bit 10)
                                                         of the IC_RAW_INTR_STAT register.                                     */
           uint32_t : 31; // padding
    } IC_CLR_START_DET_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_CLR_GEN_CALL;                 /*!< Clear GEN_CALL Interrupt Register                                     */
    
    struct {
      __I  uint32_t  CLR_GEN_CALL:  1;              /*!< Read this register to clear the GEN_CALL interrupt (bit 11)
                                                         of IC_RAW_INTR_STAT register.                                         */
           uint32_t : 31; // padding
    } IC_CLR_GEN_CALL_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_ENABLE;                       /*!< I2C Enable Register                                                   */
    
    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< Controls whether the I2C is enabled.- 0: Disables I2C (TX and
                                                         RX FIFOs are held in an erased state)- 1: Enables I2CSoftware
                                                          can disable I2C while it is active. However, it is important
                                                          that care be taken to ensure that I2C is disabled properly.When
                                                          I2C is disabled, the following occurs:- The TX FIFO and RX FIFO
                                                          get flushed.- Status bits in the IC_INTR_STAT register are still
                                                          active until I2C goes into IDLE state.If the module is transmitting,
                                                          it stops as well as deletes the contents of the transmit buffer
                                                                                                                               */
      __IO uint32_t  ABORT      :  1;               /*!< When set, the controller initiates the transfer abort. 0: ABORT
                                                         not initiated or ABORT done 1: ABORT operation in progress The
                                                          software can abort the I2C transfer in master mode by setting
                                                          this bit. The software can set this bit only when ENABLE is
                                                          already set; otherwise, the controller ignores any write to
                                                          ABORT bit. The software cannot clear the ABORT bit once set.
                                                          In response to an ABORT, the controller issues a STOP and flushes
                                                          the Tx FIFO after completing the current transfer, then sets
                                                          the TX_ABORT i                                                       */
           uint32_t : 30; // padding
    } IC_ENABLE_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_STATUS;                       /*!< I2C Status Register                                                   */
    
    struct {
      __I  uint32_t  ACTIVITY   :  1;               /*!< I2C Activity Status                                                   */
      __I  uint32_t  TFNF       :  1;               /*!< Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                         one or more empty locations, and is cleared when the FIFO is
                                                          full.- 0: Transmit FIFO is full- 1: Transmit FIFO is not full        */
      __I  uint32_t  TFE        :  1;               /*!< Transmit FIFO Completely Empty. When the transmit FIFO is completely
                                                         empty, this bit is set. When it contains one or more valid entries,
                                                          this bit is cleared. This bit field does not request an interrupt.-
                                                          0: Transmit FIFO is not empty- 1: Transmit FIFO is empty             */
      __I  uint32_t  RFNE       :  1;               /*!< Receive FIFO Not Empty. This bit is set when the receive FIFO
                                                         contains one or more entries; it is cleared when the receive
                                                          FIFO is empty.- 0: Receive FIFO is empty- 1: Receive FIFO is
                                                          not empty                                                            */
      __I  uint32_t  RFF        :  1;               /*!< Receive FIFO Completely Full. When the receive FIFO is completely
                                                         full, this bit is set. When the receive FIFO contains one or
                                                          more empty location, this bit is cleared.- 0: Receive FIFO is
                                                          not full- 1: Receive FIFO is full                                    */
      __I  uint32_t  MST_ACTIVITY:  1;              /*!< Master FSM Activity Status. When the Master Finite State Machine
                                                         (FSM) is not in the IDLE state, this bit is set.- 0: Master
                                                          FSM is in IDLE state so the Master part of I2C is not Active-
                                                          1: Master FSM is not in IDLE state so the Master part of I2C
                                                          is Active                                                            */
      __I  uint32_t  SLV_ACTIVITY:  1;              /*!< Slave FSM Activity Status.When the Slave Finite State Machine
                                                         (FSM) is not in the IDLE state, this bit is set.- 0: Slave FSM
                                                          is in IDLE state so the Slave part of I2C is not Active- 1:
                                                          Slave FSM is not in IDLE state so the Slave part of I2C is Active    */
           uint32_t : 25; // padding
    } IC_STATUS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_TXFLR;                        /*!< I2C Transmit FIFO Level Register                                      */
    
    struct {
      __I  uint32_t  TXFLR      :  4;               /*!< Transmit FIFO Level.Contains the number of valid data entries
                                                         in the transmit FIFO.                                                 */
           uint32_t : 28; // padding
    } IC_TXFLR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_RXFLR;                        /*!< I2C Receive FIFO Level Register                                       */
    
    struct {
      __I  uint32_t  RXFLR      :  4;               /*!< Receive FIFO Level.Contains the number of valid data entries
                                                         in the receive FIFO.                                                  */
           uint32_t : 28; // padding
    } IC_RXFLR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_SDA_HOLD;                     /*!< I2C SDA Hold Time Length Register                                     */
    
    struct {
      __IO uint32_t  IC_SDA_TX_HOLD: 16;            /*!< Sets the required SDA hold time in units of ic_clk period, when
                                                         I2C acts as a transmitter.                                            */
      __IO uint32_t  IC_SDA_RX_HOLD:  8;            /*!< Sets the required SDA hold time in units of ic_clk period, when
                                                         I2C acts as a receiver.                                               */
           uint32_t : 8; // padding
    } IC_SDA_HOLD_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_TX_ABRT_SOURCE;               /*!< I2C Transmit Abort Source Register                                    */
    
    struct {
      __I  uint32_t  ABRT_7B_ADDR_NOACK:  1;        /*!< 1: Master is in 7-bit addressing mode and the address sent was
                                                         not acknowledged by any slave.                                        */
      __I  uint32_t  ABRT_10ADDR1_NOACK:  1;        /*!< 1: Master is in 10-bit address mode and the first 10-bit address
                                                         byte was not acknowledged by any slave.                               */
      __I  uint32_t  ABRT_10ADDR2_NOACK:  1;        /*!< 1: Master is in 10-bit address mode and the second address byte
                                                         of the 10-bit address was not acknowledged by any slave.              */
      __I  uint32_t  ABRT_TXDATA_NOACK:  1;         /*!< 1: This is a master-mode only bit. Master has received an acknowledgement
                                                         for the address, but when it sent data byte(s) following the
                                                          address, it did not receive an acknowledge from the remote slave(s).
                                                                                                                               */
      __I  uint32_t  ABRT_GCALL_NOACK:  1;          /*!< 1: I2C in master mode sent a General Call and no slave on the
                                                         bus acknowledged the General Call.                                    */
      __I  uint32_t  ABRT_GCALL_READ:  1;           /*!< 1: I2C in master mode sent a General Call but the user programmed
                                                         the byte following the General Call to be a read from the bus
                                                          (IC_DATA_CMD[9] is set to 1).                                        */
      __I  uint32_t  ABRT_HS_ACKDET:  1;            /*!< 1: Master is in High Speed mode and the High Speed Master code
                                                         was acknowledged (wrong behavior).                                    */
      __I  uint32_t  ABRT_SBYTE_ACKDET:  1;         /*!< 1: Master has sent a START Byte and the START Byte was acknowledged
                                                         (wrong behavior).                                                     */
      __I  uint32_t  ABRT_HS_NORSTRT:  1;           /*!< 1: The restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0)
                                                         and the user is trying to use the master to transfer data in
                                                          High Speed mode.                                                     */
      __I  uint32_t  ABRT_SBYTE_NORSTRT:  1;        /*!< To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be
                                                         fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL
                                                          bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must
                                                          be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT
                                                          is fixed, then this bit can be cleared in the same manner as
                                                          other bits in this register. If the source of the ABRT_SBYTE_NORSTRT
                                                          is not fixed before attempting to clear this bit, bit 9 clears
                                                          for one cycle and then gets reasserted. 1: The restart is disabl     */
      __I  uint32_t  ABRT_10B_RD_NORSTRT:  1;       /*!< 1: The restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0)
                                                         and the master sends a read command in 10-bit addressing mode.
                                                                                                                               */
      __I  uint32_t  ABRT_MASTER_DIS:  1;           /*!< 1: User tries to initiate a Master operation with the Master
                                                         mode disabled.                                                        */
      __I  uint32_t  ARB_LOST   :  1;               /*!< 1: Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14]
                                                         is also set, then the slave transmitter has lost arbitration.
                                                          Note: I2C can be both master and slave at the same time.             */
      __I  uint32_t  ABRT_SLVFLUSH_TXFIFO:  1;      /*!< 1: Slave has received a read command and some data exists in
                                                         the TX FIFO so the slave issues a TX_ABRT interrupt to flush
                                                          old data in TX FIFO.                                                 */
      __I  uint32_t  ABRT_SLV_ARBLOST:  1;          /*!< 1: Slave lost the bus while transmitting data to a remote master.
                                                         IC_TX_ABRT_SOURCE[12] is set at the same time.                        */
      __I  uint32_t  ABRT_SLVRD_INTX:  1;           /*!< 1: When the processor side responds to a slave mode request
                                                         for data to be transmitted to a remote master and user writes
                                                          a 1 in CMD (bit 8) of IC_DATA_CMD register.                          */
      __I  uint32_t  ABRT_USER_ABRT:  1;            /*!< This is a master-mode-only bit. Master has detected the transfer
                                                         abort (IC_ENABLE[1])                                                  */
           uint32_t             :  6;
      __I  uint32_t  TX_FLUSH_CNT:  4;              /*!< This field indicates the number of Tx FIFO Data Commands which
                                                         are flushed due to TX_ABRT interrupt. It is cleared whenever
                                                          I2C is disabled.                                                     */
           uint32_t : 5; // padding
    } IC_TX_ABRT_SOURCE_b;                          /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;
  
  union {
    __IO uint32_t  IC_DMA_CR;                       /*!< DMA Control Register                                                  */
    
    struct {
      __IO uint32_t  RDMAE      :  1;               /*!< Receive DMA Enable.This bit enables/disables the receive FIFO
                                                         DMA channel.- 0 = Receive DMA disabled- 1 = Receive DMA enabled       */
      __IO uint32_t  TDMAE      :  1;               /*!< Transmit DMA Enable.This bit enables/disables the transmit FIFO
                                                         DMA channel.- 0 = Transmit DMA disabled- 1 = Transmit DMA enabled     */
           uint32_t : 30; // padding
    } IC_DMA_CR_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_DMA_TDLR;                     /*!< DMA Transmit Data Level Register                                      */
    
    struct {
      __IO uint32_t  DMATDL     :  3;               /*!< Transmit Data Level.This bit field controls the level at which
                                                         a DMA request is made by the transmit logic. It is equal to
                                                          the watermark level; that is, the dma_tx_req signal is generated
                                                          when the number of valid data entries in the transmit FIFO is
                                                          equal to or below this field value, and TDMAE = 1.                   */
           uint32_t : 29; // padding
    } IC_DMA_TDLR_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_DMA_RDLR;                     /*!< I2C Receive Data Level Register                                       */
    
    struct {
      __IO uint32_t  DMARDL     :  3;               /*!< Receive Data Level.This bit field controls the level at which
                                                         a DMA request is made by the receive logic. The watermark level
                                                          = DMARDL+1;that is, dma_rx_req is generated when the number
                                                          of valid data entries in the receive FIFO is equal to or more
                                                          than this field value + 1, and RDMAE = 1. For instance, when
                                                          DMARDL is 0, then dma_rx_req is asserted when 1 or more data
                                                          entries are present in the receive FIFO.                             */
           uint32_t : 29; // padding
    } IC_DMA_RDLR_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_SDA_SETUP;                    /*!< I2C SDA Setup Register                                                */
    
    struct {
      __IO uint32_t  SDA_SETUP  :  8;               /*!< SDA Setup. It is recommended that if the required delay is 1000ns,
                                                         then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should
                                                          be programmed to a value of 11. IC_SDA_SETUP must be programmed
                                                          with a minimum value of 2.                                           */
           uint32_t : 24; // padding
    } IC_SDA_SETUP_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_ACK_GENERAL_CALL;             /*!< I2C ACK General Call Register                                         */
    
    struct {
      __IO uint32_t  ACK_GEN_CALL:  1;              /*!< ACK General Call.When set to 1, I2C responds with a ACK (by
                                                         asserting ic_data_oe) when it receives a General Call. When
                                                          set to 0, theI2C does not generate General Call interrupts.          */
           uint32_t : 31; // padding
    } IC_ACK_GENERAL_CALL_b;                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_ENABLE_STATUS;                /*!< I2C Enable Status Register                                            */
    
    struct {
      __I  uint32_t  IC_EN      :  1;               /*!< ic_en Status.This bit always reflects the value driven on the
                                                         output port ic_en.- When read as 1, I2C is deemed to be in an
                                                          enabled state.- When read as 0, I2C is deemed completely inactive.NOTE:
                                                          The CPU can safely read this bit anytime. When this bit is read
                                                          as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WH
                                                         ILE_BUSY (bit 1).                                                     */
      __I  uint32_t  SLV_DISABLED_WHILE_BUSY:  1;   /*!< Slave Disabled While Busy (Transmit, Receive).This bit indicates
                                                         if a potential or active Slave operation has been aborted due
                                                          to setting bit 0 of the IC_ENABLE register from 1 to 0. This
                                                          bit is set when the CPU writes a 0 to bit 0 of IC_ENABLE while:
                                                          (a) I2C is receiving the address byte of the Slave-Transmitter
                                                          operation from a remote master; OR, (b) address and data bytes
                                                          of the Slave-Receiver operation from a remote master.When read
                                                          as 1, I2C is deemed to have forced a NACK during any part of
                                                          an I2C tr                                                            */
      __I  uint32_t  SLV_RX_DATA_LOST:  1;          /*!< Slave Received Data Lost.This bit indicates if a Slave-Receiver
                                                         operation has been aborted with at least one data byte received
                                                          from an I2C transfer due to setting IC_ENABLE[0] from 1 to 0.
                                                          When read as 1, I2C is deemed to have been actively engaged
                                                          in an aborted I2C transfer (with matching address) and the data
                                                          phase of the I2C transfer has been entered, even though a data
                                                          byte has been responded with a NACK.NOTE: If the remote I2C
                                                          master terminates the transfer with a STOP condition before
                                                          the I2C has a                                                        */
           uint32_t : 29; // padding
    } IC_ENABLE_STATUS_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IC_FS_SPKLEN;                    /*!< I2C SS and FS Spike Suppression Limit Register                        */
    
    struct {
      __IO uint32_t  IC_FS_SPKLEN:  8;              /*!< This register must be set before any I2C bus transaction can
                                                         take place to ensure stable operation. This register sets the
                                                          duration, measured in ic_clk cycles, of the longest spike in
                                                          the SCL or SDA lines that are filtered out by the spike suppression
                                                          logic;This register can be written only when the I2C interface
                                                          is disabled, which corresponds to IC_ENABLE[0] being set to
                                                          0. Writes at other times have no effect.The minimum valid value
                                                          is 1; hardware prevents values less than this being written,
                                                          and if atte                                                          */
           uint32_t : 24; // padding
    } IC_FS_SPKLEN_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[20];
  
  union {
    __I  uint32_t  IC_COMP_PARAM_1;                 /*!< I2C Component Parameter Register 1                                    */
    
    struct {
      __I  uint32_t  APB_DATA_WIDTH:  2;            /*!< APB_DATA_WIDTH coreConsultant parameter. 0x0 = 8 bits 0x1 =
                                                         16 bits 0x2 = 32 bits 0x3 = Reserved                                  */
      __I  uint32_t  MAX_SPEED_MODE:  2;            /*!< MAX_SPEED_MODE coreConsultant parameter. 0x0 = Reserved 0x1
                                                         = Standard 0x2 = Fast 0x3 = High                                      */
      __I  uint32_t  HC_COUNT_VALUES:  1;           /*!< HC_COUNT_VALUES coreConsultant parameter. 0: False 1: True            */
      __I  uint32_t  INTR_IO    :  1;               /*!< INTR_IO coreConsultant parameter. 0: Individual 1: Combined           */
      __I  uint32_t  HAS_DMA    :  1;               /*!< HAS_DMA coreConsultant parameter. 0: False 1: True                    */
      __I  uint32_t  ADD_ENCODED_PARAMS:  1;        /*!< ADD_ENCODED_PARAMS coreConsultant parameter. 0: False 1: True         */
      __I  uint32_t  RX_BUFFER_DEPTH:  8;           /*!< RX_BUFFER_DEPTH coreConsultant parameter. 0x00 = Reserved 0x01
                                                         = 2 0x02 = 3 ... 0xFF = 256                                           */
      __I  uint32_t  TX_BUFFER_DEPTH:  8;           /*!< TX_BUFFER_DEPTH coreConsultant parameter. 0x00 = Reserved 0x01
                                                         = 2 0x02 = 3 ... 0xFF = 256                                           */
           uint32_t : 8; // padding
    } IC_COMP_PARAM_1_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_COMP_VERSION;                 /*!< I2C Component Version Register                                        */
    
    struct {
      __I  uint32_t  IC_COMP_VERSION: 32;           /*!< I2C Component Version Register                                        */
    } IC_COMP_VERSION_b;                            /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IC_COMP_TYPE;                    /*!< I2C Component Type Register                                           */
    
    struct {
      __I  uint32_t  IC_COMP_TYPE: 32;              /*!< Designware Component Type number = 0x44_57_01_40. This assigned
                                                         unique hex value is constant and is derived from the two ASCII
                                                          letters 'DW' followed by a 16-bit unsigned number.                   */
    } IC_COMP_TYPE_b;                               /*!< BitSize                                                               */
  };
} i2c_Type;


/* ================================================================================ */
/* ================                      spim2                     ================ */
/* ================================================================================ */


/**
  * @brief spim2 (spim2)
  */

typedef struct {                                    /*!< spim2 Structure                                                       */
  
  union {
    __IO uint32_t  CTRLR0;                          /*!< Control Register 0                                                    */
    
    struct {
      __IO uint32_t  DFS        :  4;               /*!< Data Frame Size. Selects the data frame length. When the data
                                                         frame size is programmed to be less than 16 bits, the receive
                                                          data are automatically right-justified by the receive logic,
                                                          with the upper bits of the receive FIFO zero-padded. You must
                                                          right-justify transmit data before writing into the transmit
                                                          FIFO. The transmit logic ignores the upper unused bits when
                                                          transmitting the data 0000 - Reserved - undefined operation
                                                          0001 - Reserved - undefined operation 0010 - Reserved - undefined
                                                          operation 0011 -                                                     */
      __IO uint32_t  FRF        :  2;               /*!< Frame Format. Selects which serial protocol transfers the data.
                                                         00 - Motorola SPI 01 - Texas Instruments SSP 10 - National Semiconductors
                                                          Microwire 11 - Reserved                                              */
      __IO uint32_t  SCPH       :  1;               /*!< Serial Clock Phase. Valid when the frame format (FRF) is set
                                                         to Motorola SPI. The serial clock phase selects the relationship
                                                          of the serial clock with the slave select signal. When SCPH
                                                          = 0, data are captured on the first edge of the serial clock.
                                                          When SCPH = 1, the serial clock starts toggling one cycle after
                                                          the slave select line is activated, and data are captured on
                                                          the second edge of the serial clock. 0: Serial clock toggles
                                                          in middle of first data bit 1: Serial clock toggles at start
                                                          of first data bi                                                     */
      __IO uint32_t  SCPOL      :  1;               /*!< Serial Clock Polarity. Valid when the frame format (FRF) is
                                                         set to Motorola SPI. Used to select the polarity of the inactive
                                                          serial clock, which is held inactive when the SPIM master is
                                                          not actively transferring data on the serial bus. 0 - Inactive
                                                          state of serial clock is low 1 - Inactive state of serial clock
                                                          is high                                                              */
      __IO uint32_t  TMOD       :  2;               /*!< Transfer Mode. Selects the mode of transfer for serial communication.
                                                         This field does not affect the transfer duplicity. Only indicates
                                                          whether the receive or transmit data are valid. In transmit-only
                                                          mode, data received from the external device is not valid and
                                                          is not stored in the receive FIFO memory; it is overwritten
                                                          on the next transfer. In receive-only mode, transmitted data
                                                          are not valid. After the first write to the transmit FIFO, the
                                                          same word is retransmitted for the duration of the transfer.
                                                          In                                                                   */
           uint32_t             :  1;
      __IO uint32_t  SRL        :  1;               /*!< Shift Register Loop. Used for testing purposes only. When internally
                                                         active, connects the transmit shift register output to the receive
                                                          shift register input. 0 - Normal Mode Operation 1 - Test Mode
                                                          Operation                                                            */
      __IO uint32_t  CFS        :  4;               /*!< Control Frame Size. Selects the length of the control word for
                                                         the Microwire frame format. 0000 - 1-bit control word 0001 -
                                                          2-bit control word 0010 - 3-bit control word 0011 - 4-bit control
                                                          word 0100 - 5-bit control word 0101 - 6-bit control word 0110
                                                          - 7-bit control word 0111 - 8-bit control word 1000 - 9-bit
                                                          control word 1001 - 10-bit control word 1010 - 11-bit control
                                                          word 1011 - 12-bit control word 1100 - 13-bit control word 1101
                                                          - 14-bit control word 1110 - 15-bit control word 1111 - 16-bit
                                                          control wo                                                           */
           uint32_t : 16; // padding
    } CTRLR0_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CTRLR1;                          /*!< Control Register 1                                                    */
    
    struct {
      __IO uint32_t  NDF        : 16;               /*!< Number of Data Frames. When TMOD = 10, this register field sets
                                                         the number of data frames to be continuously received by the
                                                          SPIM. The SPIM continues to receive serial data until the number
                                                          of data frames received is equal to this register value plus
                                                          1, which enables you to receive up to 64 KB of data in a continuous
                                                          transfer. When the SPIM is configured as a serial slave, the
                                                          transfer continues for as long as the slave is selected. Therefore,
                                                          this register serves no purpose and is not present when the
                                                          SPI                                                                  */
           uint32_t : 16; // padding
    } CTRLR1_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SSIENR;                          /*!< SSI Enable Register                                                   */
    
    struct {
      __IO uint32_t  SSI_EN     :  1;               /*!< SSI Enable. Enables and disables all SPIM operations. When disabled,
                                                         all serial transfers are halted immediately. Transmit and receive
                                                          FIFO buffers are cleared when the device is disabled. It is
                                                          impossible to program some of the SPIM control registers when
                                                          enabled. When disabled, the ssi_sleep output is set (after delay)
                                                          to inform the system that it is safe to remove the ssi_clk,
                                                          thus saving power consumption in the system.                         */
           uint32_t : 31; // padding
    } SSIENR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  MWCR;                            /*!< Microwire Control Register                                            */
    
    struct {
      __IO uint32_t  MWMOD      :  1;               /*!< Microwire Transfer Mode. Defines whether the Microwire transfer
                                                         is sequential or non-sequential. When sequential mode is used,
                                                          only one control word is needed to transmit or receive a block
                                                          of data words. When non-sequential mode is used, there must
                                                          be a control word for each data word that is transmitted or
                                                          received. 0: non-sequential transfer 1: sequential transfer          */
      __IO uint32_t  MDD        :  1;               /*!< Microwire Control. Defines the direction of the data word when
                                                         the Microwire serial protocol is used. When this bit is set
                                                          to 0, the data word is received by the SPIM MacroCell from the
                                                          external serial device. When this bit is set to 1, the data
                                                          word is transmitted from the SPIM MacroCell to the external
                                                          serial device.                                                       */
      __IO uint32_t  MHS        :  1;               /*!< Microwire Handshaking. Relevant only when the SPIM is configured
                                                         as a serial-master device. When configured as a serial slave,
                                                          this bit field has no functionality. Used to enable and disable
                                                          the busy/ready handshaking interface for the Microwire protocol.
                                                          When enabled, the SPIM checks for a ready status from the target
                                                          slave, after the transfer of the last data/control bit, before
                                                          clearing the BUSY status in the SR register. 0: handshaking
                                                          interface is disabled 1: handshaking interface is enabled            */
           uint32_t : 29; // padding
    } MWCR_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SER;                             /*!< Slave Enable Register                                                 */
    
    struct {
      __IO uint32_t  SER        :  1;               /*!< Slave Select Enable Flag. Each bit in this register corresponds
                                                         to a slave select line (ss_x_n]) from the SPIM master. When
                                                          a bit in this register is set (1), the corresponding slave select
                                                          line from the master is activated when a serial transfer begins.
                                                          It should be noted that setting or clearing bits in this register
                                                          have no effect on the corresponding slave select outputs until
                                                          a transfer is started. Before beginning a transfer, you should
                                                          enable the bit in this register that corresponds to the slave
                                                          de                                                                   */
           uint32_t : 31; // padding
    } SER_b;                                        /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  BAUDR;                           /*!< Baud Rate Select                                                      */
    
    struct {
      __IO uint32_t  SCKDV      : 16;               /*!< SSI Clock Divider. The LSB for this field is always set to 0
                                                         and is unaffected by a write operation, which ensures an even
                                                          value is held in this register. If the value is 0, the serial
                                                          output clock (sclk_out) is disabled. The frequency of the sclk_out
                                                          is derived from the following equation:Fsclk_out = Fssi_clk/SCKDV    */
           uint32_t : 16; // padding
    } BAUDR_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  TXFTLR;                          /*!< Transmit FIFO Threshold Level                                         */
    
    struct {
      __IO uint32_t  TFT        :  1;               /*!< Transmit FIFO Threshold. Controls the level of entries (or below)
                                                         at which the transmit FIFO controller triggers an interrupt.
                                                          The FIFO depth is configurable in the range 2-256; this register
                                                          is sized to the number of address bits needed to access the
                                                          FIFO. If you attempt to set this value greater than or equal
                                                          to the depth of the FIFO, this field is not written and retains
                                                          its current value. When the number of transmit FIFO entries
                                                          is less than or equal to this value, the transmit FIFO empty
                                                          interrupt is                                                         */
           uint32_t : 31; // padding
    } TXFTLR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  RXFTLR;                          /*!< Receive FIFO Threshold Level                                          */
    
    struct {
      __IO uint32_t  RFT        :  4;               /*!< Receive FIFO Threshold. Controls the level of entries (or above)
                                                         at which the receive FIFO controller triggers an interrupt.
                                                          The FIFO depth is configurable in the range 2-256. This register
                                                          is sized to the number of address bits needed to access the
                                                          FIFO. If you attempt to set this value greater than the depth
                                                          of the FIFO, this field is not written and retains its current
                                                          value. When the number of receive FIFO entries is greater than
                                                          or equal to this value + 1, the receive FIFO full interrupt
                                                          is triggered.                                                        */
           uint32_t : 28; // padding
    } RXFTLR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TXFLR;                           /*!< Transmit FIFO Level Register                                          */
    
    struct {
      __I  uint32_t  TXTFL      :  2;               /*!< Transmit FIFO Level. Contains the number of valid data entries
                                                         in the transmit FIFO.                                                 */
           uint32_t : 30; // padding
    } TXFLR_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RXFLR;                           /*!< Receive FIFO Level Register                                           */
    
    struct {
      __I  uint32_t  RXTFL      :  4;               /*!< Receive FIFO Level. Contains the number of valid data entries
                                                         in the receive FIFO.                                                  */
           uint32_t : 28; // padding
    } RXFLR_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  SR;                              /*!< Status Register                                                       */
    
    struct {
      __I  uint32_t  BUSY       :  1;               /*!< SSI Busy Flag. When set, indicates that a serial transfer is
                                                         in progress; when cleared indicates that the SPIM is idle or
                                                          disabled. 0 - SPIM is idle or disabled 1 - SPIM is actively
                                                          transferring data                                                    */
      __I  uint32_t  TFNF       :  1;               /*!< Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                         one or more empty locations, and is cleared when the FIFO is
                                                          full. 0 - Transmit FIFO is full 1 - Transmit FIFO is not full        */
      __I  uint32_t  TFE        :  1;               /*!< Transmit FIFO Empty. When the transmit FIFO is completely empty,
                                                         this bit is set. When the transmit FIFO contains one or more
                                                          valid entries, this bit is cleared. This bit field does not
                                                          request an interrupt. 0 - Transmit FIFO is not empty 1 - Transmit
                                                          FIFO is empty                                                        */
      __I  uint32_t  RFNE       :  1;               /*!< Receive FIFO Not Empty. Set when the receive FIFO contains one
                                                         or more entries and is cleared when the receive FIFO is empty.
                                                          This bit can be polled by software to completely empty the receive
                                                          FIFO. 0 - Receive FIFO is empty 1 - Receive FIFO is not empty        */
      __I  uint32_t  RFF        :  1;               /*!< Receive FIFO Full. When the receive FIFO is completely full,
                                                         this bit is set. When the receive FIFO contains one or more
                                                          empty location, this bit is cleared. 0 - Receive FIFO is not
                                                          full 1 - Receive FIFO is full                                        */
           uint32_t             :  1;
      __I  uint32_t  DCOL       :  1;               /*!< Data Collision Error. Relevant only when the SPIM is configured
                                                         as a master device. This bit is set if the SPIM master is actively
                                                          transmitting when another master selects this device as a slave.
                                                          This informs the processor that the last data transfer was halted
                                                          before completion. This bit is cleared when read. 0 - No error
                                                          1 - Transmit data collision error                                    */
           uint32_t : 25; // padding
    } SR_b;                                         /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IMR;                             /*!< Interrupt Mask Register                                               */
    
    struct {
      __IO uint32_t  TXEIM      :  1;               /*!< Transmit FIFO Empty Interrupt Mask 0 - ssi_txe_intr interrupt
                                                         is masked 1 - ssi_txe_intr interrupt is not masked                    */
      __IO uint32_t  TXOIM      :  1;               /*!< Transmit FIFO Overflow Interrupt Mask 0 - ssi_txo_intr interrupt
                                                         is masked 1 - ssi_txo_intr interrupt is not masked                    */
      __IO uint32_t  RXUIM      :  1;               /*!< Receive FIFO Underflow Interrupt Mask 0 - ssi_rxu_intr interrupt
                                                         is masked 1 - ssi_rxu_intr interrupt is not masked                    */
      __IO uint32_t  RXOIM      :  1;               /*!< Receive FIFO Overflow Interrupt Mask 0 - ssi_rxo_intr interrupt
                                                         is masked 1 - ssi_rxo_intr interrupt is not masked                    */
      __IO uint32_t  RXFIM      :  1;               /*!< Receive FIFO Full Interrupt Mask 0 - ssi_rxf_intr interrupt
                                                         is masked 1 - ssi_rxf_intr interrupt is not masked                    */
      __IO uint32_t  MSTIM      :  1;               /*!< Multi-Master Contention Interrupt Mask. This bit field is not
                                                         present if the SPIM is configured as a serial-slave device.
                                                          0 - ssi_mst_intr interrupt is masked 1 - ssi_mst_intr interrupt
                                                          is not masked                                                        */
           uint32_t : 26; // padding
    } IMR_b;                                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  ISR;                             /*!< Interrupt Status Register                                             */
    
    struct {
      __I  uint32_t  TXEIS      :  1;               /*!< Transmit FIFO Empty Interrupt Status 0 = ssi_txe_intr interrupt
                                                         is not active after masking 1 = ssi_txe_intr interrupt is active
                                                          after masking                                                        */
      __I  uint32_t  TXOIS      :  1;               /*!< Transmit FIFO Overflow Interrupt Status 0 = ssi_txo_intr interrupt
                                                         is not active after masking 1 = ssi_txo_intr interrupt is active
                                                          after masking                                                        */
      __I  uint32_t  RXUIS      :  1;               /*!< Receive FIFO Underflow Interrupt Status 0 = ssi_rxu_intr interrupt
                                                         is not active after masking 1 = ssi_rxu_intr interrupt is active
                                                          after masking                                                        */
      __I  uint32_t  RXOIS      :  1;               /*!< Receive FIFO Overflow Interrupt Status 0 = ssi_rxo_intr interrupt
                                                         is not active after masking 1 = ssi_rxo_intr interrupt is active
                                                          after masking                                                        */
      __I  uint32_t  RXFIS      :  1;               /*!< Receive FIFO Full Interrupt Status 0 = ssi_rxf_intr interrupt
                                                         is not active after masking 1 = ssi_rxf_intr interrupt is full
                                                          after masking                                                        */
      __I  uint32_t  MSTIS      :  1;               /*!< Multi-Master Contention Interrupt Status. This bit field is
                                                         not present if the SPIM is configured as a serial-slave device.
                                                          0 = ssi_mst_intr interrupt not active after masking 1 = ssi_mst_intr
                                                          interrupt is active after masking                                    */
           uint32_t : 26; // padding
    } ISR_b;                                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RISR;                            /*!< Raw Interrupt StatusRegister                                          */
    
    struct {
      __I  uint32_t  TXEIR      :  1;               /*!< Transmit FIFO Empty Raw Interrupt Status 0 = ssi_txe_intr interrupt
                                                         is not active prior to masking 1 = ssi_txe_intr interrupt is
                                                          active prior masking                                                 */
      __I  uint32_t  TXOIR      :  1;               /*!< Transmit FIFO Overflow Raw Interrupt Status 0 = ssi_txo_intr
                                                         interrupt is not active prior to masking 1 = ssi_txo_intr interrupt
                                                          is active prior masking                                              */
      __I  uint32_t  RXUIR      :  1;               /*!< Receive FIFO Underflow Raw Interrupt Status 0 = ssi_rxu_intr
                                                         interrupt is not active prior to masking 1 = ssi_rxu_intr interrupt
                                                          is active prior to masking                                           */
      __I  uint32_t  RXOIR      :  1;               /*!< Receive FIFO Overflow Raw Interrupt Status 0 = ssi_rxo_intr
                                                         interrupt is not active prior to masking 1 = ssi_rxo_intr interrupt
                                                          is active prior masking                                              */
      __I  uint32_t  RXFIR      :  1;               /*!< Receive FIFO Full Raw Interrupt Status 0 = ssi_rxf_intr interrupt
                                                         is not active prior to masking 1 = ssi_rxf_intr interrupt is
                                                          active prior to masking                                              */
      __I  uint32_t  MSTIR      :  1;               /*!< Multi-Master Contention Raw Interrupt Status. This bit field
                                                         is not present if the SPIM is configured as a serial-slave device.
                                                          0 = ssi_mst_intr interrupt is not active prior to masking 1
                                                          = ssi_mst_intr interrupt is active prior masking                     */
           uint32_t : 26; // padding
    } RISR_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  TXOICR;                          /*!< Transmit FIFO Overflow Interrupt Clear Register                       */
    
    struct {
      __I  uint32_t  TXOICR     :  1;               /*!< Clear Transmit FIFO Overflow Interrupt. This register reflects
                                                         the status of the interrupt. A read from this register clears
                                                          the ssi_txo_intr interrupt; writing has no effect.                   */
           uint32_t : 31; // padding
    } TXOICR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RXOICR;                          /*!< Receive FIFO Overflow Interrupt Clear Register                        */
    
    struct {
      __I  uint32_t  RXOICR     :  1;               /*!< Clear Receive FIFO Overflow Interrupt. This register reflects
                                                         the status of the interrupt. A read from this register clears
                                                          the ssi_rxo_intr interrupt; writing has no effect.                   */
           uint32_t : 31; // padding
    } RXOICR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RXUICR;                          /*!< Receive FIFO Underflow Interrupt Clear Register                       */
    
    struct {
      __I  uint32_t  RXUICR     :  1;               /*!< Clear Receive FIFO Underflow Interrupt. This register reflects
                                                         the status of the interrupt. A read from this register clears
                                                          the ssi_rxu_intr interrupt; writing has no effect.                   */
           uint32_t : 31; // padding
    } RXUICR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  MSTICR;                          /*!< Multi-Master Interrupt Clear Register                                 */
    
    struct {
      __I  uint32_t  MSTICR     :  1;               /*!< Clear Multi-Master Contention Interrupt. This register reflects
                                                         the status of the interrupt. A read from this register clears
                                                          the ssi_mst_intr interrupt; writing has no effect.                   */
           uint32_t : 31; // padding
    } MSTICR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  ICR;                             /*!< Interrupt Clear Register                                              */
    
    struct {
      __I  uint32_t  ICR        :  1;               /*!< Clear Interrupts. This register is set if any of the interrupts
                                                         below are active. A read clears the ssi_txo_intr, ssi_rxu_intr,
                                                          ssi_rxo_intr, and the ssi_mst_intr interrupts. Writing to this
                                                          register has no effect.                                              */
           uint32_t : 31; // padding
    } ICR_b;                                        /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACR;                           /*!< DMA Control Register                                                  */
    
    struct {
      __IO uint32_t  RDMAE      :  1;               /*!< Receive DMA Enable. This bit enables/disables the receive FIFO
                                                         DMA channel 0 = Receive DMA disabled 1 = Receive DMA enabled          */
      __IO uint32_t  TDMAE      :  1;               /*!< Transmit DMA Enable. This bit enables/disables the transmit
                                                         FIFO DMA channel. 0 = Transmit DMA disabled 1 = Transmit DMA
                                                          enabled                                                              */
           uint32_t : 30; // padding
    } DMACR_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMATDLR;                         /*!< DMA Transmit Data Level                                               */
    
    struct {
      __IO uint32_t  DMATDL     :  1;               /*!< Transmit Data Level. This bit field controls the level at which
                                                         a DMA request is made by the transmit logic. It is equal to
                                                          the watermark level; that is, the dma_tx_req signal is generated
                                                          when the number of valid data entries in the transmit FIFO is
                                                          equal to or below this field value, and TDMAE = 1. 000 - dma_tx_req
                                                          is asserted when 0 data entries are present in the transmit
                                                          FIFO 001 - dma_tx_req is asserted when 1 or less data entry
                                                          is present in the transmit FIFO                                      */
           uint32_t : 31; // padding
    } DMATDLR_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMARDLR;                         /*!< DMA Receive Data Level                                                */
    
    struct {
      __IO uint32_t  DMARDL     :  4;               /*!< Receive Data Level. This bit field controls the level at which
                                                         a DMA request is made by the receive logic. The watermark level
                                                          = DMARDL+1; that is, dma_rx_req is generated when the number
                                                          of valid data entries in the receive FIFO is equal to or above
                                                          this field value + 1, and RDMAE=1. 000 - dma_rx_req is asserted
                                                          when 1 or more data entries are present in the receive FIFO
                                                          001 - dma_rx_req is asserted when 2 or more data entries are
                                                          present in the receive FIFO 010 - dma_rx_req is asserted when
                                                          3 or more dat                                                        */
           uint32_t : 28; // padding
    } DMARDLR_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  IDR;                             /*!< Identification Register                                               */
    
    struct {
      __I  uint32_t  IDR        : 32;               /*!< Identification Register. This register contains the peripherals
                                                         identification code, which is written into the register at configuration. */
    } IDR_b;                                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  SSI_VERSION_ID;                  /*!< coreKit Version ID Register                                           */
    
    struct {
      __I  uint32_t  SSI_VERSION_ID: 32;            /*!< coreKit Version ID Register                                           */
    } SSI_VERSION_ID_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DR[36];                          /*!< Data Register                                                         */
    
    struct {
      __IO uint32_t  dr         : 16;               /*!< Data Register. When writing to this register, you must right-justify
                                                         the data. Read data are automatically right-justified. Read
                                                          = Receive FIFO buffer Write = Transmit FIFO buffer                   */
           uint32_t : 16; // padding
    } DR_b[36];                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;
  
  union {
    __I  uint32_t  RSVD_0;                          /*!< Reserved 0                                                            */
    
    struct {
      __I  uint32_t  RSVD_0     : 32;               /*!< Reserved location for future use                                      */
    } RSVD_0_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RSVD_1;                          /*!< Reserved 1                                                            */
    
    struct {
      __I  uint32_t  RSVD_1     : 32;               /*!< Reserved location for future use                                      */
    } RSVD_1_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  RSVD_2;                          /*!< Reserved 2                                                            */
    
    struct {
      __I  uint32_t  RSVD_2     : 32;               /*!< Reserved location for future use                                      */
    } RSVD_2_b;                                     /*!< BitSize                                                               */
  };
} spim_Type;


/* ================================================================================ */
/* ================                     adcc12                     ================ */
/* ================================================================================ */


/**
  * @brief adcc12 (adcc12)
  */

typedef struct {                                    /*!< adcc12 Structure                                                      */
  
  union {
    __IO uint32_t  MODESEL;                         /*!< Mode set register                                                     */
    
    struct {
      __IO uint32_t  ConvMd     :  2;               /*!< Conversion modeSets ADC conversion modes.00: SinglePerforms
                                                         conversion of a channel specified by ChSel.01: One-time scanSequentially
                                                          performs conversion for channels enabled by each channel set
                                                          register. Comes to a stop after one round of conversions. 10:
                                                          Cyclic scanSequentially performs conversion for channels enabled
                                                          by each channel set register. Repeats conversion operation until
                                                          a stop instruction is issued by a control register. 11: Reserved     */
           uint32_t             :  2;
      __IO uint32_t  FIFOMd     :  1;               /*!< FIFO modeSets the method of storing conversion data in FIFO.0:
                                                         StreamDiscards the oldest data and stores the latest data in
                                                          FIFO when FIFO is full.1: FIFO stopRetains data in FIFO and
                                                          discards the latest data when FIFO is full.                          */
           uint32_t             :  3;
      __IO uint32_t  ChSel      :  2;               /*!< Channel selectionSets the channel number that the AD conversion
                                                         is made.Used only when conversion mode is Single00: Ch001: Ch110:
                                                          Ch211: Ch3                                                           */
           uint32_t             : 14;
      __IO uint32_t  PUpToChSet :  4;               /*!< ADC PowerUp to Channel SetSets a period between ADC macro power
                                                         down release and channel set (start of conversion if ChSetToStart
                                                          setting is '0')The period is the number of cycles given by:(Settings
                                                          + 2) x reference clock*) Reference clock is ADC clocks.              */
      __IO uint32_t  ChSetToStart:  4;              /*!< ADC Channel Select to Conversion StartSets a period between
                                                         ADC macro channel setting (switching) and start of conversion.The
                                                          period is the number of cycles given by:(Settings) x reference
                                                          clock*) Reference clock is ADC clocks.                               */
    } MODESEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ADCCTL;                          /*!< AD conversion control register                                        */
    
    struct {
      __IO uint32_t  Start      :  1;               /*!< Start of conversionStarts ADC conversion[For read operation]0:
                                                         ADC conversion is stopped1: ADC conversion in operation[For
                                                          write operation]0: - 1: Starts AD conversionWriting '1' to this
                                                          bit starts AD conversion operation. In the Single mode and One-Time
                                                          Scan mode, this bit is automatically returned to '0' when all
                                                          of conversion operations have been completed.Writing '1' to
                                                          the Stop bit during conversion operation causes the bit to return
                                                          to '0' after conversion operation being executed has been completed. */
      __IO uint32_t  Stop       :  1;               /*!< Stop conversionForcibly stops ADC conversion operation.[For
                                                         read operation]0: ADC in operation or going to stop1: ADC conversion
                                                          is stopped[For write operation]0: - 1: Starts AD conversion
                                                          stop oepration Writing '1' to this bit can stop AD conversion.
                                                          After conversion operation being executed has been completed,
                                                          ADC comes to a stop and this bit is returned to '0'.When ADC
                                                          conversion is being stopped (Start bit is '0'), '1' cannot be
                                                          written to this bit.'0' cannot be written to this bit (Even
                                                          if '0' is writ                                                       */
           uint32_t : 30; // padding
    } ADCCTL_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ADCINTEN;                        /*!< AD conversion interrupt control register                              */
    
    struct {
      __IO uint32_t  ConvEndEn  :  1;               /*!< Conversion termination interrupt0: Disable1: Enable                   */
      __IO uint32_t  ScanEndEn  :  1;               /*!< Scan operation termination interrupt0: Disable1: Enable               */
           uint32_t             :  2;
      __IO uint32_t  CmpInt0En  :  1;               /*!< Converted value comparison 0 interrupt0: Disable1: Enable             */
      __IO uint32_t  CmpInt1En  :  1;               /*!< Converted value comparison 1 interrupt0: Disable1: Enable             */
           uint32_t : 26; // padding
    } ADCINTEN_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ADCINTSTS;                       /*!< AD conversion interrupt status register                               */
    
    struct {
      __IO uint32_t  ConvEnd    :  1;               /*!< Conversion termination interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred[For write]0: -1: Clear interrupt                   */
      __IO uint32_t  ScanEnd    :  1;               /*!< Scan operation termination interrupt[For read]0: No interrupt
                                                         occurred1: Interrupt occurred[For write]0: -1: Clear interrupt        */
           uint32_t             :  2;
      __IO uint32_t  CmpInt0    :  1;               /*!< Converted value comparison 0 interrupt[For read]0: No interrupt
                                                         occurred1: Interrupt occurred[Write]0: -1: Clear interrupt            */
      __IO uint32_t  CmpInt1    :  1;               /*!< Converted value comparison 1 interrupt[For read]0: No interrupt
                                                         occurred1: Interrupt occurred[For write]0: -1: Clear interrupt        */
           uint32_t             : 10;
      __I  uint32_t  ChInt      :  4;               /*!< Channel interruptIndicates interrupt occurrence status in each
                                                         of Ch 0 to 3. 0: No interrupt occurred1: Interrupt occurredDetails
                                                          of interrupt factors can be checked by an interrupt status register
                                                          for each channel.                                                    */
           uint32_t : 12; // padding
    } ADCINTSTS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_CTRCTL;                     /*!< Sampling timing generation counter control register                   */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  SrcSel     :  3;               /*!< Source clock selection for sampling timing generation counter
                                                         000: ADC clock001: 4 divisions of ADC clock010: 16 divisions
                                                          of ADC clock011: 64 divisions of ADC clock100: RTC clockOther
                                                          than those above: Settings prohibited                                */
           uint32_t : 25; // padding
    } SPLT_CTRCTL_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_PER;                        /*!< Sampling period setting register                                      */
    
    struct {
      __IO uint32_t  Period     : 16;               /*!< Specifies the period of sampling timing signalSet the number
                                                         of clock cycles of sampling timing generation counter. Setting
                                                          of '0x0000' is prohibited. Set values in the range from '0x0001'
                                                          to '0xffff'.                                                         */
           uint32_t : 16; // padding
    } SPLT_PER_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_WAVCFG;                     /*!< Sampling timing signal waveform setting register                      */
    
    struct {
      __IO uint32_t  CycToRise  : 16;               /*!< Specfies the time to rise of sampling timing signalSet the number
                                                         of clock cycles of sampling timing generation counter. Set values
                                                          smaller than [SPLT_PER].                                             */
           uint32_t : 16; // padding
    } SPLT_WAVCFG_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_SYNC_WAVCFG;                /*!< Sampling timing synchronous signal waveform setting register          */
    
    struct {
      __IO uint32_t  CycToRise  : 16;               /*!< Specfies the time to rise of sampling timing synchronous signalSet
                                                         the number of clock cycles of sampling timing generation counter.
                                                          Set values smaller than [SPLT_PER].                                  */
           uint32_t : 16; // padding
    } SPLT_SYNC_WAVCFG_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CMPDATA_0;                       /*!< Compare data setting register 0                                       */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  CmpData    : 12;               /*!< Compare dataConverted values to be stored in FIFO and the value
                                                         of this register field are compared, and an interrupt signal
                                                          is generated according to the results of comparison as to which
                                                          is greater or smaller. Comparison as to which is greater or
                                                          smaller is specified by the CmpSel bit.                              */
           uint32_t             :  8;
      __IO uint32_t  CmpCh      :  2;               /*!< Compare channel selectSelects a channel where converted values
                                                         are compared00: Ch001: Ch110: Ch211: Ch3                              */
           uint32_t             :  2;
      __IO uint32_t  CmpEn      :  1;               /*!< Compare enable0: Converted values not compared1: Converted values
                                                         compared                                                              */
      __IO uint32_t  CmpSel     :  1;               /*!< Compare mode select0: An interrupt occurs when converted values
                                                         is larger than compare data.1: An interrupt occurs when converted
                                                          values is smaller than converted values                              */
           uint32_t : 2; // padding
    } CMPDATA_0_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CMPDATA_1;                       /*!< Compare data setting register 1                                       */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  CmpData    : 12;               /*!< Same as CMPDATA_0                                                     */
           uint32_t             :  8;
      __IO uint32_t  CmpCh      :  2;               /*!< Same as CMPDATA_0                                                     */
           uint32_t             :  2;
      __IO uint32_t  CmpEn      :  1;               /*!< Same as CMPDATA_0                                                     */
      __IO uint32_t  CmpSel     :  1;               /*!< Same as CMPDATA_0                                                     */
           uint32_t : 2; // padding
    } CMPDATA_1_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[6];
  
  union {
    __IO uint32_t  EXT_CTL;                         /*!< External output signal control register                               */
    
    struct {
      __IO uint32_t  SelExt     :  2;               /*!< External output signal data selection 00: '0' is always output01:
                                                         '1' is always output10/11: Sampling timing synchronous signals
                                                          are output                                                           */
      __IO uint32_t  InvExt     :  1;               /*!< External output signal inversion select0: Not inverted1: Inverted*)
                                                         Invert/Not invert process is performed on data selected by SelExt     */
           uint32_t : 29; // padding
    } EXT_CTL_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[47];
  
  union {
    __IO uint32_t  CH0_MODE;                        /*!< Channel 0 mode setting register                                       */
    
    struct {
      __IO uint32_t  ChEn       :  1;               /*!< Channel enable Determines whether an analog input of this channel
                                                         is subjected to AD conversion. Enabled only in the One-Time
                                                          and Cyclic Scan modes. In Single mode, the channel set to [MODESEL].ChSel
                                                          are selected regardless of settings of this bit. 0: Disable1:
                                                          Enable                                                               */
      __IO uint32_t  DtFmt      :  1;               /*!< Conversion data formatSelects formats of data to be stored in
                                                         FIFO0: Unsigned integer1: Signed integer                              */
      __IO uint32_t  OfstEn     :  1;               /*!< Offset for conversion data enable0: Disable1: Enable                  */
      __IO uint32_t  DMAEn      :  1;               /*!< DMA transfer request enable0: Disable1: Enable                        */
      __IO uint32_t  DownSpl    :  3;               /*!< Down Sampling000: No down sampling (sampling done every time)001:
                                                         One sampling in two times 010: One sampling in three times...110:
                                                          One sampling in seven times111: One sampling in eight times          */
      __IO uint32_t  DMAReq     :  1;               /*!< DMA request status[For read]0: No DMA request1: DMA request
                                                         asserted[For write]0: - 1: Cancell DMA request                        */
      __IO uint32_t  WaterMark  :  3;               /*!< Watermark interrupt level countSelects the number of FIFO steps
                                                         where Watermark interrupt is generated000: 1 step001: 2 steps010:
                                                          3 steps011: 4 steps ...110: 7 steps111: 8 steps                      */
           uint32_t : 21; // padding
    } CH0_MODE_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH0_INTEN;                       /*!< Channel 0 interrupt control register                                  */
    
    struct {
      __IO uint32_t  ChEocEn    :  1;               /*!< End of Conversion interrupt0: Disable1: Enable                        */
      __IO uint32_t  WMIntEn    :  1;               /*!< Watermark interrupt0: Disable1: Enable                                */
      __IO uint32_t  FstDLostEn :  1;               /*!< 1st data lost interrupt0: Disable1: Enable                            */
      __IO uint32_t  LstDLostEn :  1;               /*!< Last data lost interrupt0: Disable1: Enable                           */
      __IO uint32_t  FIFOFullEn :  1;               /*!< FIFO full interrupt0: Disable1: Enable                                */
      __IO uint32_t  FIFOurunEn :  1;               /*!< FIFO underrun interrupt0: Disable1: Enable                            */
           uint32_t : 26; // padding
    } CH0_INTEN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH0_INTSTS;                      /*!< Channel 0 interrupt status register                                   */
    
    struct {
      __IO uint32_t  ChEoc      :  1;               /*!< Conversion completion interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred[For write]0: - 1: Clear interrupt                  */
      __IO uint32_t  WMInt      :  1;               /*!< Watermark interrupt[For read]0: No interrupt occurred1: Interrupt
                                                         occurred[For write]0: - 1: Clear interrupt                            */
      __IO uint32_t  FstDLost   :  1;               /*!< 1st data lost interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred[For write]0: - 1: Clear interrupt                  */
      __IO uint32_t  LstDLost   :  1;               /*!< Last data lost interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred[For write]0: - 1: Clear interrupt                  */
      __IO uint32_t  FIFOFull   :  1;               /*!< FIFO full interrupt[For read]0: No interrupt occurred1: Interrupt
                                                         occurred[For write]0: - 1: Clear interrupt                            */
      __IO uint32_t  FIFOurun   :  1;               /*!< FIFO underrun interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred[For write]0: - 1: Clear interrupt                  */
           uint32_t : 26; // padding
    } CH0_INTSTS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH0_OFFSET;                      /*!< Channel 0 conversion data offset                                      */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  Offset     :  8;               /*!< Offset data for adjusting conversion dataIf offset for conversion
                                                         data is enabled, conversrion result is added with this registers
                                                          value and then sotred to FIFO. MSB of this register is a sign
                                                          bit (i.e. calculation with conversion result is done after sign
                                                          extention). If arithmetic result is larger tha the upper limit
                                                          or smaller than lower limits of the conversion range, limit
                                                          values are stored in FIFO.                                           */
           uint32_t : 20; // padding
    } CH0_OFFSET_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH0_FIFOSTS;                     /*!< Channel 0 FIFO status                                                 */
    
    struct {
      __I  uint32_t  DataNum    :  4;               /*!< Number of data frames in FIFO0 to 8 frame(s)                          */
           uint32_t : 28; // padding
    } CH0_FIFOSTS_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[3];
  
  union {
    __IO uint32_t  CH1_MODE;                        /*!< Channel 1 mode setting register                                       */
    
    struct {
      __IO uint32_t  ChEn       :  1;               /*!< ChEn                                                                  */
      __IO uint32_t  DtFmt      :  1;               /*!< DtFmt                                                                 */
      __IO uint32_t  OfstEn     :  1;               /*!< OfstEn                                                                */
      __IO uint32_t  DMAEn      :  1;               /*!< DMAEn                                                                 */
      __IO uint32_t  DownSpl    :  3;               /*!< DownSpl                                                               */
      __IO uint32_t  DMAReq     :  1;               /*!< DMAReq                                                                */
      __IO uint32_t  WaterMark  :  3;               /*!< WaterMark                                                             */
           uint32_t : 21; // padding
    } CH1_MODE_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH1_INTEN;                       /*!< Channel 1 interrupt control register                                  */
    
    struct {
      __IO uint32_t  ChEocEn    :  1;               /*!< ChEocEn                                                               */
      __IO uint32_t  WMIntEn    :  1;               /*!< WMIntEn                                                               */
      __IO uint32_t  FstDLostEn :  1;               /*!< FstDLostEn                                                            */
      __IO uint32_t  LstDLostEn :  1;               /*!< LstDLostEn                                                            */
      __IO uint32_t  FIFOFullEn :  1;               /*!< FIFOFullEn                                                            */
      __IO uint32_t  FIFOurunEn :  1;               /*!< FIFOurunEn                                                            */
           uint32_t : 26; // padding
    } CH1_INTEN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH1_INTSTS;                      /*!< Channel 1 interrupt status register                                   */
    
    struct {
      __IO uint32_t  ChEoc      :  1;               /*!< ChEoc                                                                 */
      __IO uint32_t  WMInt      :  1;               /*!< WMInt                                                                 */
      __IO uint32_t  FstDLost   :  1;               /*!< FstDLost                                                              */
      __IO uint32_t  LstDLost   :  1;               /*!< LstDLost                                                              */
      __IO uint32_t  FIFOFull   :  1;               /*!< FIFOFull                                                              */
      __IO uint32_t  FIFOurun   :  1;               /*!< FIFOurun                                                              */
           uint32_t : 26; // padding
    } CH1_INTSTS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH1_OFFSET;                      /*!< Channel 1 conversion data offset                                      */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  Offset     :  8;               /*!< Offset                                                                */
           uint32_t : 20; // padding
    } CH1_OFFSET_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH1_FIFOSTS;                     /*!< Channel 1 FIFO status                                                 */
    
    struct {
      __I  uint32_t  DataNum    :  4;               /*!< DataNum                                                               */
           uint32_t : 28; // padding
    } CH1_FIFOSTS_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[3];
  
  union {
    __IO uint32_t  CH2_MODE;                        /*!< Channel 2 mode setting register                                       */
    
    struct {
      __IO uint32_t  ChEn       :  1;               /*!< ChEn                                                                  */
      __IO uint32_t  DtFmt      :  1;               /*!< DtFmt                                                                 */
      __IO uint32_t  OfstEn     :  1;               /*!< OfstEn                                                                */
      __IO uint32_t  DMAEn      :  1;               /*!< DMAEn                                                                 */
      __IO uint32_t  DownSpl    :  3;               /*!< DownSpl                                                               */
      __IO uint32_t  DMAReq     :  1;               /*!< DMAReq                                                                */
      __IO uint32_t  WaterMark  :  3;               /*!< WaterMark                                                             */
           uint32_t : 21; // padding
    } CH2_MODE_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH2_INTEN;                       /*!< Channel 2 interrupt control register                                  */
    
    struct {
      __IO uint32_t  ChEocEn    :  1;               /*!< ChEocEn                                                               */
      __IO uint32_t  WMIntEn    :  1;               /*!< WMIntEn                                                               */
      __IO uint32_t  FstDLostEn :  1;               /*!< FstDLostEn                                                            */
      __IO uint32_t  LstDLostEn :  1;               /*!< LstDLostEn                                                            */
      __IO uint32_t  FIFOFullEn :  1;               /*!< FIFOFullEn                                                            */
      __IO uint32_t  FIFOurunEn :  1;               /*!< FIFOurunEn                                                            */
           uint32_t : 26; // padding
    } CH2_INTEN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH2_INTSTS;                      /*!< Channel 2 interrupt status register                                   */
    
    struct {
      __IO uint32_t  ChEoc      :  1;               /*!< ChEoc                                                                 */
      __IO uint32_t  WMInt      :  1;               /*!< WMInt                                                                 */
      __IO uint32_t  FstDLost   :  1;               /*!< FstDLost                                                              */
      __IO uint32_t  LstDLost   :  1;               /*!< LstDLost                                                              */
      __IO uint32_t  FIFOFull   :  1;               /*!< FIFOFull                                                              */
      __IO uint32_t  FIFOurun   :  1;               /*!< FIFOurun                                                              */
           uint32_t : 26; // padding
    } CH2_INTSTS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH2_OFFSET;                      /*!< Channel 2 conversion data offset                                      */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  Offset     :  8;               /*!< Offset                                                                */
           uint32_t : 20; // padding
    } CH2_OFFSET_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH2_FIFOSTS;                     /*!< Channel 2 FIFO status                                                 */
    
    struct {
      __I  uint32_t  DataNum    :  4;               /*!< DataNum                                                               */
           uint32_t : 28; // padding
    } CH2_FIFOSTS_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[3];
  
  union {
    __IO uint32_t  CH3_MODE;                        /*!< Channel 3 mode setting register                                       */
    
    struct {
      __IO uint32_t  ChEn       :  1;               /*!< ChEn                                                                  */
      __IO uint32_t  DtFmt      :  1;               /*!< DtFmt                                                                 */
      __IO uint32_t  OfstEn     :  1;               /*!< OfstEn                                                                */
      __IO uint32_t  DMAEn      :  1;               /*!< DMAEn                                                                 */
      __IO uint32_t  DownSpl    :  3;               /*!< DownSpl                                                               */
      __IO uint32_t  DMAReq     :  1;               /*!< DMAReq                                                                */
      __IO uint32_t  WaterMark  :  3;               /*!< WaterMark                                                             */
           uint32_t : 21; // padding
    } CH3_MODE_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH3_INTEN;                       /*!< Channel 3 interrupt control register                                  */
    
    struct {
      __IO uint32_t  ChEocEn    :  1;               /*!< ChEocEn                                                               */
      __IO uint32_t  WMIntEn    :  1;               /*!< WMIntEn                                                               */
      __IO uint32_t  FstDLostEn :  1;               /*!< FstDLostEn                                                            */
      __IO uint32_t  LstDLostEn :  1;               /*!< LstDLostEn                                                            */
      __IO uint32_t  FIFOFullEn :  1;               /*!< FIFOFullEn                                                            */
      __IO uint32_t  FIFOurunEn :  1;               /*!< FIFOurunEn                                                            */
           uint32_t : 26; // padding
    } CH3_INTEN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH3_INTSTS;                      /*!< Channel 3 interrupt status register                                   */
    
    struct {
      __IO uint32_t  ChEoc      :  1;               /*!< ChEoc                                                                 */
      __IO uint32_t  WMInt      :  1;               /*!< WMInt                                                                 */
      __IO uint32_t  FstDLost   :  1;               /*!< FstDLost                                                              */
      __IO uint32_t  LstDLost   :  1;               /*!< LstDLost                                                              */
      __IO uint32_t  FIFOFull   :  1;               /*!< FIFOFull                                                              */
      __IO uint32_t  FIFOurun   :  1;               /*!< FIFOurun                                                              */
           uint32_t : 26; // padding
    } CH3_INTSTS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH3_OFFSET;                      /*!< Channel 3 conversion data offset                                      */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  Offset     :  8;               /*!< Offset                                                                */
           uint32_t : 20; // padding
    } CH3_OFFSET_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH3_FIFOSTS;                     /*!< Channel 3 FIFO status                                                 */
    
    struct {
      __I  uint32_t  DataNum    :  4;               /*!< DataNum                                                               */
           uint32_t : 28; // padding
    } CH3_FIFOSTS_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[419];
  
  union {
    __I  uint32_t  CH0_DATA[16];                    /*!< Channel 0 conversion result data register *) Though there is
                                                         a 64-byte region ranging 0x800 to 0x83f, each address is allocated
                                                          to the same FIFO output.Read should be done with 16-bit access.
                                                          8-bit read makes the FIFO to next level.32-bit read does not
                                                          make the FIFO pop operation twice. The same data is read for
                                                          both the upper 16 bits and lower 16 bits.                            */
    
    struct {
           uint32_t             :  4;
      __I  uint32_t  ChData     : 12;               /*!< CH0 conversion data FIFO                                              */
           uint32_t : 16; // padding
    } CH0_DATA_b[16];                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH1_DATA[16];                    /*!< Channel 1 conversion result data register *) Though there is
                                                         a 64-byte region ranging 0x840 to 0x87f, each address is allocated
                                                          to the same FIFO output.Read should be done with 16-bit access.
                                                          8-bit read makes the FIFO to next level.32-bit read does not
                                                          make the FIFO pop operation twice. The same data is read for
                                                          both the upper 16 bits and lower 16 bits.                            */
    
    struct {
           uint32_t             :  4;
      __I  uint32_t  ChData     : 12;               /*!< CH1 conversion data FIFO                                              */
           uint32_t : 16; // padding
    } CH1_DATA_b[16];                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH2_DATA[16];                    /*!< Channel 2 conversion result data register *) Though there is
                                                         a 64-byte region ranging 0x880 to 0x8bf, each address is allocated
                                                          to the same FIFO output.Read should be done with 16-bit access.
                                                          8-bit read makes the FIFO to next level.32-bit read does not
                                                          make the FIFO pop operation twice. The same data is read for
                                                          both the upper 16 bits and lower 16 bits.                            */
    
    struct {
           uint32_t             :  4;
      __I  uint32_t  ChData     : 12;               /*!< CH2 conversion data FIFO                                              */
           uint32_t : 16; // padding
    } CH2_DATA_b[16];                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH3_DATA[16];                    /*!< Channel 3 conversion result data register *) Though there is
                                                         a 64-byte region ranging 0x8c0 to 0x8ff, each address is allocated
                                                          to the same FIFO output.Read should be done with 16-bit access.
                                                          8-bit read makes the FIFO to next level.32-bit read does not
                                                          make the FIFO pop operation twice. The same data is read for
                                                          both the upper 16 bits and lower 16 bits.                            */
    
    struct {
           uint32_t             :  4;
      __I  uint32_t  ChData     : 12;               /*!< CH3 conversion data FIFO                                              */
           uint32_t : 16; // padding
    } CH3_DATA_b[16];                               /*!< BitSize                                                               */
  };
} adcc12_Type;


/* ================================================================================ */
/* ================                     adcc24                     ================ */
/* ================================================================================ */


/**
  * @brief adcc24 (adcc24)
  */

typedef struct {                                    /*!< adcc24 Structure                                                      */
  
  union {
    __IO uint32_t  MODESEL;                         /*!< Mode set register                                                     */
    
    struct {
      __IO uint32_t  ConvMd     :  2;               /*!< Conversion modeSets ADC conversion modes.00: SinglePerforms
                                                         conversion of a channel specified by ChSel.01: One-time scanSequentially
                                                          performs conversion for channels enabled by each channel set
                                                          register. Comes to a stop after one round of conversions. 10:
                                                          Cyclic scanSequentially performs conversion for channels enabled
                                                          by each channel set register. Repeats conversion operation until
                                                          a stop instruction is issued by a control register. 11: Reserved     */
           uint32_t             :  2;
      __IO uint32_t  FIFOMd     :  1;               /*!< FIFO modeSets the method of storing conversion data in FIFO.0:
                                                         StreamDiscards the oldest data and stores the latest data in
                                                          FIFO when FIFO is full.1: FIFO stopRetains data in FIFO and
                                                          discards the latest data when FIFO is full.                          */
           uint32_t             :  3;
      __IO uint32_t  ChSel      :  2;               /*!< Channel selectionSets the channel number that the AD conversion
                                                         is made.Used only when conversion mode is Single00: Ch001: Ch110:
                                                          Ch211: Reserved                                                      */
           uint32_t             :  2;
      __IO uint32_t  AFEMode0   :  2;               /*!< AFE mode setting Sets parameters for configurable AFE. Connected
                                                         to AFE configuration signal: CNT MODE[1:0]Please see 'Configurable
                                                          AFE' section for detail.                                             */
      __IO uint32_t  AFEMode1   : 10;               /*!< AFE mode selectionSets parameters for configurable AFE. Connected
                                                         to AFE configuration signal: CNT MODE[1:2]Please see 'Configurable
                                                          AFE' section for detail. *) These bits are used only when the
                                                          conversion mode is Single.                                           */
      __IO uint32_t  PUpToChSet :  4;               /*!< ADC PowerUp to Channel SetSets a period between ADC macro power
                                                         down release and channel set (start of conversion if ChSetToStart
                                                          setting is '0')The period is the number of cycles given by:(Settings
                                                          + 2) x reference clock*) Reference clock is 32 divisions of
                                                          ADC clocks.                                                          */
      __IO uint32_t  ChSetToStart:  4;              /*!< ADC Channel Select to Conversion StartSets a period between
                                                         ADC macro channel setting (switching) and start of conversion.The
                                                          period is the number of cycles given by:(Settings) x reference
                                                          clock*) Reference clock is 32 divisions of ADC clocks.               */
    } MODESEL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ADCCTL;                          /*!< AD conversion control register                                        */
    
    struct {
      __IO uint32_t  Start      :  1;               /*!< Start of conversionStarts ADC conversion[For read operation]0:
                                                         ADC conversion is stopped1: ADC conversion in operation[For
                                                          write operation]0: - 1: Starts AD conversionWriting '1' to this
                                                          bit starts AD conversion operation. In the Single mode and One-Time
                                                          Scan mode, this bit is automatically returned to '0' when all
                                                          of conversion operations have been completed.Writing '1' to
                                                          the Stop bit during conversion operation causes the bit to return
                                                          to '0' after conversion operation being executed has been completed. */
      __IO uint32_t  Stop       :  1;               /*!< Stop conversionForcibly stops ADC conversion operation.[For
                                                         read operation]0: ADC in operation or going to stop1: ADC conversion
                                                          is stopped[For write operation]0: - 1: Starts AD conversion
                                                          stop oepration Writing '1' to this bit can stop AD conversion.
                                                          After conversion operation being executed has been completed,
                                                          ADC comes to a stop and this bit is returned to '0'.When ADC
                                                          conversion is being stopped (Start bit is '0'), '1' cannot be
                                                          written to this bit.'0' cannot be written to this bit (Even
                                                          if '0' is writ                                                       */
           uint32_t : 30; // padding
    } ADCCTL_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ADCINTEN;                        /*!< AD conversion interrupt control register                              */
    
    struct {
      __IO uint32_t  ConvEndEn  :  1;               /*!< Conversion termination interrupt0: Disable1: Enable                   */
      __IO uint32_t  ScanEndEn  :  1;               /*!< Scan operation termination interrupt0: Disable1: Enable               */
           uint32_t             :  2;
      __IO uint32_t  CmpInt0En  :  1;               /*!< Converted value comparison 1 interrupt0: Disable1: Enable             */
      __IO uint32_t  CmpInt1En  :  1;               /*!< Converted value comparison 1 interrupt0: Disable1: Enable             */
           uint32_t : 26; // padding
    } ADCINTEN_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ADCINTSTS;                       /*!< AD conversion interrupt status register                               */
    
    struct {
      __IO uint32_t  ConvEnd    :  1;               /*!< Conversion termination interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred[For write]0: -1: Clear interrupt                   */
      __IO uint32_t  ScanEnd    :  1;               /*!< Scan operation termination interrupt[For read]0: No interrupt
                                                         occurred1: Interrupt occurred[For write]0: -1: Clear interrupt        */
           uint32_t             :  2;
      __IO uint32_t  CmpInt0    :  1;               /*!< Converted value comparison 0 interrupt[For read]0: No interrupt
                                                         occurred1: Interrupt occurred[For write]0: -1: Clear interrupt        */
      __IO uint32_t  CmpInt1    :  1;               /*!< Converted value comparison 1 interrupt[For read]0: No interrupt
                                                         occurred1: Interrupt occurred[For write]0: -1: Clear interrupt        */
           uint32_t             : 10;
      __I  uint32_t  ChInt      :  3;               /*!< Channel interruptIndicates interrupt occurrence status in each
                                                         of Ch 0 to 3. 0: No interrupt occurred1: Interrupt occurredDetails
                                                          of interrupt factors can be checked by the interrupt status
                                                          register for each channel.                                           */
           uint32_t : 13; // padding
    } ADCINTSTS_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_CTRCTL;                     /*!< Sampling timing generation counter control register                   */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  SrcSel     :  3;               /*!< Source clock selection for sampling timing generation counter
                                                         000: ADC clock001: 4 divisions of ADC clock010: 16 divisions
                                                          of ADC clock011: 64 divisions of ADC clock100: RTC clockOther
                                                          than those above: Settings prohibited                                */
           uint32_t : 25; // padding
    } SPLT_CTRCTL_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_PER;                        /*!< Sampling period setting register                                      */
    
    struct {
      __IO uint32_t  Period     : 16;               /*!< Specifies the period of sampling timing signalSet the number
                                                         of clock cycles of sampling timing generation counter. Setting
                                                          of '0x0000' is prohibited. Set values in the range from '0x0001'
                                                          to '0xffff'.                                                         */
           uint32_t : 16; // padding
    } SPLT_PER_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_WAVCFG;                     /*!< Sampling timing signal waveform setting register                      */
    
    struct {
      __IO uint32_t  CycToRise  : 16;               /*!< Specfies the time to rise of sampling timing signalSet the number
                                                         of clock cycles of sampling timing generation counter. Set values
                                                          smaller than [SPLT_PER].                                             */
           uint32_t : 16; // padding
    } SPLT_WAVCFG_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  SPLT_SYNC_WAVCFG;                /*!< Sampling timing synchronous signal waveform setting register
                                                                                                                               */
    
    struct {
      __IO uint32_t  CycToRise  : 16;               /*!< Specfies the time to rise of sampling timing synchronous signalSet
                                                         the number of clock cycles of sampling timing generation counter.
                                                          Set values smaller than [SPLT_PER].                                  */
           uint32_t : 16; // padding
    } SPLT_SYNC_WAVCFG_b;                           /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CMPDATA_0;                       /*!< Compare data setting register 0                                       */
    
    struct {
      __IO uint32_t  CmpData    : 24;               /*!< Compare dataConverted values to be stored in FIFO and the value
                                                         of this register field are compared, and an interrupt signal
                                                          is generated according to the results of comparison as to which
                                                          is greater or smaller. Comparison as to which is greater or
                                                          smaller is specified by the CmpSel bit.                              */
      __IO uint32_t  CmpCh      :  2;               /*!< Compare channel selectSelects a channel where converted values
                                                         are compared00: Ch001: Ch110: Ch211: Reserved                         */
           uint32_t             :  2;
      __IO uint32_t  CmpEn      :  1;               /*!< Compare enable0: Converted values not compared1: Converted values
                                                         compared                                                              */
      __IO uint32_t  CmpSel     :  1;               /*!< Compare mode select0: An interrupt occurs when converted values
                                                         is larger than compare data.1: An interrupt occurs when converted
                                                          values is smaller than converted values                              */
           uint32_t : 2; // padding
    } CMPDATA_0_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CMPDATA_1;                       /*!< Compare data setting register 1                                       */
    
    struct {
      __IO uint32_t  CmpData    : 24;               /*!< Same as CMPDATA_0                                                     */
      __IO uint32_t  CmpCh      :  2;               /*!< Same as CMPDATA_0                                                     */
           uint32_t             :  2;
      __IO uint32_t  CmpEn      :  1;               /*!< Same as CMPDATA_0                                                     */
      __IO uint32_t  CmpSel     :  1;               /*!< Same as CMPDATA_0                                                     */
           uint32_t : 2; // padding
    } CMPDATA_1_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[6];
  
  union {
    __IO uint32_t  EXT_CTL;                         /*!< External output signal control register                               */
    
    struct {
      __IO uint32_t  SelExt     :  2;               /*!< External output signal data selection 00: '0' is always output01:
                                                         '1' is always output10/11: Sampling timing synchronous signals
                                                          are output                                                           */
      __IO uint32_t  InvExt     :  1;               /*!< External output signal inversion select0: Not inverted1: Inverted*)
                                                         Invert/Not invert process is performed on data selected by SelExt     */
           uint32_t : 29; // padding
    } EXT_CTL_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[47];
  
  union {
    __IO uint32_t  CH0_MODE;                        /*!< Channel 0 mode setting register                                       */
    
    struct {
      __IO uint32_t  ChEn       :  1;               /*!< Channel enable Determines whether an analog input of this channel
                                                         is subjected to AD conversion. Enabled only in the One-Time
                                                          and Cyclic Scan modes. In Single mode, the channel set to [MODESEL].ChSel
                                                          are selected regardless of settings of this bit. 0: Disable1:
                                                          Enable                                                               */
      __IO uint32_t  DtFmt      :  1;               /*!< Conversion data formatSelects formats of data to be stored in
                                                         FIFO0: Unsigned integer1: Signed integer                              */
      __IO uint32_t  OfstEn     :  1;               /*!< Offset for conversion data enable0: Disable1: Enable                  */
      __IO uint32_t  DMAEn      :  1;               /*!< DMA transfer request enable0: Disable1: Enable                        */
      __IO uint32_t  DownSpl    :  3;               /*!< Down Sampling000: No down sampling (sampling done every time)001:
                                                         One sampling in two times 010: One sampling in three times...110:
                                                          One sampling in seven times111: One sampling in eight times          */
      __IO uint32_t  DMAReq     :  1;               /*!< DMA request status[For read]0: No DMA request1: DMA request
                                                         asserted[For write]0: - 1: Cancell DMA request                        */
      __IO uint32_t  WaterMark  :  4;               /*!< Watermark interrupt level countSelects the number of FIFO steps
                                                         where Watermark interrupt is generated000: 1 step001: 2 steps010:
                                                          3 steps011: 4 steps ...110: 15 steps111: 16 steps                    */
           uint32_t : 20; // padding
    } CH0_MODE_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH0_INTEN;                       /*!< Channel 0 interrupt control register                                  */
    
    struct {
      __IO uint32_t  ChEocEn    :  1;               /*!< End of Conversion interrupt0: Disable1: Enable                        */
      __IO uint32_t  WMIntEn    :  1;               /*!< Watermark interrupt0: Disable1: Enable                                */
      __IO uint32_t  FstDLostEn :  1;               /*!< 1st data lost interrupt0: Disable1: Enable                            */
      __IO uint32_t  LstDLostEn :  1;               /*!< Last data lost interrupt0: Disable1: Enable                           */
      __IO uint32_t  FIFOFullEn :  1;               /*!< FIFO full interrupt0: Disable1: Enable                                */
      __IO uint32_t  FIFOurunEn :  1;               /*!< FIFO underrun interrupt0: Disable1: Enable                            */
           uint32_t : 26; // padding
    } CH0_INTEN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH0_INTSTS;                      /*!< Channel 0 interrupt status register                                   */
    
    struct {
      __IO uint32_t  ChEoc      :  1;               /*!< Conversion completion interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred [For write]0: - 1: Clear interrupt                 */
      __IO uint32_t  WMInt      :  1;               /*!< Watermark interrupt[For read]0: No interrupt occurred1: Interrupt
                                                         occurred [For write]0: - 1: Clear interrupt                           */
      __IO uint32_t  FstDLost   :  1;               /*!< 1st data lost interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred [For write]0: - 1: Clear interrupt                 */
      __IO uint32_t  LstDLost   :  1;               /*!< Last data lost interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred [For write]0: - 1: Clear interrupt                 */
      __IO uint32_t  FIFOFull   :  1;               /*!< FIFO full interrupt[For read]0: No interrupt occurred1: Interrupt
                                                         occurred[For write]0: - 1: Clear interrupt                            */
      __IO uint32_t  FIFOurun   :  1;               /*!< FIFO underrun interrupt[For read]0: No interrupt occurred1:
                                                         Interrupt occurred[For write]0: - 1: Clear interrupt                  */
           uint32_t : 26; // padding
    } CH0_INTSTS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH0_OFFSET;                      /*!< Channel 0 conversion data offset                                      */
    
    struct {
      __IO uint32_t  Offset     :  8;               /*!< Offset data for adjusting conversion dataIf offset for conversion
                                                         data is enabled, conversrion result is added with this registers
                                                          value and then sotred to FIFO. MSB of this register is a sign
                                                          bit (i.e. calculation with conversion result is done after sign
                                                          extention). If arithmetic result is larger tha the upper limit
                                                          or smaller than lower limits of the conversion range, limit
                                                          values are stored in FIFO.                                           */
           uint32_t : 24; // padding
    } CH0_OFFSET_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH0_FIFOSTS;                     /*!< Channel 0 FIFO status                                                 */
    
    struct {
      __I  uint32_t  DataNum    :  5;               /*!< Number of pieces of data in FIFO0 to 16 word(s)                       */
           uint32_t : 27; // padding
    } CH0_FIFOSTS_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;
  
  union {
    __IO uint32_t  CH0_AFEMODE;                     /*!< Channel 0 AFE mode setting register                                   */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  Mode       : 10;               /*!< AFE mode setting Sets parameters for configurable AFE. Connected
                                                         to AFE configuration signal: CNT MODE[11:2]Please see 'Configurable
                                                          AFE' section for detail.                                             */
           uint32_t : 20; // padding
    } CH0_AFEMODE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;
  
  union {
    __IO uint32_t  CH1_MODE;                        /*!< Channel 1 mode setting register                                       */
    
    struct {
      __IO uint32_t  ChEn       :  1;               /*!< ChEn                                                                  */
      __IO uint32_t  DtFmt      :  1;               /*!< DtFmt                                                                 */
      __IO uint32_t  OfstEn     :  1;               /*!< OfstEn                                                                */
      __IO uint32_t  DMAEn      :  1;               /*!< DMAEn                                                                 */
      __IO uint32_t  DownSpl    :  3;               /*!< DownSpl                                                               */
      __IO uint32_t  DMAReq     :  1;               /*!< DMAReq                                                                */
      __IO uint32_t  WaterMark  :  4;               /*!< WaterMark                                                             */
           uint32_t : 20; // padding
    } CH1_MODE_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH1_INTEN;                       /*!< Channel 1 interrupt control register                                  */
    
    struct {
      __IO uint32_t  ChEocEn    :  1;               /*!< ChEocEn                                                               */
      __IO uint32_t  WMIntEn    :  1;               /*!< WMIntEn                                                               */
      __IO uint32_t  FstDLostEn :  1;               /*!< FstDLostEn                                                            */
      __IO uint32_t  LstDLostEn :  1;               /*!< LstDLostEn                                                            */
      __IO uint32_t  FIFOFullEn :  1;               /*!< FIFOFullEn                                                            */
      __IO uint32_t  FIFOurunEn :  1;               /*!< FIFOurunEn                                                            */
           uint32_t : 26; // padding
    } CH1_INTEN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH1_INTSTS;                      /*!< Channel 1 interrupt status register                                   */
    
    struct {
      __IO uint32_t  ChEoc      :  1;               /*!< ChEoc                                                                 */
      __IO uint32_t  WMInt      :  1;               /*!< WMInt                                                                 */
      __IO uint32_t  FstDLost   :  1;               /*!< FstDLost                                                              */
      __IO uint32_t  LstDLost   :  1;               /*!< LstDLost                                                              */
      __IO uint32_t  FIFOFull   :  1;               /*!< FIFOFull                                                              */
      __IO uint32_t  FIFOurun   :  1;               /*!< FIFOurun                                                              */
           uint32_t : 26; // padding
    } CH1_INTSTS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH1_OFFSET;                      /*!< Channel 1 conversion data offset                                      */
    
    struct {
      __IO uint32_t  Offset     :  8;               /*!< Offset                                                                */
           uint32_t : 24; // padding
    } CH1_OFFSET_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH1_FIFOSTS;                     /*!< Channel 1 FIFO status                                                 */
    
    struct {
      __I  uint32_t  DataNum    :  5;               /*!< DataNum                                                               */
           uint32_t : 27; // padding
    } CH1_FIFOSTS_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4;
  
  union {
    __IO uint32_t  CH1_AFEMODE;                     /*!< Channel 1 AFE mode setting register                                   */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  Mode       : 10;               /*!< Mode                                                                  */
           uint32_t : 20; // padding
    } CH1_AFEMODE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5;
  
  union {
    __IO uint32_t  CH2_MODE;                        /*!< Channel 2 mode setting register                                       */
    
    struct {
      __IO uint32_t  ChEn       :  1;               /*!< ChEn                                                                  */
      __IO uint32_t  DtFmt      :  1;               /*!< DtFmt                                                                 */
      __IO uint32_t  OfstEn     :  1;               /*!< OfstEn                                                                */
      __IO uint32_t  DMAEn      :  1;               /*!< DMAEn                                                                 */
      __IO uint32_t  DownSpl    :  3;               /*!< DownSpl                                                               */
      __IO uint32_t  DMAReq     :  1;               /*!< DMAReq                                                                */
      __IO uint32_t  WaterMark  :  4;               /*!< WaterMark                                                             */
           uint32_t : 20; // padding
    } CH2_MODE_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH2_INTEN;                       /*!< Channel 2 interrupt control register                                  */
    
    struct {
      __IO uint32_t  ChEocEn    :  1;               /*!< ChEocEn                                                               */
      __IO uint32_t  WMIntEn    :  1;               /*!< WMIntEn                                                               */
      __IO uint32_t  FstDLostEn :  1;               /*!< FstDLostEn                                                            */
      __IO uint32_t  LstDLostEn :  1;               /*!< LstDLostEn                                                            */
      __IO uint32_t  FIFOFullEn :  1;               /*!< FIFOFullEn                                                            */
      __IO uint32_t  FIFOurunEn :  1;               /*!< FIFOurunEn                                                            */
           uint32_t : 26; // padding
    } CH2_INTEN_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH2_INTSTS;                      /*!< Channel 2 interrupt status register                                   */
    
    struct {
      __IO uint32_t  ChEoc      :  1;               /*!< ChEoc                                                                 */
      __IO uint32_t  WMInt      :  1;               /*!< WMInt                                                                 */
      __IO uint32_t  FstDLost   :  1;               /*!< FstDLost                                                              */
      __IO uint32_t  LstDLost   :  1;               /*!< LstDLost                                                              */
      __IO uint32_t  FIFOFull   :  1;               /*!< FIFOFull                                                              */
      __IO uint32_t  FIFOurun   :  1;               /*!< FIFOurun                                                              */
           uint32_t : 26; // padding
    } CH2_INTSTS_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CH2_OFFSET;                      /*!< Channel 2 conversion data offset                                      */
    
    struct {
      __IO uint32_t  Offset     :  8;               /*!< Offset                                                                */
           uint32_t : 24; // padding
    } CH2_OFFSET_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH2_FIFOSTS;                     /*!< Channel 2 FIFO status                                                 */
    
    struct {
      __I  uint32_t  DataNum    :  5;               /*!< DataNum                                                               */
           uint32_t : 27; // padding
    } CH2_FIFOSTS_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6;
  
  union {
    __IO uint32_t  CH2_AFEMODE;                     /*!< Channel 2 AFE mode setting register                                   */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  Mode       : 10;               /*!< Mode                                                                  */
           uint32_t : 20; // padding
    } CH2_AFEMODE_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7[425];
  
  union {
    __I  uint32_t  CH0_DATA[16];                    /*!< Channel 0 conversion result data register *) Though there is
                                                         a 64-byte region ranging 0x800 to 0x83f, each address is allocated
                                                          to the same FIFO output.Read should be done with 32-bit access.
                                                          8-bit/16bit read makes the FIFO to next level.                       */
    
    struct {
      __I  uint32_t  ChData     : 24;               /*!< CH0 conversion data FIFO                                              */
      __I  uint32_t  ChDataSign :  8;               /*!< ChDataSign                                                            */
    } CH0_DATA_b[16];                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH1_DATA[16];                    /*!< Channel 1 conversion result data register *) Though there is
                                                         a 64-byte region ranging 0x840 to 0x87f, each address is allocated
                                                          to the same FIFO output.Read should be done with 32-bit access.
                                                          8-bit/16bit read makes the FIFO to next level.                       */
    
    struct {
      __I  uint32_t  ChData     : 24;               /*!< CH1 conversion data FIFO                                              */
      __I  uint32_t  ChDataSign :  8;               /*!< ChDataSign                                                            */
    } CH1_DATA_b[16];                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CH2_DATA[16];                    /*!< Channel 2 conversion result data register *) Though there is
                                                         a 64-byte region ranging 0x880 to 0x8bf, each address is allocated
                                                          to the same FIFO output.Read should be done with 32-bit access.
                                                          8-bit/16bit read makes the FIFO to next level.                       */
    
    struct {
      __I  uint32_t  ChData     : 24;               /*!< CH2 conversion data FIFO                                              */
      __I  uint32_t  ChDataSign :  8;               /*!< ChDataSign                                                            */
    } CH2_DATA_b[16];                               /*!< BitSize                                                               */
  };
} adcc24_Type;


/* ================================================================================ */
/* ================                      gconf                     ================ */
/* ================================================================================ */


/**
  * @brief gconf (gconf)
  */

typedef struct {                                    /*!< gconf Structure                                                       */
  
  union {
    __IO uint32_t  TMR_TIMCLKEN;                    /*!< TMR_TIMCLKEN                                                          */
    
    struct {
      __IO uint32_t  TMR_TIMCLKEN0:  1;             /*!< tmr clock enable 01: Enable 0: Disable                                */
      __IO uint32_t  TMR_TIMCLKEN1:  1;             /*!< tmr clock enable 11: Enable 0: Disable                                */
           uint32_t : 30; // padding
    } TMR_TIMCLKEN_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  ADVTMR_TIMCLKEN;                 /*!< ADVTMR_TIMCLKEN                                                       */
    
    struct {
      __IO uint32_t  ADVTMR_T0TIMCLKEN:  1;         /*!< advtmr clock enable 01: Enable 0: Disable                             */
      __IO uint32_t  ADVTMR_T1TIMCLKEN:  1;         /*!< advtmr clock enable 11: Enable 0: Disable                             */
      __IO uint32_t  ADVTMR_T2TIMCLKEN:  1;         /*!< advtmr clock enable 21: Enable 0: Disable                             */
      __IO uint32_t  ADVTMR_T3TIMCLKEN:  1;         /*!< advtmr clock enable 31: Enable 0: Disable                             */
           uint32_t : 28; // padding
    } ADVTMR_TIMCLKEN_b;                            /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[2];
  
  union {
    __IO uint32_t  WDT_WDTCLKEN;                    /*!< WDT_WDTCLKEN                                                          */
    
    struct {
      __IO uint32_t  WDT_WDTCLKEN:  1;              /*!< wdt clock enable1: Enable 0: Disable                                  */
           uint32_t : 31; // padding
    } WDT_WDTCLKEN_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];
  
  union {
    __I  uint32_t  I2C0_STAT;                       /*!< I2C0_STAT                                                             */
    
    struct {
      __I  uint32_t  I2C0_SLV_CSTATE:  4;           /*!< i2c0 status (slave status)This bit indicates whether I2C0 is
                                                         active in the Slave Mode.Except 0x00 : I2C0 is active.0x00 :
                                                          I2C0 is idle.                                                        */
      __I  uint32_t  I2C0_MST_CSTATE:  5;           /*!< i2c0 status (master status)This bit indicates whether I2C0 is
                                                         active in the Master Mode.Except 0x00 : I2C0 is active.0x00
                                                          : I2C0 is idle.                                                      */
           uint32_t             :  3;
      __I  uint32_t  I2C0_SLAVE_ACT:  1;            /*!< i2c0 status (slave active status)This bit indicates whether
                                                         I2C0 is active in the Slave Mode.1 : I2C0 is active.0 : I2C0
                                                          is not active.                                                       */
      __I  uint32_t  I2C0_MASTER_ACT:  1;           /*!< i2c0 status (master active status)This bit indicates whether
                                                         I2C0 is active in the Master Mode.1 : I2C0 is active.0 : I2C0
                                                          is not active.                                                       */
           uint32_t             :  2;
      __I  uint32_t  I2C0_WR    :  1;               /*!< i2c0 status (i2c write status)This bit indicates whether I2C0
                                                         is in a write transaction on the I2C bus in the Master Mode.1
                                                          : I2C0 is in a write transaction.0 : I2C0 is not in a write
                                                          transaction.                                                         */
      __I  uint32_t  I2C0_RD    :  1;               /*!< i2c0 status (i2c read status)This bit indicates whether I2C0
                                                         is in a read transaction on the I2C bus in the Master Mode.1
                                                          : I2C0 is in a read transaction.0 : I2C0 is not in a read transaction. */
           uint32_t             :  2;
      __I  uint32_t  I2C0_ADDR  :  1;               /*!< i2c0 status (address communication period)This bit indicates
                                                         whether I2C0 is in the address phase on the I2C bus.1 : I2C0
                                                          is in the address phase.0 : I2C0 is not in the address phase.        */
      __I  uint32_t  I2C0_DATA  :  1;               /*!< i2c0 status (data communication period)This bit indicates whether
                                                         I2C0 is in the data phase on the I2C bus.1 : I2C0 is in the
                                                          data phase.0 : I2C0 is not in the data phase.                        */
           uint32_t             :  2;
      __I  uint32_t  I2C0_P_GEN :  1;               /*!< i2c0 status (stop condition period)This bit indicates whether
                                                         I2C0 is generating a STOP Condition on the I2C bus in the Master
                                                          Mode.1 : I2C0 is generating a STOP Condition.0 : I2C0 is not
                                                          generating a STOP Condition.                                         */
      __I  uint32_t  I2C0_S_GEN :  1;               /*!< i2c0 status (start condition period)This bit indicates whether
                                                         I2C0 is generating a START Condition on the I2C bus in the Master
                                                          Mode.1 : I2C0 is generating a START Condition.0 : I2C0 is not
                                                          generating a START Condition.                                        */
           uint32_t             :  2;
      __I  uint32_t  I2C0_IC_EN :  1;               /*!< i2c0 status (i2c enable)[I2C0_IC_ENABLE].ENABLE bit is indicated.1
                                                         : I2C0 is enabled.0 : I2C0 is disabled.                               */
           uint32_t : 3; // padding
    } I2C0_STAT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  I2C1_STAT;                       /*!< I2C1_STAT                                                             */
    
    struct {
      __I  uint32_t  I2C1_SLV_CSTATE:  4;           /*!< i2c1 status (slave status)This bit indicates whether I2C1 is
                                                         active in the Slave Mode.Except 0x00 : I2C1 is active.0x00 :
                                                          I2C1 is idle.                                                        */
      __I  uint32_t  I2C1_MST_CSTATE:  5;           /*!< i2c1 status (master status)This bit indicates whether I2C1 is
                                                         active in the Master Mode.Except 0x00 : I2C1 is active.0x00
                                                          : I2C1 is idle.                                                      */
           uint32_t             :  3;
      __I  uint32_t  I2C1_SLAVE_ACT:  1;            /*!< i2c1 status (slave active status)This bit indicates whether
                                                         I2C1 is active in the Slave Mode.1 : I2C1 is active.0 : I2C1
                                                          is not active.                                                       */
      __I  uint32_t  I2C1_MASTER_ACT:  1;           /*!< i2c1 status (master active status)This bit indicates whether
                                                         I2C1 is active in the Master Mode.1 : I2C1 is active.0 : I2C1
                                                          is not active.                                                       */
           uint32_t             :  2;
      __I  uint32_t  I2C1_WR    :  1;               /*!< i2c1 status (i2c write status)This bit indicates whether I2C1
                                                         is in a write transaction on the I2C bus in the Master Mode.1
                                                          : I2C1 is in a write transaction.0 : I2C1 is not in a write
                                                          transaction.                                                         */
      __I  uint32_t  I2C1_RD    :  1;               /*!< i2c1 status (i2c read status)This bit indicates whether I2C1
                                                         is in a read transaction on the I2C bus in the Master Mode.1
                                                          : I2C1 is in a read transaction.0 : I2C1 is not in a read transaction. */
           uint32_t             :  2;
      __I  uint32_t  I2C1_ADDR  :  1;               /*!< i2c1 status (address communication period)This bit indicates
                                                         whether I2C1 is in the address phase on the I2C bus.1 : I2C1
                                                          is in the address phase.0 : I2C1 is not in the address phase.        */
      __I  uint32_t  I2C1_DATA  :  1;               /*!< i2c1 status (data communication period)This bit indicates whether
                                                         I2C1 is in the data phase on the I2C bus.1 : I2C1 is in the
                                                          data phase.0 : I2C1 is not in the data phase.                        */
           uint32_t             :  2;
      __I  uint32_t  I2C1_P_GEN :  1;               /*!< i2c1 status (stop condition period)This bit indicates whether
                                                         I2C1 is generating a STOP Condition on the I2C bus in the Master
                                                          Mode.1 : I2C1 is generating a STOP Condition.0 : I2C1 is not
                                                          generating a STOP Condition.                                         */
      __I  uint32_t  I2C1_S_GEN :  1;               /*!< i2c1 status (start condition period)This bit indicates whether
                                                         I2C1 is generating a START Condition on the I2C bus in the Master
                                                          Mode.1 : I2C1 is generating a START Condition.0 : I2C1 is not
                                                          generating a START Condition.                                        */
           uint32_t             :  2;
      __I  uint32_t  I2C1_IC_EN :  1;               /*!< i2c1 status (i2c enable)[I2C1_IC_ENABLE].ENABLE bit is indicated.1
                                                         : I2C1 is enabled.0 : I2C1 is disabled.                               */
           uint32_t : 3; // padding
    } I2C1_STAT_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  I2C2_STAT;                       /*!< I2C2_STAT                                                             */
    
    struct {
      __I  uint32_t  I2C2_SLV_CSTATE:  4;           /*!< i2c2 status (slave status)This bit indicates whether I2C2 is
                                                         active in the Slave Mode.Except 0x00 : I2C2 is active.0x00 :
                                                          I2C2 is idle.                                                        */
      __I  uint32_t  I2C2_MST_CSTATE:  5;           /*!< i2c2 status (master status)This bit indicates whether I2C2 is
                                                         active in the Master Mode.Except 0x00 : I2C2 is active.0x00
                                                          : I2C2 is idle.                                                      */
           uint32_t             :  3;
      __I  uint32_t  I2C2_SLAVE_ACT:  1;            /*!< i2c2 status (slave active status)This bit indicates whether
                                                         I2C2 is active in the Slave Mode.1 : I2C2 is active.0 : I2C2
                                                          is not active.                                                       */
      __I  uint32_t  I2C2_MASTER_ACT:  1;           /*!< i2c2 status (master active status)This bit indicates whether
                                                         I2C2 is active in the Master Mode.1 : I2C2 is active.0 : I2C2
                                                          is not active.                                                       */
           uint32_t             :  2;
      __I  uint32_t  I2C2_WR    :  1;               /*!< i2c2 status (i2c write status)This bit indicates whether I2C2
                                                         is in a write transaction on the I2C bus in the Master Mode.1
                                                          : I2C2 is in a write transaction.0 : I2C2 is not in a write
                                                          transaction.                                                         */
      __I  uint32_t  I2C2_RD    :  1;               /*!< i2c2 status (i2c read status)This bit indicates whether I2C2
                                                         is in a read transaction on the I2C bus in the Master Mode.1
                                                          : I2C2 is in a read transaction.0 : I2C2 is not in a read transaction. */
           uint32_t             :  2;
      __I  uint32_t  I2C2_ADDR  :  1;               /*!< i2c2 status (address communication period)This bit indicates
                                                         whether I2C2 is in the address phase on the I2C bus.1 : I2C2
                                                          is in the address phase.0 : I2C2 is not in the address phase.        */
      __I  uint32_t  I2C2_DATA  :  1;               /*!< i2c2 status (data communication period)This bit indicates whether
                                                         I2C2 is in the data phase on the I2C bus.1 : I2C2 is in the
                                                          data phase.0 : I2C2 is not in the data phase.                        */
           uint32_t             :  2;
      __I  uint32_t  I2C2_P_GEN :  1;               /*!< i2c2 status (stop condition period)This bit indicates whether
                                                         I2C2 is generating a STOP Condition on the I2C bus in the Master
                                                          Mode.1 : I2C2 is generating a STOP Condition.0 : I2C2 is not
                                                          generating a STOP Condition.                                         */
      __I  uint32_t  I2C2_S_GEN :  1;               /*!< i2c2 status (start condition period)This bit indicates whether
                                                         I2C2 is generating a START Condition on the I2C bus in the Master
                                                          Mode.1 : I2C2 is generating a START Condition.0 : I2C2 is not
                                                          generating a START Condition.                                        */
           uint32_t             :  2;
      __I  uint32_t  I2C2_IC_EN :  1;               /*!< i2c2 status (i2c enable)[I2C2_IC_ENABLE].ENABLE bit is indicated.1
                                                         : I2C2 is enabled.0 : I2C2 is disabled.                               */
           uint32_t : 3; // padding
    } I2C2_STAT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;
  
  union {
    __I  uint32_t  SPIM0_SLEEP;                     /*!< SPIM0_SLEEP                                                           */
    
    struct {
      __I  uint32_t  SPIM0_SLEEP:  1;               /*!< spim0 sleep status1: Sleep 0: In operation                            */
           uint32_t : 31; // padding
    } SPIM0_SLEEP_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  SPIM1_SLEEP;                     /*!< SPIM1_SLEEP                                                           */
    
    struct {
      __I  uint32_t  SPIM1_SLEEP:  1;               /*!< spim1 sleep status1: Sleep 0: In operation                            */
           uint32_t : 31; // padding
    } SPIM1_SLEEP_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  SPIM2_SLEEP;                     /*!< SPIM2_SLEEP                                                           */
    
    struct {
      __I  uint32_t  SPIM2_SLEEP:  1;               /*!< spim2 sleep status1: Sleep 0: In operation                            */
           uint32_t : 31; // padding
    } SPIM2_SLEEP_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  SPIM3_SLEEP;                     /*!< SPIM3_SLEEP                                                           */
    
    struct {
      __I  uint32_t  SPIM3_SLEEP:  1;               /*!< spim3 sleep status1: Sleep 0: In operation                            */
           uint32_t : 31; // padding
    } SPIM3_SLEEP_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL0;                    /*!< DMACREQ_SEL0                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL0:  6;              /*!< DMAC request signal selection (ch0)dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35.dma_finish: Set in the range of
                                                          24 to 31.In any setting value other than above, the request
                                                          signal (dma_req, dma_single) and response signal (dma_ack, dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL1;                    /*!< DMACREQ_SEL1                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL1:  6;              /*!< DMAC request signal selection (ch1)dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35.dma_finish: Set in the range of
                                                          24 to 31.In any setting value other than above, the request
                                                          signal (dma_req, dma_single) and response signal (dma_ack, dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL2;                    /*!< DMACREQ_SEL2                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL2:  6;              /*!< DMAC request signal selection (ch2)dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35.dma_finish: Set in the range of
                                                          24 to 31.In any setting value other than above, the request
                                                          signal (dma_req, dma_single) and response signal (dma_ack, dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL3;                    /*!< DMACREQ_SEL3                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL3:  6;              /*!< DMAC request signal selection (ch3)dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35.dma_finish: Set in the range of
                                                          24 to 31.In any setting value other than above, the request
                                                          signal (dma_req , dma_single) and response signal (dma_ack,dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL3_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL4;                    /*!< DMACREQ_SEL4                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL4:  6;              /*!< DMAC request signal selection (ch4) dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35. dma_finish: Set in the range of
                                                          24 to 31. In any setting value other than above, the request
                                                          signal (dma_req, dma_single) and response signal (dma_ack, dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL4_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL5;                    /*!< DMACREQ_SEL5                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL5:  6;              /*!< DMAC request signal selection (ch5) dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35. dma_finish: Set in the range of
                                                          24 to 31. In any setting value other than above, the request
                                                          signal (dma_req, dma_single) and response signal (dma_ack, dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL5_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL6;                    /*!< DMACREQ_SEL6                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL6:  6;              /*!< DMAC request signal selection (ch6) dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35. dma_finish: Set in the range of
                                                          24 to 31. In any setting value other than above, the request
                                                          signal (dma_req, dma_single) and response signal (dma_ack, dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL6_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DMACREQ_SEL7;                    /*!< DMACREQ_SEL7                                                          */
    
    struct {
      __IO uint32_t  DMACREQ_SEL7:  6;              /*!< DMAC request signal selection (ch7) dma_req, dma_single, dma_ack:
                                                         Set in the range of 0 to 35. dma_finish: Set in the range of
                                                          24 to 31. In any setting value other than above, the request
                                                          signal (dma_req, dma_single) and response signal (dma_ack, dma_finish)
                                                          cannot be used.                                                      */
           uint32_t : 26; // padding
    } DMACREQ_SEL7_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[8];
  
  union {
    __IO uint32_t  USB_FSIO_TUNE;                   /*!< USB_FSIO_TUNE                                                         */
    
    struct {
      __IO uint32_t  FSIO_RFM   :  8;               /*!< USB FSIO Crosspoint adjustment (set our specification value.)         */
      __IO uint32_t  FSIO_XP    :  8;               /*!< USB FSIO Tr/T adjustment (set our specification value.)               */
           uint32_t : 16; // padding
    } USB_FSIO_TUNE_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  USB_FSIO_CONFIG;                 /*!< USB_FSIO_CONFIG                                                       */
    
    struct {
      __IO uint32_t  FSIO_PDCONP:  1;               /*!< USB FSIO DP terminal Pull-Down setting (do not change the initial
                                                         value.)                                                               */
      __IO uint32_t  FSIO_PUCONP1:  1;              /*!< USB FSIO DP terminal Pull-Up setting 1 (do not change the initial
                                                         value.)                                                               */
      __IO uint32_t  FSIO_PUCONP2:  1;              /*!< USB FSIO DP terminal Pull-Up setting 2 (do not change the initial
                                                         value.)                                                               */
      __IO uint32_t  FSIO_PDCONM:  1;               /*!< USB FSIO DM terminal Pull-Down setting (do not change the initial
                                                         value.)                                                               */
      __IO uint32_t  FSIO_PUCONM1:  1;              /*!< USB FSIO DM terminal Pull-Up setting 1 (do not change the initial
                                                         value.)                                                               */
      __IO uint32_t  FSIO_PUCONM2:  1;              /*!< USB FSIO DM terminal Pull-Up setting 2 (do not change the initial
                                                         value.)                                                               */
           uint32_t             :  2;
      __IO uint32_t  FSIO_BYPASS_DIS:  1;           /*!< USB FSIO series resistance ON (do not change the initial value.)      */
      __IO uint32_t  FSIO_PROT_DIS:  1;             /*!< USB FSIO 5V protect DISABLE (do not change the initial value.)        */
           uint32_t : 22; // padding
    } USB_FSIO_CONFIG_b;                            /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[14];
  
  union {
    __IO uint32_t  CPU_STCALIB;                     /*!< CPU_STCALIB                                                           */
    
    struct {
      __IO uint32_t  CPU_STCALIB: 26;               /*!< System Tick calibrationCPU [SYST_CALIB] register is set up by
                                                         this register.[25] : [SYST_CALIB].NOREF[24] : [SYST_CALIB].SKEW[23:0]
                                                          : [SYST_CALIB].TENMS                                                 */
           uint32_t : 6; // padding
    } CPU_STCALIB_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CPU_TSENABLE;                    /*!< CPU_TSENABLE                                                          */
    
    struct {
      __IO uint32_t  CPU_TSENABLE:  1;              /*!< Time Stamp count enableControl of the time stamp counter (48bit)
                                                         of CPU Trace.It is counted by CPU HCLK.1 : Count Enable0 : Count
                                                          Disable                                                              */
           uint32_t : 31; // padding
    } CPU_TSENABLE_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5;
  
  union {
    __IO uint32_t  CPU_FPUIRQEN;                    /*!< CPU_FPUIRQEN                                                          */
    
    struct {
      __IO uint32_t  CPU_FPUIOE :  1;               /*!< FPU IOC(Invalid Operation cumulative) Exception Interrupt Enable1:
                                                         Interrupt Enable0: Interrupt Disable                                  */
      __IO uint32_t  CPU_FPUDZE :  1;               /*!< FPU DZC (Division by Zero cumulative) Exception Interrupt Enable1:
                                                         Interrupt Enable0: Interrupt Disable                                  */
      __IO uint32_t  CPU_FPUOFE :  1;               /*!< FPU OFC (Overflow cumulative) Exception Interrupt Enable1: Interrupt
                                                         Enable0: Interrupt Disable                                            */
      __IO uint32_t  CPU_FPUUFE :  1;               /*!< FPU UFC (Underflow cumulative) Exception Interrupt Enable1:
                                                         Interrupt Enable0: Interrupt Disable                                  */
      __IO uint32_t  CPU_FPUIXE :  1;               /*!< FPU IXC (Inexact cumulative) Exception Interrupt Enable1: Interrupt
                                                         Enable0: Interrupt Disable                                            */
           uint32_t             :  2;
      __IO uint32_t  CPU_FPUIDE :  1;               /*!< FPU IDC (Input Denormal cumulative) Exception Interrupt Enable1:
                                                         Interrupt Enable0: Interrupt Disable                                  */
           uint32_t : 24; // padding
    } CPU_FPUIRQEN_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CPU_DEBUGIN;                     /*!< CPU_DEBUGIN                                                           */
    
    struct {
      __IO uint32_t  CPU_DEBUGIN:  1;               /*!< Debugger detection1: Enable 0: Disable                                */
           uint32_t : 31; // padding
    } CPU_DEBUGIN_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[7];
  
  union {
    __IO uint32_t  CPU_DFT;                         /*!< CPU_DFT                                                               */
    
    struct {
      __IO uint32_t  CPU_CGBYPASS:  1;              /*!< Writable when WRITE_PROT=0                                            */
      __IO uint32_t  CPU_RSTBYPASS:  1;             /*!< Writable when WRITE_PROT=0                                            */
      __IO uint32_t  CPU_SE     :  1;               /*!< Writable when WRITE_PROT=0                                            */
           uint32_t : 29; // padding
    } CPU_DFT_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  CPU_CONFENABLE;                  /*!< CPU_CONFENABLE                                                        */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  CPU_FPUDISABLE:  1;            /*!< Writable when WRITE_PROT=0                                            */
      __IO uint32_t  CPU_MPUDISABLE:  1;            /*!< Writable when WRITE_PROT=0                                            */
           uint32_t : 29; // padding
    } CPU_CONFENABLE_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7;
  
  union {
    __IO uint32_t  CPU_WRITE_PROT;                  /*!< CPU_WRITE_PROT                                                        */
    
    struct {
      __IO uint32_t  CPU_WRITE_PROT: 32;            /*!< 32h4547_c2a3 writing sets WRITE_PROT=132hd123_4744 writing sets
                                                         WRITE_PROT=0                                                          */
    } CPU_WRITE_PROT_b;                             /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG0;                         /*!< IO_CFG0                                                               */
    
    struct {
           uint32_t             :  4;
      __IO uint32_t  GPIO_1_ENPUD:  1;              /*!< MCU_GPIO_1 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_1_PUD :  1;               /*!< MCU_GPIO_1 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_1_CTL1:  1;               /*!< MCU_GPIO_1 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_1_CTL2:  1;               /*!< MCU_GPIO_1 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_2_ENPUD:  1;              /*!< MCU_GPIO_2 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_2_PUD :  1;               /*!< MCU_GPIO_2 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_2_CTL1:  1;               /*!< MCU_GPIO_2 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_2_CTL2:  1;               /*!< MCU_GPIO_2 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_3_ENPUD:  1;              /*!< MCU_GPIO_3 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_3_PUD :  1;               /*!< MCU_GPIO_3 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_3_CTL1:  1;               /*!< MCU_GPIO_3 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_3_CTL2:  1;               /*!< MCU_GPIO_3 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_4_ENPUD:  1;              /*!< MCU_GPIO_4 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_4_PUD :  1;               /*!< MCU_GPIO_4 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_4_CTL1:  1;               /*!< MCU_GPIO_4 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_4_CTL2:  1;               /*!< MCU_GPIO_4 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_5_ENPUD:  1;              /*!< MCU_GPIO_5 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_5_PUD :  1;               /*!< MCU_GPIO_5 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_5_CTL1:  1;               /*!< MCU_GPIO_5 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_5_CTL2:  1;               /*!< MCU_GPIO_5 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_6_ENPUD:  1;              /*!< MCU_GPIO_6 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_6_PUD :  1;               /*!< MCU_GPIO_6 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_6_CTL1:  1;               /*!< MCU_GPIO_6 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_6_CTL2:  1;               /*!< MCU_GPIO_6 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_7_ENPUD:  1;              /*!< MCU_GPIO_7 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_7_PUD :  1;               /*!< MCU_GPIO_7 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_7_CTL1:  1;               /*!< MCU_GPIO_7 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_7_CTL2:  1;               /*!< MCU_GPIO_7 IO cell CTL2 setting                                       */
    } IO_CFG0_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG1;                         /*!< IO_CFG1                                                               */
    
    struct {
      __IO uint32_t  GPIO_8_ENPUD:  1;              /*!< MCU_GPIO_8 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_8_PUD :  1;               /*!< MCU_GPIO_8 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_8_CTL1:  1;               /*!< MCU_GPIO_8 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_8_CTL2:  1;               /*!< MCU_GPIO_8 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_9_ENPUD:  1;              /*!< MCU_GPIO_9 IO cell ENPUD setting                                      */
      __IO uint32_t  GPIO_9_PUD :  1;               /*!< MCU_GPIO_9 IO cell PUD setting                                        */
      __IO uint32_t  GPIO_9_CTL1:  1;               /*!< MCU_GPIO_9 IO cell CTL1 setting                                       */
      __IO uint32_t  GPIO_9_CTL2:  1;               /*!< MCU_GPIO_9 IO cell CTL2 setting                                       */
      __IO uint32_t  GPIO_10_ENPUD:  1;             /*!< MCU_GPIO_10 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_10_PUD:  1;               /*!< MCU_GPIO_10 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_10_CTL1:  1;              /*!< MCU_GPIO_10 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_10_CTL2:  1;              /*!< MCU_GPIO_10 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_11_ENPUD:  1;             /*!< MCU_GPIO_11 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_11_PUD:  1;               /*!< MCU_GPIO_11 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_11_CTL1:  1;              /*!< MCU_GPIO_11 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_11_CTL2:  1;              /*!< MCU_GPIO_11 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_12_ENPUD:  1;             /*!< MCU_GPIO_12 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_12_PUD:  1;               /*!< MCU_GPIO_12 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_12_CTL1:  1;              /*!< MCU_GPIO_12 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_12_CTL2:  1;              /*!< MCU_GPIO_12 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_13_ENPUD:  1;             /*!< MCU_GPIO_13 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_13_PUD:  1;               /*!< MCU_GPIO_13 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_13_CTL1:  1;              /*!< MCU_GPIO_13 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_13_CTL2:  1;              /*!< MCU_GPIO_13 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_14_ENPUD:  1;             /*!< MCU_GPIO_14 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_14_PUD:  1;               /*!< MCU_GPIO_14 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_14_CTL1:  1;              /*!< MCU_GPIO_14 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_14_CTL2:  1;              /*!< MCU_GPIO_14 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_15_ENPUD:  1;             /*!< MCU_GPIO_15 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_15_PUD:  1;               /*!< MCU_GPIO_15 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_15_CTL1:  1;              /*!< MCU_GPIO_15 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_15_CTL2:  1;              /*!< MCU_GPIO_15 IO cell CTL2 setting                                      */
    } IO_CFG1_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  IO_CFG2;                           /*!< IO_CFG2                                                               */
  
  union {
    __IO uint32_t  IO_CFG3;                         /*!< IO_CFG3                                                               */
    
    struct {
      __IO uint32_t  GPIO_24_ENPUD:  1;             /*!< MCU_GPIO_24 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_24_PUD:  1;               /*!< MCU_GPIO_24 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_24_CTL1:  1;              /*!< MCU_GPIO_24 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_24_CTL2:  1;              /*!< MCU_GPIO_24 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_25_ENPUD:  1;             /*!< MCU_GPIO_25 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_25_PUD:  1;               /*!< MCU_GPIO_25 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_25_CTL1:  1;              /*!< MCU_GPIO_25 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_25_CTL2:  1;              /*!< MCU_GPIO_25 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_26_ENPUD:  1;             /*!< MCU_GPIO_26 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_26_PUD:  1;               /*!< MCU_GPIO_26 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_26_CTL1:  1;              /*!< MCU_GPIO_26 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_26_CTL2:  1;              /*!< MCU_GPIO_26 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_27_ENPUD:  1;             /*!< MCU_GPIO_27 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_27_PUD:  1;               /*!< MCU_GPIO_27 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_27_CTL1:  1;              /*!< MCU_GPIO_27 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_27_CTL2:  1;              /*!< MCU_GPIO_27 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_28_ENPUD:  1;             /*!< MCU_GPIO_28 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_28_PUD:  1;               /*!< MCU_GPIO_28 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_28_CTL1:  1;              /*!< MCU_GPIO_28 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_28_CTL2:  1;              /*!< MCU_GPIO_28 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_29_ENPUD:  1;             /*!< MCU_GPIO_29 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_29_PUD:  1;               /*!< MCU_GPIO_29 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_29_CTL1:  1;              /*!< MCU_GPIO_29 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_29_CTL2:  1;              /*!< MCU_GPIO_29 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_30_ENPUD:  1;             /*!< MCU_GPIO_30 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_30_PUD:  1;               /*!< MCU_GPIO_30 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_30_CTL1:  1;              /*!< MCU_GPIO_30 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_30_CTL2:  1;              /*!< MCU_GPIO_30 IO cell CTL2 setting                                      */
      __IO uint32_t  GPIO_31_ENPUD:  1;             /*!< MCU_GPIO_31 IO cell ENPUD setting                                     */
      __IO uint32_t  GPIO_31_PUD:  1;               /*!< MCU_GPIO_31 IO cell PUD setting                                       */
      __IO uint32_t  GPIO_31_CTL1:  1;              /*!< MCU_GPIO_31 IO cell CTL1 setting                                      */
      __IO uint32_t  GPIO_31_CTL2:  1;              /*!< MCU_GPIO_31 IO cell CTL2 setting                                      */
    } IO_CFG3_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG4;                         /*!< IO_CFG4                                                               */
    
    struct {
      __IO uint32_t  I2C0_DATA_ENPUD:  1;           /*!< MCU_I2C0_DATA IO cell ENPUD setting                                   */
      __IO uint32_t  I2C0_DATA_PUD:  1;             /*!< MCU_I2C0_DATA IO cell PUD setting                                     */
      __IO uint32_t  I2C0_DATA_CTL1:  1;            /*!< MCU_I2C0_DATA IO cell CTL1 setting                                    */
      __IO uint32_t  I2C0_DATA_CTL2:  1;            /*!< MCU_I2C0_DATA IO cell CTL2 setting                                    */
      __IO uint32_t  I2C0_CLK_ENPUD:  1;            /*!< MCU_I2C0_CLK IO cell ENPUD setting                                    */
      __IO uint32_t  I2C0_CLK_PUD:  1;              /*!< MCU_I2C0_CLK IO cell PUD setting                                      */
      __IO uint32_t  I2C0_CLK_CTL1:  1;             /*!< MCU_I2C0_CLK IO cell CTL1 setting                                     */
      __IO uint32_t  I2C0_CLK_CTL2:  1;             /*!< MCU_I2C0_CLK IO cell CTL2 setting                                     */
      __IO uint32_t  I2C1_DATA_ENPUD:  1;           /*!< MCU_I2C1_DATA IO cell ENPUD setting                                   */
      __IO uint32_t  I2C1_DATA_PUD:  1;             /*!< MCU_I2C1_DATA IO cell PUD setting                                     */
      __IO uint32_t  I2C1_DATA_CTL1:  1;            /*!< MCU_I2C1_DATA IO cell CTL1 setting                                    */
      __IO uint32_t  I2C1_DATA_CTL2:  1;            /*!< MCU_I2C1_DATA IO cell CTL2 setting                                    */
      __IO uint32_t  I2C1_CLK_ENPUD:  1;            /*!< MCU_I2C1_CLK IO cell ENPUD setting                                    */
      __IO uint32_t  I2C1_CLK_PUD:  1;              /*!< MCU_I2C1_CLK IO cell PUD setting                                      */
      __IO uint32_t  I2C1_CLK_CTL1:  1;             /*!< MCU_I2C1_CLK IO cell CTL1 setting                                     */
      __IO uint32_t  I2C1_CLK_CTL2:  1;             /*!< MCU_I2C1_CLK IO cell CTL2 setting                                     */
           uint32_t             :  2;
      __IO uint32_t  I2C2_DATA_CTL1:  1;            /*!< MCU_I2C2_DATA IO cell CTL1 setting                                    */
      __IO uint32_t  I2C2_DATA_CTL2:  1;            /*!< MCU_I2C2_DATA IO cell CTL2 setting                                    */
           uint32_t             :  2;
      __IO uint32_t  I2C2_CLK_CTL1:  1;             /*!< MCU_I2C2_CLK IO cell CTL1 setting                                     */
      __IO uint32_t  I2C2_CLK_CTL2:  1;             /*!< MCU_I2C2_CLK IO cell CTL2 setting                                     */
           uint32_t : 8; // padding
    } IO_CFG4_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG5;                         /*!< IO_CFG5                                                               */
    
    struct {
      __IO uint32_t  UA0_RXD_ENPUD:  1;             /*!< MCU_UA0_RXD IO cell ENPUD setting                                     */
      __IO uint32_t  UA0_RXD_PUD:  1;               /*!< MCU_UA0_RXD IO cell PUD setting                                       */
      __IO uint32_t  UA0_RXD_CTL1:  1;              /*!< MCU_UA0_RXD IO cell CTL1 setting                                      */
      __IO uint32_t  UA0_RXD_CTL2:  1;              /*!< MCU_UA0_RXD IO cell CTL2 setting                                      */
      __IO uint32_t  UA0_TXD_ENPUD:  1;             /*!< MCU_UA0_TXD IO cell ENPUD setting                                     */
      __IO uint32_t  UA0_TXD_PUD:  1;               /*!< MCU_UA0_TXD IO cell PUD setting                                       */
      __IO uint32_t  UA0_TXD_CTL1:  1;              /*!< MCU_UA0_TXD IO cell CTL1 setting                                      */
      __IO uint32_t  UA0_TXD_CTL2:  1;              /*!< MCU_UA0_TXD IO cell CTL2 setting                                      */
           uint32_t             :  8;
      __IO uint32_t  UA1_RXD_ENPUD:  1;             /*!< MCU_UA1_RXD IO cell ENPUD setting                                     */
      __IO uint32_t  UA1_RXD_PUD:  1;               /*!< MCU_UA1_RXD IO cell PUD setting                                       */
      __IO uint32_t  UA1_RXD_CTL1:  1;              /*!< MCU_UA1_RXD IO cell CTL1 setting                                      */
      __IO uint32_t  UA1_RXD_CTL2:  1;              /*!< MCU_UA1_RXD IO cell CTL2 setting                                      */
      __IO uint32_t  UA1_TXD_ENPUD:  1;             /*!< MCU_UA1_TXD IO cell ENPUD setting                                     */
      __IO uint32_t  UA1_TXD_PUD:  1;               /*!< MCU_UA1_TXD IO cell PUD setting                                       */
      __IO uint32_t  UA1_TXD_CTL1:  1;              /*!< MCU_UA1_TXD IO cell CTL1 setting                                      */
      __IO uint32_t  UA1_TXD_CTL2:  1;              /*!< MCU_UA1_TXD IO cell CTL2 setting                                      */
      __IO uint32_t  UA1_RTS_N_ENPUD:  1;           /*!< MCU_UA1_RTS_N IO cell ENPUD setting                                   */
      __IO uint32_t  UA1_RTS_N_PUD:  1;             /*!< MCU_UA1_RTS_N IO cell PUD setting                                     */
      __IO uint32_t  UA1_RTS_N_CTL1:  1;            /*!< MCU_UA1_RTS_N IO cell CTL1 setting                                    */
      __IO uint32_t  UA1_RTS_N_CTL2:  1;            /*!< MCU_UA1_RTS_N IO cell CTL2 setting                                    */
      __IO uint32_t  UA1_CTS_N_ENPUD:  1;           /*!< MCU_UA1_CTS_N IO cell ENPUD setting                                   */
      __IO uint32_t  UA1_CTS_N_PUD:  1;             /*!< MCU_UA1_CTS_N IO cell PUD setting                                     */
      __IO uint32_t  UA1_CTS_N_CTL1:  1;            /*!< MCU_UA1_CTS_N IO cell CTL1 setting                                    */
      __IO uint32_t  UA1_CTS_N_CTL2:  1;            /*!< MCU_UA1_CTS_N IO cell CTL2 setting                                    */
    } IO_CFG5_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG6;                         /*!< IO_CFG6                                                               */
    
    struct {
      __IO uint32_t  UA2_RXD_ENPUD:  1;             /*!< MCU_UA2_RXD IO cell ENPUD setting                                     */
      __IO uint32_t  UA2_RXD_PUD:  1;               /*!< MCU_UA2_RXD IO cell PUD setting                                       */
      __IO uint32_t  UA2_RXD_CTL1:  1;              /*!< MCU_UA2_RXD IO cell CTL1 setting                                      */
      __IO uint32_t  UA2_RXD_CTL2:  1;              /*!< MCU_UA2_RXD IO cell CTL2 setting                                      */
      __IO uint32_t  UA2_TXD_ENPUD:  1;             /*!< MCU_UA2_TXD IO cell ENPUD setting                                     */
      __IO uint32_t  UA2_TXD_PUD:  1;               /*!< MCU_UA2_TXD IO cell PUD setting                                       */
      __IO uint32_t  UA2_TXD_CTL1:  1;              /*!< MCU_UA2_TXD IO cell CTL1 setting                                      */
      __IO uint32_t  UA2_TXD_CTL2:  1;              /*!< MCU_UA2_TXD IO cell CTL2 setting                                      */
      __IO uint32_t  UA2_RTS_N_ENPUD:  1;           /*!< MCU_UA2_RTS_N IO cell ENPUD setting                                   */
      __IO uint32_t  UA2_RTS_N_PUD:  1;             /*!< MCU_UA2_RTS_N IO cell PUD setting                                     */
      __IO uint32_t  UA2_RTS_N_CTL1:  1;            /*!< MCU_UA2_RTS_N IO cell CTL1 setting                                    */
      __IO uint32_t  UA2_RTS_N_CTL2:  1;            /*!< MCU_UA2_RTS_N IO cell CTL2 setting                                    */
      __IO uint32_t  UA2_CTS_N_ENPUD:  1;           /*!< MCU_UA2_CTS_N IO cell ENPUD setting                                   */
      __IO uint32_t  UA2_CTS_N_PUD:  1;             /*!< MCU_UA2_CTS_N IO cell PUD setting                                     */
      __IO uint32_t  UA2_CTS_N_CTL1:  1;            /*!< MCU_UA2_CTS_N IO cell CTL1 setting                                    */
      __IO uint32_t  UA2_CTS_N_CTL2:  1;            /*!< MCU_UA2_CTS_N IO cell CTL2 setting                                    */
           uint32_t : 16; // padding
    } IO_CFG6_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG7;                         /*!< IO_CFG7                                                               */
    
    struct {
      __IO uint32_t  SPIM0_CS_N_ENPUD:  1;          /*!< MCU_SPIM0_CS_N IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM0_CS_N_PUD:  1;            /*!< MCU_SPIM0_CS_N IO cell PUD setting                                    */
      __IO uint32_t  SPIM0_CS_N_CTL1:  1;           /*!< MCU_SPIM0_CS_N IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM0_CS_N_CTL2:  1;           /*!< MCU_SPIM0_CS_N IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM0_CLK_ENPUD:  1;           /*!< MCU_SPIM0_CLK IO cell ENPUD setting                                   */
      __IO uint32_t  SPIM0_CLK_PUD:  1;             /*!< MCU_SPIM0_CLK IO cell PUD setting                                     */
      __IO uint32_t  SPIM0_CLK_CTL1:  1;            /*!< MCU_SPIM0_CLK IO cell CTL1 setting                                    */
      __IO uint32_t  SPIM0_CLK_CTL2:  1;            /*!< MCU_SPIM0_CLK IO cell CTL2 setting                                    */
      __IO uint32_t  SPIM0_MOSI_ENPUD:  1;          /*!< MCU_SPIM0_MOSI IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM0_MOSI_PUD:  1;            /*!< MCU_SPIM0_MOSI IO cell PUD setting                                    */
      __IO uint32_t  SPIM0_MOSI_CTL1:  1;           /*!< MCU_SPIM0_MOSI IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM0_MOSI_CTL2:  1;           /*!< MCU_SPIM0_MOSI IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM0_MISO_ENPUD:  1;          /*!< MCU_SPIM0_MISO IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM0_MISO_PUD:  1;            /*!< MCU_SPIM0_MISO IO cell PUD setting                                    */
      __IO uint32_t  SPIM0_MISO_CTL1:  1;           /*!< MCU_SPIM0_MISO IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM0_MISO_CTL2:  1;           /*!< MCU_SPIM0_MISO IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM1_CS_N_ENPUD:  1;          /*!< MCU_SPIM1_CS_N IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM1_CS_N_PUD:  1;            /*!< MCU_SPIM1_CS_N IO cell PUD setting                                    */
      __IO uint32_t  SPIM1_CS_N_CTL1:  1;           /*!< MCU_SPIM1_CS_N IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM1_CS_N_CTL2:  1;           /*!< MCU_SPIM1_CS_N IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM1_CLK_ENPUD:  1;           /*!< MCU_SPIM1_CLK IO cell ENPUD setting                                   */
      __IO uint32_t  SPIM1_CLK_PUD:  1;             /*!< MCU_SPIM1_CLK IO cell PUD setting                                     */
      __IO uint32_t  SPIM1_CLK_CTL1:  1;            /*!< MCU_SPIM1_CLK IO cell CTL1 setting                                    */
      __IO uint32_t  SPIM1_CLK_CTL2:  1;            /*!< MCU_SPIM1_CLK IO cell CTL2 setting                                    */
      __IO uint32_t  SPIM1_MOSI_ENPUD:  1;          /*!< MCU_SPIM1_MOSI IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM1_MOSI_PUD:  1;            /*!< MCU_SPIM1_MOSI IO cell PUD setting                                    */
      __IO uint32_t  SPIM1_MOSI_CTL1:  1;           /*!< MCU_SPIM1_MOSI IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM1_MOSI_CTL2:  1;           /*!< MCU_SPIM1_MOSI IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM1_MISO_ENPUD:  1;          /*!< MCU_SPIM1_MISO IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM1_MISO_PUD:  1;            /*!< MCU_SPIM1_MISO IO cell PUD setting                                    */
      __IO uint32_t  SPIM1_MISO_CTL1:  1;           /*!< MCU_SPIM1_MISO IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM1_MISO_CTL2:  1;           /*!< MCU_SPIM1_MISO IO cell CTL2 setting                                   */
    } IO_CFG7_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG8;                         /*!< IO_CFG8                                                               */
    
    struct {
      __IO uint32_t  SPIM2_CS_N_ENPUD:  1;          /*!< MCU_SPIM2_CS_N IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM2_CS_N_PUD:  1;            /*!< MCU_SPIM2_CS_N IO cell PUD setting                                    */
      __IO uint32_t  SPIM2_CS_N_CTL1:  1;           /*!< MCU_SPIM2_CS_N IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM2_CS_N_CTL2:  1;           /*!< MCU_SPIM2_CS_N IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM2_CLK_ENPUD:  1;           /*!< MCU_SPIM2_CLK IO cell ENPUD setting                                   */
      __IO uint32_t  SPIM2_CLK_PUD:  1;             /*!< MCU_SPIM2_CLK IO cell PUD setting                                     */
      __IO uint32_t  SPIM2_CLK_CTL1:  1;            /*!< MCU_SPIM2_CLK IO cell CTL1 setting                                    */
      __IO uint32_t  SPIM2_CLK_CTL2:  1;            /*!< MCU_SPIM2_CLK IO cell CTL2 setting                                    */
      __IO uint32_t  SPIM2_MOSI_ENPUD:  1;          /*!< MCU_SPIM2_MOSI IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM2_MOSI_PUD:  1;            /*!< MCU_SPIM2_MOSI IO cell PUD setting                                    */
      __IO uint32_t  SPIM2_MOSI_CTL1:  1;           /*!< MCU_SPIM2_MOSI IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM2_MOSI_CTL2:  1;           /*!< MCU_SPIM2_MOSI IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM2_MISO_ENPUD:  1;          /*!< MCU_SPIM2_MISO IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM2_MISO_PUD:  1;            /*!< MCU_SPIM2_MISO IO cell PUD setting                                    */
      __IO uint32_t  SPIM2_MISO_CTL1:  1;           /*!< MCU_SPIM2_MISO IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM2_MISO_CTL2:  1;           /*!< MCU_SPIM2_MISO IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM3_CS_N_ENPUD:  1;          /*!< MCU_SPIM3_CS_N IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM3_CS_N_PUD:  1;            /*!< MCU_SPIM3_CS_N IO cell PUD setting                                    */
      __IO uint32_t  SPIM3_CS_N_CTL1:  1;           /*!< MCU_SPIM3_CS_N IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM3_CS_N_CTL2:  1;           /*!< MCU_SPIM3_CS_N IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM3_CLK_ENPUD:  1;           /*!< MCU_SPIM3_CLK IO cell ENPUD setting                                   */
      __IO uint32_t  SPIM3_CLK_PUD:  1;             /*!< MCU_SPIM3_CLK IO cell PUD setting                                     */
      __IO uint32_t  SPIM3_CLK_CTL1:  1;            /*!< MCU_SPIM3_CLK IO cell CTL1 setting                                    */
      __IO uint32_t  SPIM3_CLK_CTL2:  1;            /*!< MCU_SPIM3_CLK IO cell CTL2 setting                                    */
      __IO uint32_t  SPIM3_MOSI_ENPUD:  1;          /*!< MCU_SPIM3_MOSI IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM3_MOSI_PUD:  1;            /*!< MCU_SPIM3_MOSI IO cell PUD setting                                    */
      __IO uint32_t  SPIM3_MOSI_CTL1:  1;           /*!< MCU_SPIM3_MOSI IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM3_MOSI_CTL2:  1;           /*!< MCU_SPIM3_MOSI IO cell CTL2 setting                                   */
      __IO uint32_t  SPIM3_MISO_ENPUD:  1;          /*!< MCU_SPIM3_MISO IO cell ENPUD setting                                  */
      __IO uint32_t  SPIM3_MISO_PUD:  1;            /*!< MCU_SPIM3_MISO IO cell PUD setting                                    */
      __IO uint32_t  SPIM3_MISO_CTL1:  1;           /*!< MCU_SPIM3_MISO IO cell CTL1 setting                                   */
      __IO uint32_t  SPIM3_MISO_CTL2:  1;           /*!< MCU_SPIM3_MISO IO cell CTL2 setting                                   */
    } IO_CFG8_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG9;                         /*!< IO_CFG9                                                               */
    
    struct {
      __IO uint32_t  SPIC_CS_N_ENPUD:  1;           /*!< MCU_SPIC_CS_N IO cell ENPUD setting                                   */
      __IO uint32_t  SPIC_CS_N_PUD:  1;             /*!< MCU_SPIC_CS_N IO cell PUD setting                                     */
      __IO uint32_t  SPIC_CS_N_CTL1:  1;            /*!< MCU_SPIC_CS_N IO cell CTL1 setting                                    */
      __IO uint32_t  SPIC_CS_N_CTL2:  1;            /*!< MCU_SPIC_CS_N IO cell CTL2 setting                                    */
      __IO uint32_t  SPIC_CLK_ENPUD:  1;            /*!< MCU_SPIC_CLK IO cell ENPUD setting                                    */
      __IO uint32_t  SPIC_CLK_PUD:  1;              /*!< MCU_SPIC_CLK IO cell PUD setting                                      */
      __IO uint32_t  SPIC_CLK_CTL1:  1;             /*!< MCU_SPIC_CLK IO cell CTL1 setting                                     */
      __IO uint32_t  SPIC_CLK_CTL2:  1;             /*!< MCU_SPIC_CLK IO cell CTL2 setting                                     */
      __IO uint32_t  SPIC_MOSI_ENPUD:  1;           /*!< MCU_SPIC_MOSI IO cell ENPUD setting                                   */
      __IO uint32_t  SPIC_MOSI_PUD:  1;             /*!< MCU_SPIC_MOSI IO cell PUD setting                                     */
      __IO uint32_t  SPIC_MOSI_CTL1:  1;            /*!< MCU_SPIC_MOSI IO cell CTL1 setting                                    */
      __IO uint32_t  SPIC_MOSI_CTL2:  1;            /*!< MCU_SPIC_MOSI IO cell CTL2 setting                                    */
      __IO uint32_t  SPIC_MISO_ENPUD:  1;           /*!< MCU_SPIC_MISO IO cell ENPUD setting                                   */
      __IO uint32_t  SPIC_MISO_PUD:  1;             /*!< MCU_SPIC_MISO IO cell PUD setting                                     */
      __IO uint32_t  SPIC_MISO_CTL1:  1;            /*!< MCU_SPIC_MISO IO cell CTL1 setting                                    */
      __IO uint32_t  SPIC_MISO_CTL2:  1;            /*!< MCU_SPIC_MISO IO cell CTL2 setting                                    */
      __IO uint32_t  SPIC_IO2_ENPUD:  1;            /*!< MCU_SPIC_IO2 IO cell ENPUD setting                                    */
      __IO uint32_t  SPIC_IO2_PUD:  1;              /*!< MCU_SPIC_IO2 IO cell PUD setting                                      */
      __IO uint32_t  SPIC_IO2_CTL1:  1;             /*!< MCU_SPIC_IO2 IO cell CTL1 setting                                     */
      __IO uint32_t  SPIC_IO2_CTL2:  1;             /*!< MCU_SPIC_IO2 IO cell CTL2 setting                                     */
      __IO uint32_t  SPIC_IO3_ENPUD:  1;            /*!< MCU_SPIC_IO3 IO cell ENPUD setting                                    */
      __IO uint32_t  SPIC_IO3_PUD:  1;              /*!< MCU_SPIC_IO3 IO cell PUD setting                                      */
      __IO uint32_t  SPIC_IO3_CTL1:  1;             /*!< MCU_SPIC_IO3 IO cell CTL1 setting                                     */
      __IO uint32_t  SPIC_IO3_CTL2:  1;             /*!< MCU_SPIC_IO3 IO cell CTL2 setting                                     */
           uint32_t : 8; // padding
    } IO_CFG9_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG10;                        /*!< IO_CFG10                                                              */
    
    struct {
      __IO uint32_t  ADC24_SYNC_ENPUD:  1;          /*!< MCU_ADC24_SYNC IO cell ENPUD setting                                  */
      __IO uint32_t  ADC24_SYNC_PUD:  1;            /*!< MCU_ADC24_SYNC IO cell PUD setting                                    */
      __IO uint32_t  ADC24_SYNC_CTL1:  1;           /*!< MCU_ADC24_SYNC IO cell CTL1 setting                                   */
      __IO uint32_t  ADC24_SYNC_CTL2:  1;           /*!< MCU_ADC24_SYNC IO cell CTL2 setting                                   */
           uint32_t : 28; // padding
    } IO_CFG10_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  IO_CFG11;                        /*!< IO_CFG11                                                              */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  DBG_CTL1   :  1;               /*!< MCU_DBG_* IO cell CTL1 setting                                        */
      __IO uint32_t  DBG_CTL2   :  1;               /*!< MCU_DBG_* IO cell CTL2 setting                                        */
           uint32_t : 28; // padding
    } IO_CFG11_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8[4];
  
  union {
    __IO uint32_t  FMODE_CFG0;                      /*!< For details on Function Mode, see 'Datasheet Summary 5.1 Setting
                                                         Multiple function I/O'.                                               */
    
    struct {
      __IO uint32_t  GPIO_0_FMODE:  2;              /*!< MCU_GPIO_0 Function Mode setting                                      */
      __IO uint32_t  GPIO_1_FMODE:  2;              /*!< MCU_GPIO_1 Function Mode setting                                      */
      __IO uint32_t  GPIO_2_FMODE:  2;              /*!< MCU_GPIO_2 Function Mode setting                                      */
      __IO uint32_t  GPIO_3_FMODE:  2;              /*!< MCU_GPIO_3 Function Mode setting                                      */
      __IO uint32_t  GPIO_4_FMODE:  2;              /*!< MCU_GPIO_4 Function Mode setting                                      */
      __IO uint32_t  GPIO_5_FMODE:  2;              /*!< MCU_GPIO_5 Function Mode setting                                      */
      __IO uint32_t  GPIO_6_FMODE:  2;              /*!< MCU_GPIO_6 Function Mode setting                                      */
      __IO uint32_t  GPIO_7_FMODE:  2;              /*!< MCU_GPIO_7 Function Mode setting                                      */
      __IO uint32_t  GPIO_8_FMODE:  2;              /*!< MCU_GPIO_8 Function Mode setting                                      */
      __IO uint32_t  GPIO_9_FMODE:  2;              /*!< MCU_GPIO_9 Function Mode setting                                      */
      __IO uint32_t  GPIO_10_FMODE:  2;             /*!< MCU_GPIO_10 Function Mode setting                                     */
      __IO uint32_t  GPIO_11_FMODE:  2;             /*!< MCU_GPIO_11 Function Mode setting                                     */
      __IO uint32_t  GPIO_12_FMODE:  2;             /*!< MCU_GPIO_12 Function Mode setting                                     */
      __IO uint32_t  GPIO_13_FMODE:  2;             /*!< MCU_GPIO_13 Function Mode setting                                     */
      __IO uint32_t  GPIO_14_FMODE:  2;             /*!< MCU_GPIO_14 Function Mode setting                                     */
      __IO uint32_t  GPIO_15_FMODE:  2;             /*!< MCU_GPIO_15 Function Mode setting                                     */
    } FMODE_CFG0_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FMODE_CFG1;                      /*!< For details on Function Mode, see 'Datasheet Summary 5.1 Setting
                                                         Multiple function I/O'.                                               */
    
    struct {
           uint32_t             : 16;
      __IO uint32_t  GPIO_24_FMODE:  2;             /*!< MCU_GPIO_24 Function Mode setting                                     */
      __IO uint32_t  GPIO_25_FMODE:  2;             /*!< MCU_GPIO_25 Function Mode setting                                     */
      __IO uint32_t  GPIO_26_FMODE:  2;             /*!< MCU_GPIO_26 Function Mode setting                                     */
      __IO uint32_t  GPIO_27_FMODE:  2;             /*!< MCU_GPIO_27 Function Mode setting                                     */
      __IO uint32_t  GPIO_28_FMODE:  2;             /*!< MCU_GPIO_28 Function Mode setting                                     */
      __IO uint32_t  GPIO_29_FMODE:  2;             /*!< MCU_GPIO_29 Function Mode setting                                     */
      __IO uint32_t  GPIO_30_FMODE:  2;             /*!< MCU_GPIO_30 Function Mode setting                                     */
      __IO uint32_t  GPIO_31_FMODE:  2;             /*!< MCU_GPIO_31 Function Mode setting                                     */
    } FMODE_CFG1_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FMODE_CFG2;                      /*!< For details on Function Mode, see 'Datasheet Summary 5.1 Setting
                                                         Multiple function I/O'.                                               */
    
    struct {
      __IO uint32_t  I2C0_DATA_FMODE:  2;           /*!< MCU_I2C0_DATA Function Mode setting                                   */
      __IO uint32_t  I2C0_CLK_FMODE:  2;            /*!< MCU_I2C0_CLK Function Mode setting                                    */
      __IO uint32_t  I2C1_DATA_FMODE:  2;           /*!< MCU_I2C1_DATA Function Mode setting                                   */
      __IO uint32_t  I2C1_CLK_FMODE:  2;            /*!< MCU_I2C1_CLK Function Mode setting                                    */
      __IO uint32_t  I2C2_FMODE :  2;               /*!< MCU_I2C2_* Function Mode setting                                      */
           uint32_t : 22; // padding
    } FMODE_CFG2_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FMODE_CFG3;                      /*!< For details on Function Mode, see 'Datasheet Summary 5.1 Setting
                                                         Multiple function I/O'.                                               */
    
    struct {
      __IO uint32_t  UA0_RXD_FMODE:  2;             /*!< MCU_UA0_RXD Function Mode setting                                     */
      __IO uint32_t  UA0_TXD_FMODE:  2;             /*!< MCU_UA0_TXD Function Mode setting                                     */
           uint32_t             :  4;
      __IO uint32_t  UA1_RXD_FMODE:  2;             /*!< MCU_UA1_RXD Function Mode setting                                     */
      __IO uint32_t  UA1_TXD_FMODE:  2;             /*!< MCU_UA1_TXD Function Mode setting                                     */
      __IO uint32_t  UA1_RTS_N_FMODE:  2;           /*!< MCU_UA1_RTS_N Function Mode setting                                   */
      __IO uint32_t  UA1_CTS_N_FMODE:  2;           /*!< MCU_UA1_CTS_N Function Mode setting                                   */
      __IO uint32_t  UA2_RXD_FMODE:  2;             /*!< MCU_UA2_RXD Function Mode setting                                     */
      __IO uint32_t  UA2_TXD_FMODE:  2;             /*!< MCU_UA2_TXD Function Mode setting                                     */
      __IO uint32_t  UA2_RTS_N_FMODE:  2;           /*!< MCU_UA2_RTS_N Function Mode setting                                   */
      __IO uint32_t  UA2_CTS_N_FMODE:  2;           /*!< MCU_UA2_CTS_N Function Mode setting                                   */
           uint32_t : 8; // padding
    } FMODE_CFG3_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FMODE_CFG4;                      /*!< For details on Function Mode, see 'Datasheet Summary 5.1 Setting
                                                         Multiple function I/O'.                                               */
    
    struct {
      __IO uint32_t  SPIM0_CS_N_FMODE:  2;          /*!< MCU_SPIM0_CS_N Function Mode setting                                  */
      __IO uint32_t  SPIM0_CLK_FMODE:  2;           /*!< MCU_SPIM0_CLK Function Mode setting                                   */
      __IO uint32_t  SPIM0_MOSI_FMODE:  2;          /*!< MCU_SPIM0_MOSI Function Mode setting                                  */
      __IO uint32_t  SPIM0_MISO_FMODE:  2;          /*!< MCU_SPIM0_MISO Function Mode setting                                  */
      __IO uint32_t  SPIM1_CS_N_FMODE:  2;          /*!< MCU_SPIM1_CS_N Function Mode setting                                  */
      __IO uint32_t  SPIM1_CLK_FMODE:  2;           /*!< MCU_SPIM1_CLK Function Mode setting                                   */
      __IO uint32_t  SPIM1_MOSI_FMODE:  2;          /*!< MCU_SPIM1_MOSI Function Mode setting                                  */
      __IO uint32_t  SPIM1_MISO_FMODE:  2;          /*!< MCU_SPIM1_MISO Function Mode setting                                  */
      __IO uint32_t  SPIM2_FMODE:  2;               /*!< MCU_SPIM2_* Function Mode setting                                     */
           uint32_t             :  6;
      __IO uint32_t  SPIM3_FMODE:  2;               /*!< MCU_SPIM3_* Function Mode setting                                     */
           uint32_t : 6; // padding
    } FMODE_CFG4_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FMODE_CFG5;                      /*!< For details on Function Mode, see 'Datasheet Summary 5.1 Setting
                                                         Multiple function I/O'.                                               */
    
    struct {
      __IO uint32_t  SPIC_FMODE :  2;               /*!< MCU_SPIC_* Function Mode setting                                      */
           uint32_t : 30; // padding
    } FMODE_CFG5_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FMODE_CFG6;                      /*!< For details on Function Mode, see 'Datasheet Summary 5.1 Setting
                                                         Multiple function I/O'.                                               */
    
    struct {
      __IO uint32_t  ADC24_SYNC_FMODE:  2;          /*!< MCU_ADC24_SYNC Function Mode setting                                  */
           uint32_t : 30; // padding
    } FMODE_CFG6_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED9[41];
  
  union {
    __IO uint32_t  OE_CTRL;                         /*!< OE_CTRL                                                               */
    
    struct {
      __IO uint32_t  UART0_OE   :  1;               /*!< Output Enable for UART0 signals1 : Output Enable0 : Output Disable    */
      __IO uint32_t  UART1_OE   :  1;               /*!< Output Enable for UART1 signals1 : Output Enable0 : Output Disable    */
      __IO uint32_t  UART2_OE   :  1;               /*!< Output Enable for UART2 signals1 : Output Enable0 : Output Disable    */
           uint32_t             :  1;
      __IO uint32_t  SPIM0_OE   :  1;               /*!< Output Enable for SPIM0 signals1 : Output Enable0 : Output Disable    */
      __IO uint32_t  SPIM1_OE   :  1;               /*!< Output Enable for SPIM1 signals1 : Output Enable0 : Output Disable    */
      __IO uint32_t  SPIM2_OE   :  1;               /*!< Output Enable for SPIM2 signals1 : Output Enable0 : Output Disable    */
      __IO uint32_t  SPIM3_OE   :  1;               /*!< Output Enable for SPIM3 signals1 : Output Enable0 : Output Disable    */
      __IO uint32_t  ADC24_OE   :  1;               /*!< Output Enable for ASC24 signals1 : Output Enable0 : Output Disable    */
           uint32_t             :  3;
      __IO uint32_t  CPU_TRACE_OE:  1;              /*!< Output Enable for CPU Trace signals1 : Output Enable0 : Output
                                                         Disable                                                               */
           uint32_t : 19; // padding
    } OE_CTRL_b;                                    /*!< BitSize                                                               */
  };
} gconf_Type;


/* ================================================================================ */
/* ================                      gpio0                     ================ */
/* ================================================================================ */


/**
  * @brief gpio0 (gpio0)
  */

typedef struct {                                    /*!< gpio0 Structure                                                       */
  
  union {
    __IO uint32_t  GPIODATA[256];                   /*!< GPIO Data Register                                                    */
    
    struct {
      __IO uint32_t  DATA       :  8;               /*!< At reading: The logical product of the address to be accessed
                                                         and terminal status can be read. PADDR[9:2] & GPIN[7:0]At writing:
                                                          The logical product of the address to be accessed and written
                                                          data and GPIO output settings is set for the terminal. PADDR[9:2]
                                                          & PWDATA[7:0] & [GPIO0_GPIODIR].DIR[7:0]                             */
           uint32_t : 24; // padding
    } GPIODATA_b[256];                              /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIODIR;                         /*!< GPIO Data Direction Register                                          */
    
    struct {
      __IO uint32_t  DIR        :  8;               /*!< Sets the data direction of each GPIO pin. 0b1: GPIO output 0b0:
                                                         GPIO input                                                            */
           uint32_t : 24; // padding
    } GPIODIR_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOIS;                          /*!< GPIO Interrupt Sense Register                                         */
    
    struct {
      __IO uint32_t  IS         :  8;               /*!< Sets the interrupt detection method of each GPIO pin. GPIOIEV
                                                         specifies other settings. 0b1: Level detection interrupt 0b0:
                                                          Edge detection interrupt                                             */
           uint32_t : 24; // padding
    } GPIOIS_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOIBE;                         /*!< GPIO Interrupt Both Edges Register                                    */
    
    struct {
      __IO uint32_t  IBE        :  8;               /*!< Sets both-edge interrupt of each GPIO pin. GPIOIEV determines
                                                         the edge to be used. 0b1: Both-edge interrupt 0b0: Single edge
                                                          interrupt                                                            */
           uint32_t : 24; // padding
    } GPIOIBE_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOIEV;                         /*!< GPIO Interrupt Event Register                                         */
    
    struct {
      __IO uint32_t  IEV        :  8;               /*!< Sets the edge interrupt method of each GPIO pin. 0b1: Rising
                                                         edge interrupt or High-level interrupt 0b0: Falling edge interrupt
                                                          or low-level interrupt                                               */
           uint32_t : 24; // padding
    } GPIOIEV_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOIE;                          /*!< GPIO Interrupt Enable Register                                        */
    
    struct {
      __IO uint32_t  IE         :  8;               /*!< Sets interrupt enable/mask for each GPIO pin. 0b1: Does not
                                                         mask the interrupt (interrupt enable) 0b0: Masks the interrupt
                                                          (interrupt disable)                                                  */
           uint32_t : 24; // padding
    } GPIOIE_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIORIS;                         /*!< GPIO Raw Interrupt Status Register                                    */
    
    struct {
      __I  uint32_t  RIS        :  8;               /*!< Interrupt status before masking for each GPIO pin 0b1: Interrupt
                                                         request available 0b0: No interrupt request                           */
           uint32_t : 24; // padding
    } GPIORIS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOMIS;                         /*!< GPIO Masked Interrupt Status Register                                 */
    
    struct {
      __I  uint32_t  MIS        :  8;               /*!< Interrupt status after masking for each GPIO pin 0b1: Interrupt
                                                         request available 0b0: No interrupt request                           */
           uint32_t : 24; // padding
    } GPIOMIS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOIC;                          /*!< GPIO Interrupt Clear Register                                         */
    
    struct {
      __IO uint32_t  IC         :  8;               /*!< Clears an interrupt for each GPIO pin. 0b1: Clears the interrupt.
                                                         0b0: Does nothing.                                                    */
           uint32_t : 24; // padding
    } GPIOIC_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[120];
  
  union {
    __IO uint32_t  GPIOITCR;                        /*!< GPIO Integration Test Control Register                                */
    
    struct {
      __IO uint32_t  ITEN       :  1;               /*!< Integration test enable0b1: Test mode0b0: Normal operation            */
           uint32_t : 31; // padding
    } GPIOITCR_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOITIP1;                       /*!< GPIO Integration test input read/set Register 1                       */
    
    struct {
      __IO uint32_t  GPAFOUT    :  8;               /*!< For ITEM=1(Integration test mode), enables the GPAFOUT input
                                                         signal to be controlled.At reading: Reads the output status
                                                          of Mux at the GPAFOUT last stage.At writing: Enables alternate
                                                          data to be written for GPAFOUT input.For ITEM=0(Normal mod),
                                                          the GPAFOUT input status can be read intact. No operation for
                                                          writing.                                                             */
           uint32_t : 24; // padding
    } GPIOITIP1_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOITIP2;                       /*!< GPIO Integration test input read/set Register 2                       */
    
    struct {
      __IO uint32_t  nGPAFEN    :  8;               /*!< For ITEM=1(Integration test mode), enables the nGPAFEN input
                                                         signal to be controlled.At reading: Reads the output status
                                                          of Mux at the nGPAFEN last stage.At writing: Enables alternate
                                                          data to be written for nGPAFEN input.For ITEM=0(Normal mod),
                                                          the nGPAFEN input status can be read intact. No operation for
                                                          writing.                                                             */
           uint32_t : 24; // padding
    } GPIOITIP2_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOITOP1;                       /*!< GPIO Integration test output read/set Register 1                      */
    
    struct {
      __IO uint32_t  GPIOMIS    :  8;               /*!< For ITEM=1(Integration test mode), enables the GPIOMIS output
                                                         signal to be controlled.At reading: Returns 0.At writing: Writes
                                                          data to be output to GPIOMIS.For ITEM=0(Normal mod), no operation
                                                          for writing.                                                         */
           uint32_t : 24; // padding
    } GPIOITOP1_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOITOP2;                       /*!< GPIO Integration test output read/set Register 2                      */
    
    struct {
      __I  uint32_t  GPIOINTR   :  1;               /*!< For ITEM=1(Integration test mode), enables the status of the
                                                         GPIOINTR output signal to be read.At reading: Reads the GPIOINTR
                                                          status (GPIOINTR is a signal with GPIOMIS[7:0] being ORed).          */
           uint32_t : 31; // padding
    } GPIOITOP2_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GPIOITOP3;                       /*!< GPIO Integration test output read/set Register 3                      */
    
    struct {
      __IO uint32_t  GPAFIN     :  8;               /*!< For ITEM=1(Integration test mode), enables the GPIOAFIN output
                                                         signal to be controlled.At reading: Reads the output status
                                                          of Mux at the GPAFIN last stage.AT writing: Writes data to be
                                                          output to GPAFIN.For ITEM=0(Normal mod), the GPAFIN output status
                                                          can be read intact. No operation for writing.                        */
           uint32_t : 24; // padding
    } GPIOITOP3_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[626];
  
  union {
    __I  uint32_t  GPIOPERIPHID0;                   /*!< GPIO Peripheral ID0 Register                                          */
    
    struct {
      __I  uint32_t  Partnumber0:  8;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Lower) 061=>61                                  */
           uint32_t : 24; // padding
    } GPIOPERIPHID0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOPERIPHID1;                   /*!< GPIO Peripheral ID1 Register                                          */
    
    struct {
      __I  uint32_t  Partnumber1:  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Partnumber(Upper) 061=>0                                   */
      __I  uint32_t  Designer0  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Lower) 41=>1                                      */
           uint32_t : 24; // padding
    } GPIOPERIPHID1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOPERIPHID2;                   /*!< GPIO Peripheral ID2 Register                                          */
    
    struct {
      __I  uint32_t  Designer1  :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Designer(Upper) 41=>4                                      */
      __I  uint32_t  Revision   :  4;               /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Revision: r1p0=>0                                          */
           uint32_t : 24; // padding
    } GPIOPERIPHID2_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOPERIPHID3;                   /*!< GPIO Peripheral ID3 Register                                          */
    
    struct {
      __I  uint32_t  Configuration:  8;             /*!< Peripheral ID (this register stores a value from a hardware
                                                         viewpoint.)Configuration: 00                                          */
           uint32_t : 24; // padding
    } GPIOPERIPHID3_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOPCELLID0;                    /*!< GPIO PrimeCell ID0 Register                                           */
    
    struct {
      __I  uint32_t  PCellID0   :  8;               /*!< PrimeCell ID (this register stores a value from a hardware viewpoint).
                                                         Fixed value.                                                          */
           uint32_t : 24; // padding
    } GPIOPCELLID0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOPCELLID1;                    /*!< GPIO PrimeCell ID1 Register                                           */
    
    struct {
      __I  uint32_t  PCellID1   :  8;               /*!< PrimeCell ID (this register stores a value from a hardware viewpoint).
                                                         Fixed value.                                                          */
           uint32_t : 24; // padding
    } GPIOPCELLID1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOPCELLID2;                    /*!< GPIO PrimeCell ID2 Register                                           */
    
    struct {
      __I  uint32_t  PCellID2   :  8;               /*!< PrimeCell ID (this register stores a value from a hardware viewpoint).
                                                         Fixed value.                                                          */
           uint32_t : 24; // padding
    } GPIOPCELLID2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GPIOPCELLID3;                    /*!< GPIO PrimeCell ID3 Register                                           */
    
    struct {
      __I  uint32_t  PCellID3   :  8;               /*!< PrimeCell ID (this register stores a value from a hardware viewpoint).
                                                         Fixed value.                                                          */
           uint32_t : 24; // padding
    } GPIOPCELLID3_b;                               /*!< BitSize                                                               */
  };
} gpio_Type;


/* ================================================================================ */
/* ================                      uart0                     ================ */
/* ================================================================================ */


/**
  * @brief uart0 (uart0)
  */

typedef struct {                                    /*!< uart0 Structure                                                       */
  
  union {
    __IO uint32_t  UARTDR;                          /*!< UART Data Register                                                    */
    
    struct {
      __IO uint32_t  DATA       :  8;               /*!< Send and receive data At reading: Data of reception FIFO is
                                                         read. At writing: Data is written to transmission FIFO.(Note)
                                                          If transmission or reception is disabled midway, it stops after
                                                          current data transfer is complete.                                   */
      __I  uint32_t  FE         :  1;               /*!< Framing error 0b1: Error occurrence If the reception data does
                                                         not satisfy the configured stop bit length, 0b1 is set. In FIFO
                                                          mode, 0b1 is set when the reception data for which that condition
                                                          was generated comes to the highest stage.0b0: No error               */
      __I  uint32_t  PE         :  1;               /*!< Parity error 0b1: Error occurrence If the reception data does
                                                         not satisfy the configured parity condition, 0b1 is set. In
                                                          FIFO mode, 0b1 is set when the reception data for which that
                                                          condition was generated comes to the highest stage.0b0: No error     */
      __I  uint32_t  BE         :  1;               /*!< Break error0b1: Error occurrence Indicates that the break condition
                                                         was detected (break status: Low input equal to or greater than
                                                          'reception data + status bit). In FIFO mode, 0b1 is set when
                                                          the reception data for which that condition was generated comes
                                                          to the highest stage. The reception data after the break condition
                                                          was detected is subject to marking (High status acceptance),
                                                          resulting in a wait for the next start bit detection.0b0: No
                                                          error                                                                */
      __I  uint32_t  OE         :  1;               /*!< Overrun error 0b1: Error occurrence If FIFO is full of data
                                                         at data reception and reception data becomes ready to be stored,
                                                          0b1 is stored at next FIFO fetching. The data stored in FIFO
                                                          remains unchanged and reception data in the shift register used
                                                          before FIFO storing is overwritten.0b0: No error If FIFO becomes
                                                          ready to store data, 0b0 is stored at next FIFO fetching.            */
           uint32_t : 20; // padding
    } UARTDR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTRSR_ECR;                     /*!< UART Receive status Register/Error clear Register                     */
    
    struct {
      __IO uint32_t  FE         :  1;               /*!< At reading: Framing error0b1: Error occurrence0b0: No error
                                                         At writing: The error flag can be cleared by writing to this
                                                          register, regardless of the data value.                              */
      __IO uint32_t  PE         :  1;               /*!< At reading: Parity error0b1: Error occurrence0b0: No error At
                                                         writing: The error flag can be cleared by writing to this register,
                                                          regardless of the data value.                                        */
      __IO uint32_t  BE         :  1;               /*!< At reading: Break error0b1: Error occurrence0b0: No error At
                                                         writing: The error flag can be cleared by writing to this register,
                                                          regardless of the data value.                                        */
      __IO uint32_t  OE         :  1;               /*!< At reading: Overrun error0b1: Error occurrence0b0: No error
                                                         At writing: The error flag can be cleared by writing to this
                                                          register, regardless of the data value.                              */
           uint32_t : 28; // padding
    } UARTRSR_ECR_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[4];
  
  union {
    __I  uint32_t  UARTFR;                          /*!< UART Flag Register                                                    */
    
    struct {
      __I  uint32_t  CTS        :  1;               /*!< nUARTCTS terminal status (Clear To Send)0b1:nUARTCTS =Low input
                                                         status0b0:nUARTCTS =High input status                                 */
           uint32_t             :  2;
      __I  uint32_t  BUSY       :  1;               /*!< Busy status0b1: Data transmission in progress0b0: Idle status
                                                         without transmission data                                             */
      __I  uint32_t  RXFE       :  1;               /*!< Reception FIFO Empty0b1: Reception FIFO empty (FIFO mode)/reception
                                                         retention register empty (FIFO disable)0b0: Data existence in
                                                          reception FIFO (FIFO mode)/data existence in the reception retention
                                                          register (FIFO disable)                                              */
      __I  uint32_t  TXFF       :  1;               /*!< Transmission FIFO Full0b1: Transmission FIFO full of data (FIFO
                                                         mode)/transmission retention register full of data (FIFO disable)0b0:
                                                          Transmission FIFO not full of data (FIFO mode)/transmission
                                                          retention register not full of data(FIFO disable)                    */
      __I  uint32_t  RXFF       :  1;               /*!< Reception FIFO Full0b1: Reception FIFO full of data (FIFO mode)/reception
                                                         retention register full of data (FIFO disable)0b0: Reception
                                                          FIFO not full of data (FIFO mode)/reception retention register
                                                          not full of data(FIFO disable)                                       */
      __I  uint32_t  TXFE       :  1;               /*!< Transmission FIFO Empty0b1: Transmission FIFO empty (FIFO mode)/transmissi
                                                         on retention register empty (FIFO disable)0b0: Data existence
                                                         in transmission FIFO (FIFO mode)/data existence in the transmission
                                                          retention register (FIFO disable)                                    */
      __I  uint32_t  RI         :  1;               /*!< (Ring Indicator) nUARTRI terminal status0b1:nUARTRI = Low input
                                                         status0b0:nUARTRI = High input status                                 */
           uint32_t : 23; // padding
    } UARTFR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[2];
  
  union {
    __IO uint32_t  UARTIBRD;                        /*!< UART Integer part of the Baud Rate Divisor Register                   */
    
    struct {
      __IO uint32_t  BAUD_DIVINT: 16;               /*!< For baud rate generation (integer value)                              */
           uint32_t : 16; // padding
    } UARTIBRD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTFBRD;                        /*!< UART Fractional part of the Baud Rate Divisor Register                */
    
    struct {
      __IO uint32_t  BAUD_DIVFRAC:  6;              /*!< For baud rate generation (fractional value)The baud rate divisor
                                                         can be obtained as follows:Baud rate divisor BAUDDIV =(FUARTCLK/(16
                                                          * baud rate)FUARTCLK is a UART reference clock frequency.BAUDDIV
                                                          consists of an integer value (BAUD DIVINT) and fractional value
                                                          (BAUD DIVFRAC).(Note) Transmission and reception operations
                                                          are disabled if both BAUD DIVINT and BAUD DIVFRAC are set to
                                                          0x00.                                                                */
           uint32_t : 26; // padding
    } UARTFBRD_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTLCR_H;                       /*!< UART Line control register                                            */
    
    struct {
      __IO uint32_t  BRK        :  1;               /*!< Break transmission0b1:Break transmission0b0: Normal transmission(Note)
                                                         Data needs to be written in the following order in setting the
                                                          UARTTIBRD, UARTTFBRD, and UARTLCR_H registers. UARTLCR_H writing
                                                          should be done last. (Example 1) UARTIBRD writing, UARTFBRD
                                                          writing, UARTLCR_H writing (Example 2) UARTFBRD writing, UARTIBRD
                                                          writing, UARTLCR_H writing                                           */
      __IO uint32_t  PEN        :  1;               /*!< Parity enable0b1: Enable0b0: Disable                                  */
      __IO uint32_t  EPS        :  1;               /*!< Even parity selection0b1: Even parity0b0: Odd parity                  */
      __IO uint32_t  STP2       :  1;               /*!< Stop bit length selection0b1: 2-bit length0b0: 1-bit length           */
      __IO uint32_t  FEN        :  1;               /*!< FIFO enable0b1: Enable. FIFO mode is entered.0b0: Disable             */
      __IO uint32_t  WLE        :  2;               /*!< Transfer bit length 0b11: 8-bit length0b10: 7-bit length0b01:
                                                         6-bit length0b00: 5-bit length                                        */
      __IO uint32_t  SPS        :  1;               /*!< Stick parity selection0b1: Enable With PEN=1, EPS=0, and SPS=1,
                                                         transmission or reception is checked with parity bit =1. With
                                                          PEN=1, EPS=1, and SPS=1, transmission or reception is checked
                                                          with parity bit =0.0b0: Disable                                      */
           uint32_t : 24; // padding
    } UARTLCR_H_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTCR;                          /*!< UART Control Register                                                 */
    
    struct {
      __IO uint32_t  UARTEN     :  1;               /*!< UART enable0b1: Enable. If transmission or reception is disabled
                                                         midway, it stops after completing the current transmission or
                                                          reception processing.0b0: Disable                                    */
           uint32_t             :  6;
      __IO uint32_t  LBE        :  1;               /*!< Loopback enable0b1: Enable0b0: Disable                                */
      __IO uint32_t  TXE        :  1;               /*!< Transmission enable0b1: Enable. If transmission is disabled
                                                         midway, it stops after data being currently transmitted has
                                                          been transmitted. 0b0: Disable                                       */
      __IO uint32_t  RXE        :  1;               /*!< Reception enable0b1: Enable. If reception is disabled midway,
                                                         it stops after data being currently received has been received.
                                                          0b0: Disable                                                         */
           uint32_t             :  1;
      __IO uint32_t  RTS        :  1;               /*!< nUARTRTS output control0b1:nUARTRTS=Low output0b0:nUARTRTS=High
                                                         output                                                                */
           uint32_t             :  2;
      __IO uint32_t  RTSEn      :  1;               /*!< RTS hardware flow control0b1: Enable. Data is requested only
                                                         when reception FIFO contains space for receiving that data.0b0:
                                                          Disable                                                              */
      __IO uint32_t  CTSEn      :  1;               /*!< CTS hardware flow control0b1: Enable. Data is not transmitted
                                                         until the nUARTCTS signal is asserted.0b0: Disable                    */
           uint32_t : 16; // padding
    } UARTCR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTIFLS;                        /*!< UART Interrupt FIFO Level Select Register                             */
    
    struct {
      __IO uint32_t  TXIFLSEL   :  3;               /*!< Transmission interrupt FIFO level selection (trigger occurs
                                                         when FIFO becomes equal to or less than the setting level.)0b111
                                                          - 0b101:reserved0b100: Transmission FIFO<= 7/8 Full0b011: Transmission
                                                          FIFO<= 3/4 Full0b010: Transmission FIFO<= 1/2 Full0b001: Transmission
                                                          FIFO<= 1/4 Full0b000: Transmission FIFO<= 1/8 Full(Note) For
                                                          UART, the 16byte FIFO is configured. So, each FIFO level indicates
                                                          the following size. 1/8 Full = 2byte, 1/4 Full = 4byte, 1/2
                                                          Full = 8byte, 3/4 Full = 12byte, 7/8 Full = 14byte                   */
      __IO uint32_t  RXIFLSEL   :  3;               /*!< Reception interrupt FIFO level selection (trigger occurs when
                                                         FIFO becomes equal to or greater than the setting level.)0b111
                                                          - 0b101:reserved0b100: Reception FIFO>= 7/8 Full0b011: Reception
                                                          FIFO>= 3/4 Full0b010: Reception FIFO>= 1/2 Full0b001: Reception
                                                          FIFO>= 1/4 Full0b000: Reception FIFO>= 1/8 Full                      */
           uint32_t : 26; // padding
    } UARTIFLS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTIMSC;                        /*!< UART Interrupt Mask Set/Clear                                         */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  CTSMIM     :  1;               /*!< nUARTCTS modem interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
           uint32_t             :  2;
      __IO uint32_t  RXIM       :  1;               /*!< Reception interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
      __IO uint32_t  TXIM       :  1;               /*!< Transmission interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
      __IO uint32_t  RTIM       :  1;               /*!< Reception timeout interrupt0b1: No interrupt mask (interrupt
                                                         enable)0b0: Interrupt mask (interrupt disable)                        */
      __IO uint32_t  FEIM       :  1;               /*!< Framing error interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
      __IO uint32_t  PEIM       :  1;               /*!< Parity error interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
      __IO uint32_t  BEIM       :  1;               /*!< Break error interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
      __IO uint32_t  OEIM       :  1;               /*!< Overrun error interrupt0b1: No interrupt mask (interrupt enable)0b0:
                                                         Interrupt mask (interrupt disable)                                    */
           uint32_t : 21; // padding
    } UARTIMSC_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTRIS;                         /*!< UART Raw Interrupt Status Register                                    */
    
    struct {
           uint32_t             :  1;
      __I  uint32_t  CTSMRIS    :  1;               /*!< nUARTCTS modem interrupt0b1: Interrupt request available (UART
                                                         interrupt occurrence before masking)0b0: No interrupt (UART
                                                          interrupt occurrence before masking)The value depends on wire
                                                          connection. An interrupt request occurs every time the signal
                                                          state changes.                                                       */
           uint32_t             :  2;
      __I  uint32_t  RXRIS      :  1;               /*!< Reception interrupt0b1: Interrupt request available (UART interrupt
                                                         occurrence before masking)0b0: No interrupt request (UART interrupt
                                                          occurrence before masking)                                           */
      __I  uint32_t  TXRIS      :  1;               /*!< Transmission interrupt0b1: Interrupt request available (UART
                                                         interrupt occurrence before masking)0b0: No interrupt request
                                                          (UART interrupt occurrence before masking)                           */
      __I  uint32_t  RTRIS      :  1;               /*!< Reception timeout interrupt0b1: Interrupt request available
                                                         (UART interrupt occurrence before masking)0b0: No interrupt
                                                          request (UART interrupt occurrence before masking)(Note) Unlike
                                                          other bits, RTRIS does not become 0b1 until RTIM=1 is set.           */
      __I  uint32_t  FERIS      :  1;               /*!< Framing error interrupt0b1: Interrupt request available (UART
                                                         interrupt occurrence before masking)0b0: No interrupt request
                                                          (UART interrupt occurrence before masking)                           */
      __I  uint32_t  PERIS      :  1;               /*!< Parity error interrupt0b1: Interrupt request available (UART
                                                         interrupt occurrence before masking)0b0: No interrupt request
                                                          (UART interrupt occurrence before masking)                           */
      __I  uint32_t  BERIS      :  1;               /*!< Break error interrupt0b1: Interrupt request available (UART
                                                         interrupt occurrence before masking)0b0: No interrupt request
                                                          (UART interrupt occurrence before masking)                           */
      __I  uint32_t  OERIS      :  1;               /*!< Overrun error interrupt0b1: Interrupt request available (UART
                                                         interrupt occurrence before masking)0b0: No interrupt request
                                                          (UART interrupt occurrence before masking)                           */
           uint32_t : 21; // padding
    } UARTRIS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTMIS;                         /*!< UART Masked Interrupt Status Register                                 */
    
    struct {
           uint32_t             :  1;
      __I  uint32_t  CTSMMIS    :  1;               /*!< nUARTCTS modem interrupt                                              */
           uint32_t             :  2;
      __I  uint32_t  RXMIS      :  1;               /*!< Reception interrupt                                                   */
      __I  uint32_t  TXMIS      :  1;               /*!< Transmission interrupt                                                */
      __I  uint32_t  RTMIS      :  1;               /*!< Reception timeout interrupt                                           */
      __I  uint32_t  FEMIS      :  1;               /*!< Framing error interrupt                                               */
      __I  uint32_t  PEMIS      :  1;               /*!< Parity error interrupt                                                */
      __I  uint32_t  BEMIS      :  1;               /*!< Break error interrupt                                                 */
      __I  uint32_t  OEMIS      :  1;               /*!< Overrun error interrupt                                               */
           uint32_t : 21; // padding
    } UARTMIS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTICR;                         /*!< UART Interrupt Clear Register                                         */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  CTSMIC     :  1;               /*!< nUARTCTS modem interrupt0b1: Interrupt request clear0b0: No
                                                         operation                                                             */
           uint32_t             :  2;
      __IO uint32_t  RXIC       :  1;               /*!< Reception interrupt0b1: Interrupt request clear0b0: No operation      */
      __IO uint32_t  TXIC       :  1;               /*!< Transmission interrupt0b1: Interrupt request clear0b0: No operation   */
      __IO uint32_t  RTIC       :  1;               /*!< Reception timeout interrupt0b1: Interrupt request clear0b0:
                                                         No operation                                                          */
      __IO uint32_t  FEIC       :  1;               /*!< Framing error interrupt0b1: Interrupt request clear0b0: No operation  */
      __IO uint32_t  PEIC       :  1;               /*!< Parity error interrupt0b1: Interrupt request clear0b0: No operation   */
      __IO uint32_t  BEIC       :  1;               /*!< Break error interrupt0b1: Interrupt request clear0b0: No operation    */
      __IO uint32_t  OEIC       :  1;               /*!< Overrun error interrupt0b1: Interrupt request clear0b0: No operation  */
           uint32_t : 21; // padding
    } UARTICR_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTDMACR;                       /*!< UART DMA Control Register                                             */
    
    struct {
      __IO uint32_t  RXDMAE     :  1;               /*!< Reception FIFO DMA enable0b1: DMA request enable0b0: No DMA
                                                         request                                                               */
      __IO uint32_t  TXDMAE     :  1;               /*!< Transmission FIFO DMA enable0b1: DMA request enable0b0: No DMA
                                                         request                                                               */
      __IO uint32_t  DMAONERR   :  1;               /*!< DMA on Error0b1: Disables the DMA request if UART generates
                                                         Error interrupt.0b0: Normal operation                                 */
           uint32_t : 29; // padding
    } UARTDMACR_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[13];
  
  union {
    __IO uint32_t  UARTTCR;                         /*!< UART Test Control Register                                            */
    
    struct {
      __IO uint32_t  ITEN       :  1;               /*!< Integration test enable 0b1: Test mode 0b0: Normal operation          */
      __IO uint32_t  TESTFIFO   :  1;               /*!< Test FIFO enable 0b1: Test mode 0b0: Normal operation                 */
           uint32_t : 30; // padding
    } UARTTCR_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTITIP;                        /*!< UART Integration Test InPut Register                                  */
    
    struct {
      __I  uint32_t  UARTRXD    :  1;               /*!< At reading, reads the UARTRXD terminal status.                        */
           uint32_t             :  2;
      __I  uint32_t  nUARTCTS   :  1;               /*!< At reading, reads the nUARTCTS terminal status.                       */
           uint32_t             :  2;
      __IO uint32_t  UARTRXDMACLR:  1;              /*!< AT writing, output to the UARTRXDMACLR terminalAt reading, reading
                                                         of the UARTRXDMACLR terminal status                                   */
      __IO uint32_t  UARTTXDMACLR:  1;              /*!< AT writing, output to the UARTTXDMACLR terminalAt reading, reading
                                                         of the UARTTXDMACLR terminal status                                   */
           uint32_t : 24; // padding
    } UARTITIP_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTITOP;                        /*!< UART Integration Test OutPut Register                                 */
    
    struct {
      __IO uint32_t  UARTTXD    :  1;               /*!< At writing, makes output to the UARTTXD terminal.                     */
           uint32_t             :  2;
      __IO uint32_t  nUARTRTS   :  1;               /*!< At writing, makes output to the nUARTRTS terminal.                    */
           uint32_t             :  2;
      __IO uint32_t  UARTINTR   :  1;               /*!< At writing, makes output to the UARTINTR terminal.At reading,
                                                         reads the UARTINTR terminal status.                                   */
      __IO uint32_t  UARTEINTR  :  1;               /*!< At writing, makes output to the UARTEINTR terminal.At reading,
                                                         reads the UARTEINTR terminal status.                                  */
      __IO uint32_t  UARTRTINTR :  1;               /*!< At writing, makes output to the UARTRTINTR terminal.At reading,
                                                         reads the UARTRTINTR terminal status.                                 */
      __IO uint32_t  UARTTXINTR :  1;               /*!< At writing, makes output to the UARTTXINTR terminal.At reading,
                                                         reads the UARTTXINTR terminal status.                                 */
      __IO uint32_t  UARTRXINTR :  1;               /*!< At writing, makes output to the UARTRXINTR terminal.At reading,
                                                         reads the UARTRXINTR terminal status.                                 */
      __IO uint32_t  UARTMSINTR :  1;               /*!< At writing, makes output to the UARTMSINTR terminal.At reading,
                                                         reads the UARTMSINTR terminal status.                                 */
      __IO uint32_t  UARTRXDMABREQ:  1;             /*!< At writing, makes output to the UARTRXDMABREQ terminal.At reading,
                                                         reads the UARTRXDMABREQ terminal status.                              */
      __IO uint32_t  UARTRXDMASREQ:  1;             /*!< At writing, makes output to the UARTRXDMASREQ terminal.At reading,
                                                         reads the UARTRXDMASREQ terminal status.                              */
      __IO uint32_t  UARTTXDMABREQ:  1;             /*!< At writing, makes output to the UARTTXDMABREQ terminal.At reading,
                                                         reads the UARTTXDMABREQ terminal status.                              */
      __IO uint32_t  UARTTXDMASREQ:  1;             /*!< At writing, makes output to the UARTTXDMASREQ terminal.At reading,
                                                         reads the UARTTXDMASREQ terminal status.                              */
           uint32_t : 16; // padding
    } UARTITOP_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  UARTTDR;                         /*!< UART Test Data Register                                               */
    
    struct {
      __IO uint32_t  UARTTDR    : 12;               /*!< At writing, data is written in reception FIFO.At reading, transmission
                                                         FIFO is read.                                                         */
           uint32_t : 20; // padding
    } UARTTDR_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[980];
  
  union {
    __I  uint32_t  UARTPERIPHID0;                   /*!< UART Peripheral ID0 Register                                          */
    
    struct {
      __I  uint32_t  Partnumber0:  8;               /*!< Partnumber(Lower) 011 =>11                                            */
           uint32_t : 24; // padding
    } UARTPERIPHID0_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTPERIPHID1;                   /*!< UART Peripheral ID1 Register                                          */
    
    struct {
      __I  uint32_t  Partnumber1:  4;               /*!< Partnumber(Upper) 011=>0                                              */
      __I  uint32_t  Designer0  :  4;               /*!< Designer(Lower) 41=>1                                                 */
           uint32_t : 24; // padding
    } UARTPERIPHID1_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTPERIPHID2;                   /*!< UART Peripheral ID2 Register                                          */
    
    struct {
      __I  uint32_t  Designer1  :  4;               /*!< Designer(Upper) 41=>4                                                 */
      __I  uint32_t  Revision   :  4;               /*!< Revision: r1p4 =>2                                                    */
           uint32_t : 24; // padding
    } UARTPERIPHID2_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTPERIPHID3;                   /*!< UART Peripheral ID3 Register                                          */
    
    struct {
      __I  uint32_t  Configuration:  8;             /*!< Configuration: 00                                                     */
           uint32_t : 24; // padding
    } UARTPERIPHID3_b;                              /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTPCELLID0;                    /*!< UART PrimeCell ID0 Register                                           */
    
    struct {
      __I  uint32_t  PCellID0   :  8;               /*!< Fixed value                                                           */
           uint32_t : 24; // padding
    } UARTPCELLID0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTPCELLID1;                    /*!< UART PrimeCell ID1 Register                                           */
    
    struct {
      __I  uint32_t  PCellID1   :  8;               /*!< Fixed value                                                           */
           uint32_t : 24; // padding
    } UARTPCELLID1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTPCELLID2;                    /*!< UART PrimeCell ID2 Register                                           */
    
    struct {
      __I  uint32_t  PCellID2   :  8;               /*!< Fixed value                                                           */
           uint32_t : 24; // padding
    } UARTPCELLID2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  UARTPCELLID3;                    /*!< UART PrimeCell ID3 Register                                           */
    
    struct {
      __I  uint32_t  PCellID3   :  8;               /*!< Fixed value                                                           */
           uint32_t : 24; // padding
    } UARTPCELLID3_b;                               /*!< BitSize                                                               */
  };
} uart_Type;


/* ================================================================================ */
/* ================                     usb2fs                     ================ */
/* ================================================================================ */


/**
  * @brief usb2fs (usb2fs)
  */

typedef struct {                                    /*!< usb2fs Structure                                                      */
  
  union {
    __IO uint32_t  GOTGCTL;                         /*!< OTG Control and Status Register                                       */
    
    struct {
           uint32_t             :  6;
      __IO uint32_t  BvalidOvEn :  1;               /*!< BvalidOvEn                                                            */
      __IO uint32_t  BvalidOvVal:  1;               /*!< Mode: Device onlyB-Peripheral Session Valid Override Value (BvalidOvVal)Th
                                                         is bit is used to set Override value for Bvalid signal when [GOTGCTL].Bvali
                                                         dOvEn is set.- 1b0: Bvalid value is 1b0 when [GOTGCTL].BvalidOvEn
                                                         =1- 1b1: Bvalid value is 1b1 when [GOTGCTL].BvalidOvEn =1             */
           uint32_t             :  8;
      __I  uint32_t  ConIDSts   :  1;               /*!< Mode: Host and DeviceConnector ID Status (ConIDSts)Indicates
                                                         the connector ID status on a connect event.- 1b0: The DWC_otg
                                                          core is in A-Device mode- 1b1: The DWC_otg core is in B-Device
                                                          mode                                                                 */
           uint32_t             :  2;
      __I  uint32_t  BSesVld    :  1;               /*!< Mode: Device onlyB-Session Valid (BSesVld)Indicates the Device
                                                         mode transceiver status.- 1b0: B-session is not valid.- 1b1:
                                                          B-session is valid.In OTG mode, you can use this bit to determine
                                                          if the device is connected or disconnected.Note: If you do not
                                                          enable OTG features (such as SRP and HNP), the read reset value
                                                          will be 1.The vbus assigns the values internally for non-SRP
                                                          or non-HNP configurations.                                           */
      __IO uint32_t  OTGVer     :  1;               /*!< OTG Version (OTGVer)Indicates the OTG revision.- 1b0: OTG Version
                                                         1.3. In this version the core supports Data line pulsing and
                                                          VBus pulsing for SRP.- 1b1: OTG Version 2.0. In this version
                                                          the core supports only Data line pulsing for SRP.                    */
      __I  uint32_t  CurMod     :  1;               /*!< Current Mode of Operation (CurMod)Mode: Host and DeviceIndicates
                                                         the current mode.- 1b0: Device mode- 1b1: Host mode                   */
           uint32_t : 10; // padding
    } GOTGCTL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GOTGINT;                         /*!< OTG Interrupt Register                                                */
    
    struct {
           uint32_t             :  2;
      __IO uint32_t  SesEndDet  :  1;               /*!< Mode: Host and DeviceSession End Detected (SesEndDet)The core
                                                         sets this bit when the utmiotg_bvalid signal is deasserted.This
                                                          bit can be set only by the core and the application should write
                                                          1 to clear it.                                                       */
           uint32_t             :  5;
      __IO uint32_t  SesReqSucStsChng:  1;          /*!< Mode: Host and DeviceSession Request Success Status Change (SesReqSucStsCh
                                                         ng)The core sets this bit on the success or failure of a session
                                                         request. The application must read the Session Request Success
                                                          bit in the OTG Control and Status register ([GOTGCTL].SesReqScs)
                                                          to check for success or failure.This bit can be set only by
                                                          the core and the application should write 1 to clear it.             */
      __IO uint32_t  HstNegSucStsChng:  1;          /*!< Mode: Host and DeviceHost Negotiation Success Status Change
                                                         (HstNegSucStsChng)The core sets this bit on the success or failure
                                                          of a USB host negotiation request. The application must read
                                                          the Host Negotiation Success bit of the OTG Control and Status
                                                          register ([GOTGCTL].HstNegScs) to check for success or failure.This
                                                          bit can be set only by the core and the application should write
                                                          1 to clear it.                                                       */
           uint32_t             :  7;
      __IO uint32_t  HstNegDet  :  1;               /*!< Mode: Host and DeviceHost Negotiation Detected (HstNegDet)The
                                                         core sets this bit when it detects a host negotiation request
                                                          on the USB.This bit can be set only by the core and the pplication
                                                          should write 1 to clear it.                                          */
      __IO uint32_t  ADevTOUTChg:  1;               /*!< Mode: Host and DeviceA-Device Timeout Change (ADevTOUTChg)The
                                                         core sets this bit to indicate that the A-device has timed out
                                                          while waiting for the B-device to connect.This bit can be set
                                                          only by the core and the application should write 1 to clear
                                                          it.                                                                  */
           uint32_t : 13; // padding
    } GOTGINT_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GAHBCFG;                         /*!< AHB Configuration Register                                            */
    
    struct {
      __IO uint32_t  GlblIntrMsk:  1;               /*!< Mode: Host and deviceGlobal Interrupt Mask (GlblIntrMsk)The
                                                         application uses this bit to mask or unmask the interrupt line
                                                          assertion to itself. Irrespective of this bits setting, the
                                                          interrupt status registers are updated by the core.- 1b0: Mask
                                                          the interrupt assertion to the application.- 1b1: Unmask the
                                                          interrupt assertion to the application                               */
      __IO uint32_t  HBstLen    :  4;               /*!< Mode: Host and deviceBurst Length/Type (HBstLen)This field is
                                                         used in both External and Internal DMA modes. In External DMA
                                                          mode, these bits appear on dma_burst[3:0] ports, which can be
                                                          used by an external wrapper to interface the External DMA Controller
                                                          interface to Synopsys DW_ahb_dmac or ARM PrimeCell.External
                                                          DMA Mode defines the DMA burst length in terms of 32-bit words:-
                                                          4b0000: 1 word- 4b0001: 4 words- 4b0010: 8 words- 4b0011: 16
                                                          words- 4b0100: 32 words- 4b0101: 64 words- 4b0110: 128 words-
                                                          4b0111:                                                              */
      __IO uint32_t  DMAEn      :  1;               /*!< Mode: Host and deviceDMA Enable (DMAEn)- 1b0: Core operates
                                                         in Slave mode- 1b1: Core operates in a DMA modeThis bit is always
                                                          0 when Slave-Only mode has been selected.                            */
           uint32_t             :  1;
      __IO uint32_t  NPTxFEmpLvl:  1;               /*!< Mode: Host and deviceNon-Periodic TxFIFO Empty Level (NPTxFEmpLvl)This
                                                         bit is used only in Slave mode. In host mode and with Shared
                                                          FIFO with device mode, this bit indicates when the Non-Periodic
                                                          TxFIFO Empty Interrupt bit in the Core Interrupt register ([GINTSTS].NPTxF
                                                         Emp) is triggered. With dedicated FIFO in device mode, this bit
                                                          indicates when IN endpoint Transmit FIFO empty interrupt ([DIEPINTn].TxFEm
                                                         p) is triggered. Host mode and with Shared FIFO with device mode:-
                                                          1b0: [GINTSTS].NPTxFEmp interrupt in                                 */
           uint32_t             : 13;
      __IO uint32_t  RemMemSupp :  1;               /*!< Mode: Host and DeviceRemote Memory Support (RemMemSupp)This
                                                         bit is programmed to enable the functionality to wait for the
                                                          system DMA Done Signal for the DMA Write Transfers.- [GAHBCFG].RemMemSupp=
                                                         1The int_dma_req output signal is asserted when HSOTG DMA starts
                                                          write transfer to the external memory. When the core is done
                                                          with theTransfers it asserts int_dma_done signal to flag the
                                                          completion of DMA writes from HSOTG. The core then waits for
                                                          sys_dma_done signal from the system to proceed further and complete  */
      __IO uint32_t  NotiAllDmaWrit:  1;            /*!< Mode: Host and DeviceNotify all DMA Write Transactions (NotiAllDmaWrit)Thi
                                                         s bit is programmed to enable the System DMA Done functionality
                                                         for all the DMA write Transactions corresponding to the Channel/Endpoint.
                                                          This bit is valid only when [GAHBCFG].RemMemSupp is set to 1.-
                                                          [GAHBCFG].NotiAllDmaWrit = 1 DWC_otg core asserts int_dma_req
                                                          for all the DMA write transactions on the AHB interface along
                                                          with int_dma_done, chep_last_transact and chep_number signal
                                                          informations. The core waits for sys_dma_done signa                  */
      __IO uint32_t  AHBSingle  :  1;               /*!< Mode: Host and DeviceAHBSingleSupport (AHBSingle)This bit when
                                                         programmed supports Single transfers for the remaining data
                                                          in a transfer when the DWC_otg core is operating in DMA mode.-
                                                          1b0: This is the default mode. When this bit is set to 1b0,
                                                          the remaining data in the transfer is sent using INCR burst
                                                          size.- 1b1: When set to 1b1, the remaining data in a transfer
                                                          is sent using Single burst size.Note: If this feature is enabled,
                                                          the AHB RETRY and SPLIT transfers still have INCR burst type.
                                                          Enable this fea                                                      */
           uint32_t : 8; // padding
    } GAHBCFG_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GUSBCFG;                         /*!< USB Configuration Register                                            */
    
    struct {
      __IO uint32_t  TOutCal    :  3;               /*!< Mode: Host and DeviceHS/FS Timeout Calibration (TOutCal)The
                                                         number of PHY clocks that the application programs in this field
                                                          is added to the high-speed/full-speed interpacket timeout duration
                                                          in the core to account for any additional delays introduced
                                                          by the PHY. This can be required, because the delay introduced
                                                          by the PHY in generating the linestate condition can vary from
                                                          one PHY to another. The USB standard timeout value for high-speed
                                                          operation is 736 to 816 (inclusive) bit times. The USB standard
                                                          tim                                                                  */
      __I  uint32_t  PHYIf      :  1;               /*!< Mode: Host and DevicePHY Interface (PHYIf)The application uses
                                                         this bit to configure the core to support a UTMI+ PHY with an
                                                          8- or 16-bit interface. When a ULPI PHY is chosen, this must
                                                          be set to 8-bit mode.- 1b0: 8 bits- 1b1: 16 bitsThis bit is
                                                          writable only If UTMI+ and ULPI were selected. Otherwise, this
                                                          bit returns the value for the power-on interface selected during
                                                          configuration.                                                       */
           uint32_t             :  1;
      __IO uint32_t  FSIntf     :  1;               /*!< Mode: Host and DeviceFull-Speed Serial Interface Select (FSIntf)The
                                                         application uses this bit to select either a unidirectional
                                                          or bidirectional USB 1.1 full-speed serial transceiver interface.-
                                                          1b0: 6-pin unidirectional full-speed serial interface- 1b1:
                                                          3-pin bidirectional full-speed serial interfaceIf a USB 1.1
                                                          Full-Speed Serial Transceiver interface was not selected, this
                                                          bit is always 0, with Read Only access. If a USB 1.1 FS interface
                                                          was selected, then the application can set this bit to select
                                                          betwe                                                                */
      __IO uint32_t  PHYSel     :  1;               /*!< Mode: Host and DeviceUSB 2.0 High-Speed PHY or USB 1.1 Full-Speed
                                                         Serial Transceiver Select (PHYSel)The application uses this
                                                          bit to select either a high-speed UTMI+ or ULPI PHY, or a full-speed
                                                          transceiver.- 1b0: USB 2.0 high-speed UTMI+ or ULPI PHY- 1b1:
                                                          USB 1.1 full-speed serial transceiverIf a USB 1.1 Full-Speed
                                                          Serial Transceiver interface was not selected, this bit is always
                                                          0, with Read Only access. If a high-speed PHY interface was
                                                          not selected, this bit is always 1, with Read Only access. If
                                                          both                                                                 */
           uint32_t             :  3;
      __IO uint32_t  USBTrdTim  :  4;               /*!< Mode: Device onlyUSB Turnaround Time (USBTrdTim)Sets the turnaround
                                                         time in PHY clocks. Specifies the response time for a MAC request
                                                          to the Packet FIFO Controller (PFC) to fetch data from the DFIFO
                                                          (SPRAM). This must be programmed to- 4h5: When the MAC interface
                                                          is 16-bit UTMI+.- 4h9: When the MAC interface is 8-bit UTMI+.Note:
                                                          The values above are calculated for the minimum AHB frequency
                                                          of 30 MHz. USB turnaround time is critical for certification
                                                          where long cables and 5-Hubs are used, so If you need the            */
           uint32_t             :  8;
      __IO uint32_t  TermSelDLPulse:  1;            /*!< Mode: Device onlyTermSel DLine Pulsing Selection (TermSelDLPulse)This
                                                         bit selects utmi_termselect to drive data line pulse during
                                                          SRP.- 1b0: Data line pulsing using utmi_txvalid (Default).-
                                                          1b1: Data line pulsing using utmi_termsel.                           */
           uint32_t             :  3;
      __I  uint32_t  IC_USBCap  :  1;               /*!< Mode: Host and DeviceIC_USB-Capable (IC_USBCap)The application
                                                         uses this bit to control the DWC_otg cores IC_USB capabilities.-
                                                          1b0: IC_USB PHY Interface is not selected.- 1b1: IC_USB PHY
                                                          Interface is selected.                                               */
           uint32_t             :  1;
      __IO uint32_t  TxEndDelay :  1;               /*!< Mode: Device onlyTx End Delay (TxEndDelay)Writing 1b1 to this
                                                         bit enables the core to follow the TxEndDelay timings as per
                                                          UTMI+ specification 1.05 section 4.1.5 for opmode signal during
                                                          remote wakeup.- 1b0: Normal Mode.- 1b1: Tx End delay.                */
      __I  uint32_t  ForceDevMode:  2;              /*!< Reserved for future use.                                              */
      __IO uint32_t  CorruptTxPkt:  1;              /*!< Mode: Host and deviceCorrupt Tx packet (CorruptTxPkt)This bit
                                                         is for debug purposes only. Never set this bit to 1. Theapplication
                                                          should always write 1b0 to this bit.                                 */
    } GUSBCFG_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GRSTCTL;                         /*!< Reset Register                                                        */
    
    struct {
      __IO uint32_t  CSftRst    :  1;               /*!< Mode: Host and DeviceCore Soft Reset (CSftRst)Resets the hclk
                                                         and phy_clock domains as follows:- Clears the interrupts and
                                                          all the CSR registers except the following register bits:- [PCGCCTL].RstPd
                                                         wnModule- [PCGCCTL].GateHclk- [PCGCCTL].PwrClmp- [PCGCCTL].StopPPhyLPwrClkS
                                                         elclk- [GUSBCFG].PhyLPwrClkSel- [GUSBCFG].DDRSel- [GUSBCFG].PHYSel-
                                                          [GUSBCFG].FSIntf- [GUSBCFG].ULPI_UTMI_Sel- [GUSBCFG].PHYIf-
                                                          [GUSBCFG].TxEndDelay- [GUSBCFG].TermSelDLPulse- [GUSBCFG].ULPIClkSusM-
                                                          [GUSBCFG].ULPIAutoRes- [GUSBCFG].ULPIFsL                             */
      __IO uint32_t  PIUFSSftRst:  1;               /*!< Mode: Host and DevicePIU FS Dedicated Controller Soft Reset
                                                         (PIUFSSftRst)Resets the PIU FS Dedicated Controller All module
                                                          state machines in FS Dedicated Controller of PIU are reset to
                                                          the IDLE state. Used to reset the FS Dedicated controller in
                                                          PIU in case of any PHY Errors like Loss of activity or Babble
                                                          Error resulting in the PHY remaining in RX state for more than
                                                          one frame boundary. This is a self clearing bit and core clears
                                                          this bit after all the necessary logic is reset in the core.         */
      __IO uint32_t  FrmCntrRst :  1;               /*!< Mode: Host onlyHost Frame Counter Reset (FrmCntrRst)The application
                                                         writes this bit to reset the (micro)frame number counter inside
                                                          the core. When the (micro)frame counter is reset, the subsequent
                                                          SOF sent out by the core has a (micro)frame number of 0. If
                                                          the application writes 1 to the bit, it may not be able to read
                                                          back the value as it gets cleared by the core in a few clock
                                                          cycles.                                                              */
      __IO uint32_t  INTknQFlsh :  1;               /*!< Mode: Device onlyIN Token Sequence Learning Queue Flush (INTknQFlsh)The
                                                         application writes this bit to flush the IN Token Sequence Learning
                                                          Queue.                                                               */
      __IO uint32_t  RxFFlsh    :  1;               /*!< Mode: Host and DeviceRxFIFO Flush (RxFFlsh)The application can
                                                         flush the entire RxFIFO using this bit, but must first ensure
                                                          that the core is not in the middle of a transaction. The application
                                                          must only write to this bit after checking that the core is
                                                          neither reading from the RxFIFO nor writing to the RxFIFO. The
                                                          application must wait until the bit is cleared before performing
                                                          any other operations. This bit requires 8 clocks (slowest of
                                                          PHY or AHB clock) to clear.                                          */
      __IO uint32_t  TxFFlsh    :  1;               /*!< Mode: Host and DeviceTxFIFO Flush (TxFFlsh)This bit selectively
                                                         flushes a single or all transmit FIFOs, but cannot do so if
                                                          the core is in the midst of a transaction. The application must
                                                          write this bit only after checking that the core is neither
                                                          writing to the TxFIFO nor reading from the TxFIFO. Verify using
                                                          these registers:- Read - NAK Effective Interrupt ensures the
                                                          core is not reading from the FIFO- Write - [GRSTCTL].AHBIdle
                                                          ensures the core is not writing anything to the FIFO.Flushing
                                                          is normally rec                                                      */
      __IO uint32_t  TxFNum     :  5;               /*!< Mode: Host and DeviceTxFIFO Number (TxFNum)This is the FIFO
                                                         number that must be flushed using the TxFIFO Flush bit. This
                                                          field must not be changed until the core clears the TxFIFO Flush
                                                          bit.- 5h0:- Non-periodic TxFIFO flush in Host mode- Non-periodic
                                                          TxFIFO flush in device mode when in shared FIFO operation- Tx
                                                          FIFO 0 flush in device mode when in dedicated FIFO mode- 5h1:-
                                                          Periodic TxFIFO flush in Host mode- Periodic TxFIFO 1 flush
                                                          in Device mode when in shared FIFO operation- TXFIFO 1 flush
                                                          in device mode                                                       */
           uint32_t             : 19;
      __I  uint32_t  DMAReq     :  1;               /*!< Mode: Host and DeviceDMA Request Signal (DMAReq)Indicates that
                                                         the DMA request is in progress. Used for debug.                       */
      __I  uint32_t  AHBIdle    :  1;               /*!< Mode: Host and DeviceAHB Master Idle (AHBIdle)Indicates that
                                                         the AHB Master State Machine is in the IDLE condition.                */
    } GRSTCTL_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GINTSTS;                         /*!< Interrupt Register                                                    */
    
    struct {
      __I  uint32_t  CurMod     :  1;               /*!< Mode: Host and DeviceCurrent Mode of Operation (CurMod)Indicates
                                                         the current mode.- 1b0: Device mode- 1b1: Host mode                   */
      __IO uint32_t  ModeMis    :  1;               /*!< Mode: Host and DeviceMode Mismatch Interrupt (ModeMis)The core
                                                         sets this bit when the application is trying to access:- A Host
                                                          mode register, when the core is operating in Device mode- A
                                                          Device mode register, when the core is operating in Host modeThe
                                                          register access is completed on the AHB with an OKAY response,
                                                          but is ignored by the core internally and does not affect the
                                                          operation of the core. This bit can be set only by the core
                                                          and the application should write 1 to clear it.                      */
      __I  uint32_t  OTGInt     :  1;               /*!< Mode: Host and DeviceOTG Interrupt (OTGInt)The core sets this
                                                         bit to indicate an OTG protocol event. The application must
                                                          read the OTG Interrupt Status ([GOTGINT]) register to determine
                                                          the exact event that caused this interrupt. The application
                                                          must clear the appropriate status bit in the [GOTGINT] register
                                                          to clear this bit.                                                   */
      __IO uint32_t  Sof        :  1;               /*!< Mode: Host and DeviceStart of (micro)Frame (Sof)In Host mode,
                                                         the core sets this bit to indicate that an SOF (FS), micro-SOF
                                                          (HS), or Keep-Alive (LS) is transmitted on the USB. The application
                                                          must write a 1 to this bit to clear the interrupt. In Device
                                                          mode, in the core sets this bit to indicate that an SOF token
                                                          has been received on the USB. The application can read the Device
                                                          Status register to get the current (micro)Frame number. This
                                                          interrupt is seen only when the core is operating at either
                                                          HS or FS                                                             */
      __I  uint32_t  RxFLvl     :  1;               /*!< Mode: Host and DeviceRxFIFO Non-Empty (RxFLvl)Indicates that
                                                         there is at least one packet pending to be read from the RxFIFO.      */
      __I  uint32_t  NPTxFEmp   :  1;               /*!< Mode: Host and DeviceNon-periodic TxFIFO Empty (NPTxFEmp)This
                                                         interrupt is asserted when the Non-periodic TxFIFO is either
                                                          half or completely empty, and there is space for at least one
                                                          entry to be written to the Non-periodic Transmit Request Queue.
                                                          The half or completely empty status is determined by the Non-periodic
                                                          TxFIFOEmpty Level bit in the Core AHB Configuration register
                                                          ([GAHBCFG].NPTxFEmpLvl).                                             */
      __I  uint32_t  GINNakEff  :  1;               /*!< Mode: Device onlyGlobal IN Non-periodic NAK Effective (GINNakEff)Indicates
                                                         that the Set Global Non-periodic IN NAK bit in the Device Control
                                                          register ([DCTL].SGNPInNak) set by the application has taken
                                                          effect in the core. That is, the core has sampled the Global
                                                          IN NAK bit set by the application. This bit can be cleared by
                                                          clearing the Clear Global Non-periodic IN NAK bit in the Device
                                                          Control register ([DCTL].CGNPInNak). This interrupt does not
                                                          necessarily mean that a NAK handshake is sent out on the USB.        */
      __I  uint32_t  GOUTNakEff :  1;               /*!< Global OUT NAK Effective (GOUTNakEff)Indicates that the Set
                                                         Global OUT NAK bit in the Device Control register ([DCTL].SGOUTNak)
                                                          set by the application has taken effect in the core. This bit
                                                          can be cleared by writing the Clear Global OUT NAK bit in the
                                                          Device Control register ([DCTL].CGOUTNak).                           */
           uint32_t             :  2;
      __IO uint32_t  ErlySusp   :  1;               /*!< Mode: Device onlyEarly Suspend (ErlySusp)The core sets this
                                                         bit to indicate that an Idle state has been detected on the
                                                          USB For 3 ms.                                                        */
      __IO uint32_t  USBSusp    :  1;               /*!< Mode: Device onlyUSB Suspend (USBSusp)The core sets this bit
                                                         to indicate that a suspend was detected on the USB. The core
                                                          enters the Suspend state when there is no activity on the linestate
                                                          signal for an extended period of time.                               */
      __IO uint32_t  USBRst     :  1;               /*!< Mode: Device onlyUSB Reset (USBRst)The core sets this bit to
                                                         indicate that a reset is detected on the USB.                         */
      __IO uint32_t  EnumDone   :  1;               /*!< Mode: Device onlyEnumeration Done (EnumDone)The core sets this
                                                         bit to indicate that speed enumeration is complete. The application
                                                          must read the Device Status ([DSTS]) register to obtain the
                                                          enumerated speed.                                                    */
      __IO uint32_t  ISOOutDrop :  1;               /*!< Mode: Device onlyIsochronous OUT Packet Dropped Interrupt (ISOOutDrop)The
                                                         core sets this bit when it fails to write an isochronous OUT
                                                          packet into the RxFIFO because the RxFIFO does not have enough
                                                          space to accommodate a maximum packet size packet for the isochronous
                                                          OUT endpoint.                                                        */
      __IO uint32_t  EOPF       :  1;               /*!< Mode: Device onlyEnd of Periodic Frame Interrupt (EOPF)Indicates
                                                         that the period specified in the Periodic Frame Interval field
                                                          of the Device Configuration register ([DCFG].PerFrInt) has been
                                                          reached in the current microframe.                                   */
           uint32_t             :  1;
      __IO uint32_t  EPMis      :  1;               /*!< Mode: Device onlyEndpoint Mismatch Interrupt (EPMis)Note: This
                                                         interrupt is valid only in shared FIFO operation.Indicates that
                                                          an IN token has been received for a non-periodic endpoint, but
                                                          the data for another endpoint is present in the top of the Non-periodic
                                                          Transmit FIFO and the IN endpoint mismatch count programmed
                                                          by the application has expired.                                      */
      __I  uint32_t  IEPInt     :  1;               /*!< Mode: Device onlyIN Endpoints Interrupt (IEPInt)The core sets
                                                         this bit to indicate that an interrupt is pending on one of
                                                          the IN endpoints of the core (in Device mode). The application
                                                          must read the Device All Endpoints Interrupt ([DAINT]) register
                                                          to determine the exact number of the IN endpoint on Device IN
                                                          Endpoint-n Interrupt ([DIEPINTn]) register to determine the
                                                          exact cause of the interrupt. The application must clear the
                                                          appropriate status bit in the corresponding [DIEPINTn] register
                                                          to clear this b                                                      */
      __I  uint32_t  OEPInt     :  1;               /*!< Mode: Device onlyOUT Endpoints Interrupt (OEPInt)The core sets
                                                         this bit to indicate that an interrupt is pending on one of
                                                          the OUT endpoints of the core (in Device mode). The application
                                                          must read the Device All Endpoints Interrupt ([DAINT]) register
                                                          to determine the exact number of the OUT endpoint on which the
                                                          interrupt occurred, and Then read the corresponding Device OUT
                                                          Endpoint-n Interrupt ([DOEPINTn]) register to determine the
                                                          exact cause of the interrupt. The application must clear the
                                                          appropriate s                                                        */
      __IO uint32_t  incompISOIN:  1;               /*!< Mode: Device onlyIncomplete Isochronous IN Transfer (incompISOIN)The
                                                         core sets this interrupt to indicate that there is at least
                                                          one isochronous IN endpoint on which the transfer is not completed
                                                          in thecurrent microframe. This interrupt is asserted along with
                                                          the End of Periodic Frame Interrupt (EOPF) bit in this register.
                                                          Note: This nterrupt is not asserted in Scatter/Gather DMA mode.      */
      __IO uint32_t  incompISOOUT:  1;              /*!< Incomplete Periodic Transfer (incomplP)Mode: Host onlyIn Host
                                                         mode, the core sets this interrupt bit when there are incomplete
                                                          periodic transactions still pending which are scheduled for
                                                          the current microframe.Incomplete Isochronous OUT Transfer (incompISOOUT)M
                                                         ode: Device onlyIn Device mode, the core sets this interrupt
                                                          to indicate that there is at least one isochronous OUT endpoint
                                                          on which the transfer is not completed in the current microframe.
                                                          This interrupt is asserted along with the End of Periodic F          */
      __IO uint32_t  FetSusp    :  1;               /*!< Mode: Device onlyData Fetch Suspended (FetSusp)This interrupt
                                                         is valid only in DMA mode. This interrupt indicates that the
                                                          core has stopped fetching data For IN endpoints due to theunavailability
                                                          of TxFIFO space or Request Queue space. This interrupt is used
                                                          by the application For an endpoint mismatch algorithm. For example,
                                                          after detecting an endpoint mismatch, the application:- Sets
                                                          a Global non-periodic IN NAK handshake- Disables In endpoints-
                                                          Flushes the FIFO- Determines the token sequence from the IN
                                                                                                                               */
      __IO uint32_t  ResetDet   :  1;               /*!< Mode: Device onlyReset detected Interrupt (ResetDet)In Device
                                                         mode, this interrupt is asserted when a reset is detected on
                                                          the USB in partial power-down mode when the device is in Suspend.In
                                                          Host mode, this interrupt is not asserted.                           */
           uint32_t             :  4;
      __IO uint32_t  ConIDStsChng:  1;              /*!< Mode: Host and DeviceConnector ID Status Change (ConIDStsChng)The
                                                         core sets this bit when there is a change in connector ID status.     */
           uint32_t             :  1;
      __IO uint32_t  SessReqInt :  1;               /*!< Mode: Host and DeviceSession Request/New Session Detected Interrupt
                                                         (SessReqInt)In Host mode, this interrupt is asserted when a
                                                          session request is detected from the device.In Device mode,
                                                          this interrupt is asserted when the utmisrp_bvalid signal goes
                                                          high.                                                                */
      __IO uint32_t  WkUpInt    :  1;               /*!< Mode: Host and DeviceResume/Remote Wakeup Detected Interrupt
                                                         (WkUpInt)Wakeup Interrupt during Suspend(L2) or LPM(L1) state.-
                                                          During Suspend (L2):- Device Mode - This interrupt is asserted
                                                          only when HostInitiated Resume is detected on USB.- Host Mode
                                                          - This interrupt is asserted only when DeviceInitiated Remote
                                                          Wakeup is detected on USB.- During LPM (L1):- Device Mode -
                                                          This interrupt is asserted for either Host InitiatedResume or
                                                          Device Initiated Remote Wakeup on USB.- Host Mode - This interrupt
                                                          is asserte                                                           */
    } GINTSTS_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GINTMSK;                         /*!< Interrupt Mask Register                                               */
    
    struct {
           uint32_t             :  1;
      __IO uint32_t  ModeMisMsk :  1;               /*!< Mode: Host and DeviceMode Mismatch Interrupt Mask (ModeMisMsk)        */
      __IO uint32_t  OTGIntMsk  :  1;               /*!< Mode: Host and DeviceOTG Interrupt Mask (OTGIntMsk)                   */
      __IO uint32_t  SofMsk     :  1;               /*!< Mode: Host and DeviceStart of (micro)Frame Mask (SofMsk)              */
      __IO uint32_t  RxFLvlMsk  :  1;               /*!< Mode: Host and DeviceReceive FIFO Non-Empty Mask (RxFLvlMsk)          */
      __IO uint32_t  NPTxFEmpMsk:  1;               /*!< Mode: Host and DeviceNon-periodic TxFIFO Empty Mask (NPTxFEmpMsk)     */
      __IO uint32_t  GINNakEffMsk:  1;              /*!< Mode: Device onlyGlobal Non-periodic IN NAK Effective Mask (GINNakEffMsk) */
      __IO uint32_t  GOUTNakEffMsk:  1;             /*!< Mode: Device onlyGlobal OUT NAK Effective Mask (GOUTNakEffMsk)        */
           uint32_t             :  2;
      __IO uint32_t  ErlySuspMsk:  1;               /*!< Mode: Device onlyEarly Suspend Mask (ErlySuspMsk)                     */
      __IO uint32_t  USBSuspMsk :  1;               /*!< Mode: Device onlyUSB Suspend Mask (USBSuspMsk)                        */
      __IO uint32_t  USBRstMsk  :  1;               /*!< Mode: Device onlyUSB Reset Mask (USBRstMsk)                           */
      __IO uint32_t  EnumDoneMsk:  1;               /*!< Mode: Device onlyEnumeration Done Mask (EnumDoneMsk)                  */
      __IO uint32_t  ISOOutDropMsk:  1;             /*!< Mode: Device only Isochronous OUT Packet Dropped InterruptMask
                                                         (ISOOutDropMsk)                                                       */
      __IO uint32_t  EOPFMsk    :  1;               /*!< Mode: Device onlyEnd of Periodic Frame Interrupt Mask (EOPFMsk)       */
           uint32_t             :  1;
      __IO uint32_t  EPMisMsk   :  1;               /*!< Mode: Device onlyEndpoint Mismatch Interrupt Mask (EPMisMsk)          */
      __IO uint32_t  IEPIntMsk  :  1;               /*!< Mode: Device onlyIN Endpoints Interrupt Mask (IEPIntMsk)              */
      __IO uint32_t  OEPIntMsk  :  1;               /*!< Mode: Device onlyOUT Endpoints Interrupt Mask (OEPIntMsk)             */
      __IO uint32_t  incompISOINMsk:  1;            /*!< Mode: Device onlyIncomplete Isochronous IN Transfer Mask (incompISOINMsk)T
                                                         his bit is enabled only when device periodic endpoints are enabled
                                                         in Dedicated TxFIFO mode.                                             */
      __IO uint32_t  incomplISOOUTMsk:  1;          /*!< Incomplete Periodic Transfer Mask (incomplPMsk)Mode: Host onlyIncomplete
                                                         Isochronous OUT Transfer Mask (incompISOOUTMsk)Mode: Device
                                                          only                                                                 */
      __IO uint32_t  FetSuspMsk :  1;               /*!< Mode: Device onlyData Fetch Suspended Mask (FetSuspMsk)               */
      __IO uint32_t  ResetDetMsk:  1;               /*!< Mode: Device onlyReset detected Interrupt Mask (ResetDetMsk)          */
           uint32_t             :  4;
      __IO uint32_t  ConIDStsChngMsk:  1;           /*!< Mode: Host and DeviceConnector ID Status Change Mask (ConIDStsChngMsk */
      __IO uint32_t  DisconnIntMsk:  1;             /*!< Mode: Host and DeviceDisconnect Detected Interrupt Mask (DisconnIntMsk */
      __IO uint32_t  SessReqIntMsk:  1;             /*!< Mode: Host and DeviceSession Request/New Session Detected Interrupt
                                                         Mask (SessReqIntMsk)                                                  */
      __IO uint32_t  WkUpIntMsk :  1;               /*!< Mode: Host and DeviceResume/Remote Wakeup Detected Interrupt
                                                         Mask (WkUpIntMsk)The WakeUp bit is used for LPM state wake up
                                                          in a way similar to that of wake up in suspend state.                */
    } GINTMSK_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GRXSTSR;                         /*!< Receive Status Debug Read Register                                    */
    
    struct {
      __I  uint32_t  EPNum      :  4;               /*!< Endpoint Number (EPNum)Indicates the endpoint number to which
                                                         the current received packet belongs.                                  */
      __I  uint32_t  BCnt       : 11;               /*!< Byte Count (BCnt)Indicates the byte count of the received data
                                                         packet                                                                */
      __I  uint32_t  DPID       :  2;               /*!< Data PID (DPID)Indicates the Data PID of the received OUT data
                                                         packet- 2b00: DATA0- 2b10: DATA1- 2b01: DATA2- 2b11: MDATA            */
      __I  uint32_t  PktSts     :  4;               /*!< Packet Status (PktSts)Indicates the status of the received packet-
                                                         4b0001: Global OUT NAK (triggers an interrupt)- 4b0010: OUT
                                                          data packet received- 4b0011: OUT transfer completed (triggers
                                                          an interrupt)- 4b0100: SETUP transaction completed (triggers
                                                          an interrupt)- 4b0110: SETUP data packet received- Others: Reserved  */
      __I  uint32_t  FN         :  4;               /*!< Frame Number (FN)This is the least significant 4 bits of the
                                                         (micro)frame number in which the packet is received on the USB.
                                                          This field is supported only when isochronous OUT endpoints
                                                          are supported.                                                       */
           uint32_t : 7; // padding
    } GRXSTSR_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GRXSTSP;                         /*!< Receive Status Read /Pop Register                                     */
    
    struct {
      __I  uint32_t  EPNum      :  4;               /*!< Endpoint Number (EPNum)Indicates the endpoint number to which
                                                         the current received packet belongs.                                  */
      __I  uint32_t  BCnt       : 11;               /*!< Byte Count (BCnt)Indicates the byte count of the received data
                                                         packet.                                                               */
      __I  uint32_t  DPID       :  2;               /*!< Data PID (DPID)Indicates the Data PID of the received OUT data
                                                         packet- 2b00: DATA0- 2b10: DATA1- 2b01: DATA2- 2b11: MDATA            */
      __I  uint32_t  PktSts     :  4;               /*!< Packet Status (PktSts)Indicates the status of the received packet-
                                                         4b0001: Global OUT NAK (triggers an interrupt)- 4b0010: OUT
                                                          data packet received- 4b0011: OUT transfer completed (triggers
                                                          an interrupt)- 4b0100: SETUP transaction completed (triggers
                                                          an interrupt)- 4b0110: SETUP data packet received- Others: Reserved  */
      __I  uint32_t  FN         :  4;               /*!< Frame Number (FN)This is the least significant 4 bits of the
                                                         (micro)frame number in which the packet is received on the USB.
                                                          This field is supported only when isochronous OUT endpoints
                                                          are supported.                                                       */
           uint32_t : 7; // padding
    } GRXSTSP_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GRXFSIZ;                         /*!< Receive FIFO Size Register                                            */
    
    struct {
      __IO uint32_t  RxFDep     :  8;               /*!< RxFIFO Depth (RxFDep)This value is in terms of 32-bit words.-
                                                         Minimum value is 16- Maximum value is 32,768Programmed values
                                                          must not exceed the power-on value.                                  */
           uint32_t : 24; // padding
    } GRXFSIZ_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  GNPTXFSIZ;                       /*!< Non-periodic Transmit FIFO Size Register                              */
    
    struct {
      __IO uint32_t  NPTXFStAddr:  8;               /*!< Non-periodic Transmit RAM Start Address (NPTxFStAddr)This field
                                                         contains the memory start address for Non-periodic Transmit
                                                          FIFO RAM.Programmed values must not exceed the power-on value.       */
           uint32_t             :  8;
      __IO uint32_t  NPTXFDep   :  6;               /*!< Non-periodic TxFIFO Depth (NPTxFDep)This value is in terms of
                                                         32-bit words.- Minimum value is 16- Maximum value is 32,768Programmed
                                                          values must not exceed the power-on value.                           */
           uint32_t : 10; // padding
    } GNPTXFSIZ_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  GNPTXSTS;                        /*!< Non-periodic Transmit FIFO/Queue Status Register                      */
    
    struct {
      __I  uint32_t  NPTxFSpcAvail: 16;             /*!< Non-periodic TxFIFO Space Avail (NPTxFSpcAvail)Indicates the
                                                         amount of free space available in the Non-periodic TxFIFO. Values
                                                          are in terms of 32-bit words.- 16h0: Non-periodic TxFIFO is
                                                          full- 16h1: 1 word available- 16h2: 2 words available- 16hn:
                                                          n words available (where 0 less than or equal to n less than
                                                          or equal to 32,768)- 16h8000: 32,768 words available- Others:
                                                          Reserved                                                             */
      __I  uint32_t  NPTxQSpcAvail:  8;             /*!< Non-periodic Transmit Request Queue Space Available (NPTxQSpcAvail)Indicat
                                                         es the amount of free space available in the Non-periodic Transmit
                                                         Request Queue. This queue holds both IN and OUT requests in
                                                          Host mode. Device mode has only IN requests.- 8h0: Non-periodic
                                                          Transmit Request Queue is full- 8h1: 1 location available- 8h2:
                                                          2 locations available- n: n locations available (0 less than
                                                          or equal to n less than or equal to 8)- Others: Reserved             */
      __I  uint32_t  NPTxQTop   :  7;               /*!< Top of the Non-periodic Transmit Request Queue (NPTxQTop)Entry
                                                         in the Non-periodic Tx Request Queue that is currently being
                                                          processed by the MAC.- Bits [30:27]: Channel/endpoint number-
                                                          Bits [26:25]:- 2b00: IN/OUT token- 2b01: Zero-length transmit
                                                          packet (device IN/host OUT)- 2b10: PING/CSPLIT token- 2b11:
                                                          Channel halt command- Bit [24]: Terminate (last Entry for selected
                                                          channel/endpoint)                                                    */
           uint32_t : 1; // padding
    } GNPTXSTS_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[4];
  
  union {
    __I  uint32_t  GSNPSID;                         /*!< Synopsys ID Register                                                  */
    
    struct {
      __I  uint32_t  SynopsysID : 32;               /*!< Release number of the DWC_otg core currently being used.              */
    } GSNPSID_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[48];
  
  union {
    __IO uint32_t  DPTXFSIZ1;                       /*!< Device Periodic Transmit FIFO-n Size Register 1                       */
    
    struct {
      __IO uint32_t  DPTxFStAddr: 16;               /*!< Device Periodic TxFIFO RAM Start Address (DPTxFStAddr)This field
                                                         specifies the start address in the RAM for this periodic FIFO.
                                                          The power-on reset value of this register is the sum of the
                                                          Largest Rx Data FIFO Depth, Largest Non-periodic Tx Data FIFO
                                                          Depth, and all lower numbered Largest Device Mode Periodic Tx
                                                          Data FIFOn Depth.Programmed values must not exceed the power-on
                                                          value .                                                              */
      __I  uint32_t  DPTxFSize  : 16;               /*!< Device Periodic TxFIFO Size (DPTxFSize)This value is in terms
                                                         of 32-bit words.- Minimum value is 4- Maximum value is 768            */
    } DPTXFSIZ1_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[446];
  
  union {
    __IO uint32_t  DCFG;                            /*!< Device Configuration Register                                         */
    
    struct {
      __IO uint32_t  DevSpd     :  2;               /*!< Device Speed (DevSpd)Indicates the speed at which the application
                                                         requires the core to enumerate, or the maximum speed the application
                                                          can support. However, the actual bus speed is determined only
                                                          after the chirp sequence is completed, and is based on the speed
                                                          of the USB host to which the core is connected.- 2b00: High
                                                          speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)- 2b01: Full speed
                                                          (USB 2.0 PHY clock is 30 MHz or 60 MHz)- 2b10: Low speed (USB
                                                          1.1 transceiver clock is 6 MHz). If you select 6 MHz LS mode,
                                                          y                                                                    */
      __IO uint32_t  NZStsOUTHShk:  1;              /*!< Non-Zero-Length Status OUT Handshake (NZStsOUTHShk)The application
                                                         can use this field to select the handshake the core sends on
                                                          receiving a non zero-length data packet during the OUT transaction
                                                          of a control transfers Status stage.- 1b1: Send a STALL handshake
                                                          on a non zero-length status OUT transaction and do not send
                                                          the received OUT packet to the application.- 1b0: Send the received
                                                          OUT packet to the application (zero-length or non zero-length)
                                                          and send a handshake based on the NAK and STALL bits for th          */
      __IO uint32_t  Ena32KHzSusp:  1;              /*!< Enable 32 KHz Suspend mode (Ena32KHzSusp)This bit can be set
                                                         only if FS PHY interface is selected. Otherwise, this bit needs
                                                          to be set to zero. If FS PHY interface is chosen and this bit
                                                          is set, the PHY clock during Suspend must be switched from 48
                                                          MHz to 32 KHz.                                                       */
      __IO uint32_t  DevAddr    :  7;               /*!< Device Address (DevAddr)The application must program this field
                                                         after every SetAddress control command.                               */
      __IO uint32_t  PerFrInt   :  2;               /*!< Periodic Frame Interval (PerFrInt)Indicates the time within
                                                         a (micro)frame at which the application must be notified using
                                                          the End Of Periodic Frame Interrupt. This can be used to determine
                                                          if all the isochronous traffic for that (micro)frame is complete.-
                                                          2b00: 80% of the (micro)frame interval- 2b01: 85%- 2b10: 90%-
                                                          2b11: 95%                                                            */
      __I  uint32_t  EnDevOutNak:  1;               /*!< Enable Device OUT NAK (EnDevOutNak)This bit enables setting
                                                         NAK for Bulk OUT endpoints after the transfer iscompleted for
                                                          Device mode Descriptor DMA mode.- 1b0: The core does not set
                                                          NAK after Bulk OUT transfer complete- 1b1: The core sets NAK
                                                          after Bulk OUT transfer completeThis is a one time programmable
                                                          bit after reset like any other DCFG register bits.                   */
      __IO uint32_t  XCVRDLY    :  1;               /*!< Enables or disables delay between xcvr_sel and txvalid during
                                                         device chirp- 1b1: Enable delay between xcvr_sel and txvalid
                                                          during Device chirp- 1b0: No delay between xcvr_sel and txvalid
                                                          during Device chirp                                                  */
      __IO uint32_t  ErraticIntMsk:  1;             /*!< Mode: DeviceErratic Error Interrupt Mask- 1b1: Mask early suspend
                                                         interrupt on erratic error- 1b0: Early suspend interrupt is
                                                          generated on erratic error                                           */
           uint32_t             :  2;
      __IO uint32_t  EPMisCnt   :  5;               /*!< IN Endpoint Mismatch Count (EPMisCnt)This field is valid only
                                                         in shared FIFO operation.The application programs this field
                                                          with a count that determines when the core generates an Endpoint
                                                          Mismatch interrupt (GINTSTS.EPMis). The core loads this value
                                                          into an internal counter and decrements it. The counter is reloaded
                                                          whenever there is a match or when the counter expires. The width
                                                          of this counter depends on the depth of the Token Queue.             */
           uint32_t             :  1;
      __IO uint32_t  PerSchIntvl:  2;               /*!< Periodic Scheduling Interval (PerSchIntvl)PerSchIntvl must be
                                                         programmed only for Scatter/Gather DMA mode.This field specifies
                                                          the amount of time the Internal DMA engine must allocate For
                                                          fetching periodic IN endpoint data. Based on the number of periodic
                                                          endpoints, this value must be specified as 25,50 or 75% of (micro)frame.
                                                          When any periodic endpoints are active, the internal DMA engine
                                                          allocates the specified amount of time in fetching periodic
                                                          IN endpoint data. When no periodic endpoints are active, t           */
      __IO uint32_t  ResValid   :  6;               /*!< Resume Validation Period (ResValid)This field is effective only
                                                         when [DCFG].Ena32KHzSusp is set. It controls the resume period
                                                          when the core resumes from suspend. The core counts for 'ResValid'
                                                          number of clock cycles to detect a valid resume when this bit
                                                          is set.                                                              */
    } DCFG_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DCTL;                            /*!< Device Control Register                                               */
    
    struct {
      __IO uint32_t  RmtWkUpSig :  1;               /*!< Remote Wakeup Signaling (RmtWkUpSig)When the application sets
                                                         this bit, the core initiates remote signaling to wake the USB
                                                          host. The application must set thisbit to instruct the core
                                                          to exit the Suspend state. As specified in the USB 2.0 specification,
                                                          the application must clear this bit 1-15 ms after setting it.If
                                                          LPM is enabled and the core is in the L1 (Sleep) state, when
                                                          the application sets this bit, the core initiates L1 remote
                                                          signaling to wake up the USB host. The application must set
                                                          this bit to                                                          */
      __IO uint32_t  SftDiscon  :  1;               /*!< Soft Disconnect (SftDiscon)The application uses this bit to
                                                         signal the DWC_otg core to do a soft disconnect. As long as
                                                          this bit is set, the host does not see that the device is connected,
                                                          and the device does not receive signals on the USB. The core
                                                          stays in the disconnected state until the application clears
                                                          this bit. The minimum duration for which the core must keep
                                                          this bit set is specified in Table 5-55.- 1b0: Normal operation.
                                                          When this bit is cleared after a soft disconnect, the core drives
                                                          the phy_o                                                            */
      __I  uint32_t  GNPINNakSts:  1;               /*!< Global Non-periodic IN NAK Status (GNPINNakSts)- 1b0: A handshake
                                                         is sent out based on the data availability in the transmit FIFO.-
                                                          1b1: A NAK handshake is sent out on all non-periodic IN endpoints,
                                                          irrespective of the data availability in the transmit FIFO.          */
      __I  uint32_t  GOUTNakSts :  1;               /*!< Global OUT NAK Status (GOUTNakSts)- 1b0: A handshake is sent
                                                         based on the FIFO Status and the NAK and STALL bit settings.-
                                                          1b1: No data is written to the RxFIFO, irrespective of space
                                                          availability. Sends a NAK handshake on all packets, except on
                                                          SETUP transactions. All isochronous OUT packets are dropped.         */
      __IO uint32_t  TstCtl     :  3;               /*!< Test Control (TstCtl)- 3b000: Test mode disabled- 3b001: Test_J
                                                         mode- 3b010: Test_K mode- 3b011: Test_SE0_NAK mode- 3b100: Test_Packet
                                                          mode- 3b101: Test_Force_Enable- Others: Reserved                     */
      __IO uint32_t  SGNPInNak  :  1;               /*!< Set Global Non-periodic IN NAK (SGNPInNak)A write to this field
                                                         sets the Global Non-periodic IN NAK.The application uses this
                                                          bit to send a NAK handshake on all nonperiodic IN endpoints.
                                                          The core can also set this bit when a timeout condition is detected
                                                          on a non-periodic endpoint in shared FIFO operation.The application
                                                          must set this bit only after making sure that the Global IN
                                                          NAK Effective bit in the Core Interrupt Register ([GINTSTS].GINNakEff)
                                                          is cleared.                                                          */
      __IO uint32_t  CGNPInNak  :  1;               /*!< Clear Global Non-periodic IN NAK (CGNPInNak)A write to this
                                                         field clears the Global Non-periodic IN NAK.                          */
      __IO uint32_t  SGOUTNak   :  1;               /*!< Set Global OUT NAK (SGOUTNak)A write to this field sets the
                                                         Global OUT NAK.The application uses this bit to send a NAK handshake
                                                          on all OUT endpoints. The application must set the this bit
                                                          only after making sure that the Global OUT NAK Effective bit
                                                          in the Core Interrupt Register ([GINTSTS].GOUTNakEff) is cleared.    */
      __IO uint32_t  CGOUTNak   :  1;               /*!< Clear Global OUT NAK (CGOUTNak)A write to this field clears
                                                         the Global OUT NAK.                                                   */
      __IO uint32_t  PWROnPrgDone:  1;              /*!< Power-On Programming Done (PWROnPrgDone)The application uses
                                                         this bit to indicate that register programming is complete after
                                                          a wake-up from Power Down mode.                                      */
           uint32_t             :  3;
      __IO uint32_t  IgnrFrmNum :  1;               /*!< Ignore frame number for isochronous endpoints (IgnrFrmNum)Slave
                                                         Mode ([GAHBCFG].DMAEn=0):This bit is not valid in Slave mode
                                                          and should not beprogrammed to 1.Non-Scatter/Gather DMA mode([GAHBCFG].DMA
                                                         En=1, [DCFG].DescDMA=0):This bit is not used when Threshold mode
                                                          is enabled and should not be programmed to 1.In non-Scatter/Gather
                                                          DMA mode, the application receives transfer complete interrupt
                                                          after transfers for multiple (micro)frames are completed.- When
                                                          Scatter/Gather DMA mode is disabled, this field is us                */
      __IO uint32_t  NakOnBble  :  1;               /*!< NAK on Babble Error (NakOnBble)Set NAK automatically on babble
                                                         (NakOnBble). The core setsNAK automatically for the endpoint
                                                          on which babble is received.                                         */
           uint32_t : 15; // padding
    } DCTL_b;                                       /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DSTS;                            /*!< Device Status Register                                                */
    
    struct {
      __I  uint32_t  SuspSts    :  1;               /*!< Suspend Status (SuspSts)In Device mode, this bit is set as long
                                                         as a Suspend condition is detected on the USB. The core enters
                                                          the Suspend state when there is no activity on the phy_line_state_i
                                                          signal for an extended period of time. The core comes out of
                                                          the suspend under the following conditions:- If there is any
                                                          activity on the phy_line_state_i signal- If the application
                                                          writes to the Remote Wakeup Signaling bit in the Device Control
                                                          register ([DCTL].RmtWkUpSig).                                        */
      __I  uint32_t  EnumSpd    :  2;               /*!< Enumerated Speed (EnumSpd)Indicates the speed at which the DWC_otg
                                                         core has come up after speed detection through a chirp sequence.-
                                                          2b00: High speed (PHY clock is running at 30 or 60 MHz)- 2b01:
                                                          Full speed (PHY clock is running at 30 or 60 MHz)- 2b10: Low
                                                          speed (PHY clock is running at 6 MHz)- 2b11: Full speed (PHY
                                                          clock is running at 48 MHz)Low speed is not supported for devices
                                                          using a UTMI+ PHY.                                                   */
      __I  uint32_t  ErrticErr  :  1;               /*!< Erratic Error (ErrticErr)The core sets this bit to report any
                                                         erratic errors (phy_rxvalid_i/phy_rxvldh_i or phy_rxactive_i
                                                          is asserted For at least 2 ms, due to PHY error) seen on the
                                                          UTMI+. Due to erratic errors, the DWC_otg core goes into Suspend
                                                          state and an interrupt is generated to the application with
                                                          Early Suspend bit of the Core Interrupt register ([GINTSTS].ErlySusp).
                                                          If the early suspend is asserted because of an erratic error,
                                                          the application can only perform a soft disconnect recover.          */
           uint32_t             :  4;
      __I  uint32_t  SOFFN      : 14;               /*!< Frame or Microframe Number of the Received SOF (SOFFN)When the
                                                         core is operating at high speed, this field contains a microframe
                                                          number. When the core is operating at full or low speed, this
                                                          field contains a Frame number.Note: This register may return
                                                          a non zero value if read immediately after power on reset. In
                                                          case the register bit reads non zero immediately after power
                                                          on reset it does not indicate that SOF has been received from
                                                          the host. The read value of this interrupt is valid only after
                                                          a valid con                                                          */
      __I  uint32_t  DevLnSts   :  2;               /*!< Device Line Status (DevLnSts)Indicates the current logic level
                                                         USB data lines- Bit [23]: Logic level of D+- Bit [22]: Logic
                                                          level of D-                                                          */
           uint32_t : 8; // padding
    } DSTS_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;
  
  union {
    __IO uint32_t  DIEPMSK;                         /*!< Device IN Endpoint Common Interrupt Mask Register                     */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Transfer Completed Interrupt Mask (XferComplMsk)                      */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Endpoint Disabled Interrupt Mask (EPDisbldMsk)                        */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< AHB Error Mask (AHBErrMsk)                                            */
      __IO uint32_t  TimeOUTMsk :  1;               /*!< Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)       */
      __IO uint32_t  INTknTXFEmpMsk:  1;            /*!< IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)             */
      __IO uint32_t  INTknEPMisMsk:  1;             /*!< IN Token received with EP Mismatch Mask (INTknEPMisMsk)               */
      __IO uint32_t  INEPNakEffMsk:  1;             /*!< IN Endpoint NAK Effective Mask (INEPNakEffMsk)                        */
           uint32_t             :  1;
      __IO uint32_t  TxfifoUndrnMsk:  1;            /*!< Fifo Underrun Mask (TxfifoUndrnMsk)                                   */
           uint32_t             :  4;
      __IO uint32_t  NAKMsk     :  1;               /*!< NAK interrupt Mask (NAKMsk)                                           */
           uint32_t : 18; // padding
    } DIEPMSK_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPMSK;                         /*!< Device OUT Endpoint Common Interrupt Mask Register                    */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Transfer Completed Interrupt Mask (XferComplMsk)                      */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Endpoint Disabled Interrupt Mask (EPDisbldMsk)                        */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< AHB Error (AHBErrMsk)                                                 */
      __IO uint32_t  SetUPMsk   :  1;               /*!< SETUP Phase Done Mask (SetUPMsk)Applies to control endpoints
                                                         only.                                                                 */
      __IO uint32_t  OUTTknEPdisMsk:  1;            /*!< OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)Applies
                                                         to control OUT endpoints only.                                        */
      __IO uint32_t  StsPhseRcvdMsk:  1;            /*!< Status Phase Received Mask (StsPhseRcvdMsk) Applies to control
                                                         OUT endpoints only.                                                   */
      __IO uint32_t  Back2BackSETup:  1;            /*!< Back-to-Back SETUP Packets Received Mask (Back2BackSETupMsk)Applies
                                                         to control OUT endpoints only.                                        */
           uint32_t             :  1;
      __IO uint32_t  OutPktErrMsk:  1;              /*!< OUT Packet Error Mask (OutPktErrMsk)                                  */
           uint32_t             :  3;
      __IO uint32_t  BbleErrMsk :  1;               /*!< Babble Error interrupt Mask (BbleErrMsk)                              */
      __IO uint32_t  NAKMsk     :  1;               /*!< NAK interrupt Mask (NAKMsk)                                           */
      __IO uint32_t  NYETMsk    :  1;               /*!< NYET interrupt Mask (NYETMsk)                                         */
           uint32_t : 17; // padding
    } DOEPMSK_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DAINT;                           /*!< Device All Endpoints Interrupt Register                               */
    
    struct {
      __I  uint32_t  InEpInt0   :  1;               /*!< IN Endpoint 0 Interrupt Bit                                           */
      __I  uint32_t  InEpInt1   :  1;               /*!< IN Endpoint 1 Interrupt Bit                                           */
      __I  uint32_t  InEpInt2   :  1;               /*!< IN Endpoint 2 Interrupt Bit                                           */
      __I  uint32_t  InEpInt3   :  1;               /*!< IN Endpoint 3 Interrupt Bit                                           */
           uint32_t             : 12;
      __I  uint32_t  OutEPInt0  :  1;               /*!< OUT Endpoint 0 Interrupt Bit                                          */
      __I  uint32_t  OutEPInt1  :  1;               /*!< OUT Endpoint 1 Interrupt Bit                                          */
      __I  uint32_t  OutEPInt2  :  1;               /*!< OUT Endpoint 2 Interrupt Bit                                          */
      __I  uint32_t  OutEPInt3  :  1;               /*!< OUT Endpoint 3 Interrupt Bit                                          */
           uint32_t : 12; // padding
    } DAINT_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DAINTMSK;                        /*!< Device All Endpoints Interrupt Mask Register                          */
    
    struct {
      __IO uint32_t  InEpMsk0   :  1;               /*!< IN Endpoint 0 Interrupt mask Bit                                      */
      __IO uint32_t  InEpMsk1   :  1;               /*!< IN Endpoint 1 Interrupt mask Bit                                      */
      __IO uint32_t  InEpMsk2   :  1;               /*!< IN Endpoint 2 Interrupt mask Bit                                      */
      __IO uint32_t  InEpMsk3   :  1;               /*!< IN Endpoint 3 Interrupt mask Bit                                      */
           uint32_t             : 12;
      __IO uint32_t  OutEPMsk0  :  1;               /*!< OUT Endpoint 0 Interrupt mask Bit                                     */
      __IO uint32_t  OutEPMsk1  :  1;               /*!< OUT Endpoint 1 Interrupt mask Bit                                     */
      __IO uint32_t  OutEPMsk2  :  1;               /*!< OUT Endpoint 2 Interrupt mask Bit                                     */
      __IO uint32_t  OutEPMsk3  :  1;               /*!< OUT Endpoint 3 Interrupt mask Bit                                     */
           uint32_t : 12; // padding
    } DAINTMSK_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTKNQR1;                         /*!< Device IN Token Sequence Learning Queue Read Register 1               */
    
    struct {
      __I  uint32_t  INTknWPtr  :  5;               /*!< IN Token Queue Write Pointer (INTknWPtr)                              */
           uint32_t             :  2;
      __I  uint32_t  WrapBit    :  1;               /*!< Wrap Bit (WrapBit)This bit is set when the write pointer wraps.
                                                         It is cleared when the learningqueue is cleared.                      */
      __I  uint32_t  EPTkn      : 24;               /*!< Endpoint Token (EPTkn)Four bits per token represent the endpoint
                                                         number of the token:- Bits [31:28]: Endpoint number of Token
                                                          5- Bits [27:24]: Endpoint number of Token 4.......- Bits [15:12]:
                                                          Endpoint number of Token 1- Bits [11:8]: Endpoint number of
                                                          Token 0                                                              */
    } DTKNQR1_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTKNQR2;                         /*!< Device IN Token Sequence Learning Queue Read Register 2               */
    
    struct {
      __I  uint32_t  EPTkn      : 32;               /*!< Endpoint Token (EPTkn)Four bits per token represent the endpoint
                                                         number of the token:- Bits [31:28]: Endpoint number of Token
                                                          13- Bits [27:24]: Endpoint number of Token 12.......- Bits [7:4]:
                                                          Endpoint number of Token 7- Bits [3:0]: Endpoint number of Token
                                                          6                                                                    */
    } DTKNQR2_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DVBUSDIS;                        /*!< Device VBUS Discharge Time Register                                   */
    
    struct {
      __IO uint32_t  DVBUSDis   : 16;               /*!< Device VBUS Discharge Time (DVBUSDis)Specifies the VBUS discharge
                                                         time after VBUS pulsing during SRP. This value equals: VBUS
                                                          discharge time in PHY clocks / 1,024The value you use depends
                                                          whether the PHY is operating at 30 MHz (16-bit data width) or
                                                          60 MHz (8-bit data width). Depending on your VBUS load, this
                                                          value can be adjusted.                                               */
           uint32_t : 16; // padding
    } DVBUSDIS_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DVBUSPULSE;                      /*!< Device VBUS Pulsing Time Register                                     */
    
    struct {
      __IO uint32_t  DVBUSPulse : 12;               /*!< Device VBUS Pulsing Time (DVBUSPulse)Specifies the VBUS pulsing
                                                         time during SRP. This value equals:VBUS pulsing time in PHY
                                                          clocks / 1,024The value you use depends whether the PHY is operating
                                                          at 30 MHz (16-bit data width) or 60 MHz (8-bit data width).          */
           uint32_t : 20; // padding
    } DVBUSPULSE_b;                                 /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTKNQR3;                         /*!< Device IN Token Sequence Learning Queue Read Register 3               */
    
    struct {
      __I  uint32_t  EPTkn      : 32;               /*!< Endpoint Token (EPTkn)Four bits per token represent the endpoint
                                                         number of the token:- Bits [31:28]: Endpoint number of Token
                                                          21- Bits [27:24]: Endpoint number of Token 20.......- Bits [7:4]:
                                                          Endpoint number of Token 15- Bits [3:0]: Endpoint number of
                                                          Token 14                                                             */
    } DTKNQR3_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTKNQR4;                         /*!< Device IN Token Sequence Learning Queue Read Register 4               */
    
    struct {
      __I  uint32_t  EPTkn      : 32;               /*!< Endpoint Token (EPTkn)Four bits per token represent the endpoint
                                                         number of the token:- Bits [31:28]: Endpoint number of Token
                                                          29- Bits [27:24]: Endpoint number of Token 28.......- Bits [7:4]:
                                                          Endpoint number of Token 23- Bits [3:0]: Endpoint number of
                                                          Token 22                                                             */
    } DTKNQR4_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DEACHINT;                        /*!< Device Each Endpoints Interrupt Register                              */
    
    struct {
      __I  uint32_t  EchInEpInt : 16;               /*!< IN Endpoint Interrupt Bits (EchInEpInt)One bit per IN Endpoint:-
                                                         Bit 0 for IN endpoint 0...- Bit 15 for endpoint 15                    */
      __I  uint32_t  EchOutEPInt: 16;               /*!< OUT Endpoint Interrupt Bits (EchOutEPInt)One bit per OUT endpoint:-
                                                         Bit 16 for OUT endpoint 0...- Bit 31 for OUT endpoint 15              */
    } DEACHINT_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DEACHINTMSK;                     /*!< Device Each Endpoints Interrupt Mask Register                         */
    
    struct {
      __IO uint32_t  EchInEpMsk : 16;               /*!< IN EP Interrupt Mask Bits (EchInEpMsk)One bit per IN Endpoint:-
                                                         Bit 0 for IN endpoint 0...- Bit 15 for endpoint 15                    */
      __IO uint32_t  EchOutEpMsk: 16;               /*!< OUT EP Interrupt Mask Bits (EchOutEpMsk)One per OUT Endpoint:-
                                                         Bit 16 for IN endpoint 0...- Bit 31 for endpoint 15                   */
    } DEACHINTMSK_b;                                /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPEACHMSK0;                    /*!< Device Each IN Endpoint 16 Interrupt Register                         */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Transfer Completed Interrupt Mask (XferComplMsk)                      */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Endpoint Disabled Interrupt Mask (EPDisbldMsk)                        */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< AHB Error Mask (AHBErrMsk)                                            */
      __IO uint32_t  TimeOUTMsk :  1;               /*!< Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)       */
      __IO uint32_t  INTknTXFEmpMsk:  1;            /*!< IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)             */
      __IO uint32_t  INTknEPMisMsk:  1;             /*!< IN Token received with EP Mismatch Mask (INTknEPMisMsk)               */
      __IO uint32_t  INEPNakEffMsk:  1;             /*!< IN Endpoint NAK Effective Mask (INEPNakEffMsk)                        */
           uint32_t             :  1;
      __IO uint32_t  TxfifoUndrnMsk:  1;            /*!< Fifo Underrun Mask (TxfifoUndrnMsk)                                   */
           uint32_t             :  4;
      __IO uint32_t  NAKMsk     :  1;               /*!< NAK interrupt Mask (NAKMsk)                                           */
           uint32_t : 18; // padding
    } DIEPEACHMSK0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPEACHMSK1;                    /*!< Device Each IN Endpoint 1 Interrupt Register                          */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  TimeOUTMsk :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INTknTXFEmpMsk:  1;            /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INTknEPMisMsk:  1;             /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INEPNakEffMsk:  1;             /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  TxfifoUndrnMsk:  1;            /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t             :  4;
      __IO uint32_t  NAKMsk     :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t : 18; // padding
    } DIEPEACHMSK1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPEACHMSK2;                    /*!< Device Each IN Endpoint 2 Interrupt Register                          */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  TimeOUTMsk :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INTknTXFEmpMsk:  1;            /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INTknEPMisMsk:  1;             /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INEPNakEffMsk:  1;             /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  TxfifoUndrnMsk:  1;            /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t             :  4;
      __IO uint32_t  NAKMsk     :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t : 18; // padding
    } DIEPEACHMSK2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPEACHMSK3;                    /*!< Device Each IN Endpoint 3 Interrupt Register                          */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  TimeOUTMsk :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INTknTXFEmpMsk:  1;            /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INTknEPMisMsk:  1;             /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
      __IO uint32_t  INEPNakEffMsk:  1;             /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  TxfifoUndrnMsk:  1;            /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t             :  4;
      __IO uint32_t  NAKMsk     :  1;               /*!< Refer to the description of the corresponding field in [DIEPEACHMSK0]. */
           uint32_t : 18; // padding
    } DIEPEACHMSK3_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[12];
  
  union {
    __IO uint32_t  DOEPEACHMSK0;                    /*!< Device Each OUT Endpoint 16 Interrupt Register                        */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Transfer Completed Interrupt Mask (XferComplMsk)                      */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Endpoint Disabled Interrupt Mask (EPDisbldMsk)                        */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< AHB Error (AHBErrMsk)                                                 */
      __IO uint32_t  SetUPMsk   :  1;               /*!< SETUP Phase Done Mask (SetUPMsk) Applies to control endpoints
                                                         only.                                                                 */
      __IO uint32_t  OUTTknEPdisMsk:  1;            /*!< OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)
                                                         Applies to control OUT endpoints only.                                */
           uint32_t             :  1;
      __IO uint32_t  Back2BackSETup:  1;            /*!< Back-to-Back SETUP Packets Received Mask (Back2BackSETup) Applies
                                                         to control OUT endpoints only.                                        */
           uint32_t             :  1;
      __IO uint32_t  OutPktErrMsk:  1;              /*!< OUT Packet Error Mask (OutPktErrMsk)                                  */
           uint32_t             :  3;
      __IO uint32_t  BbleErrMsk :  1;               /*!< Babble Error interrupt Mask (BbleErrMsk)                              */
      __IO uint32_t  NAKMsk     :  1;               /*!< NAK interrupt Mask (NAKMsk)                                           */
      __IO uint32_t  NYETMsk    :  1;               /*!< NYET interrupt Mask (NYETMsk)                                         */
           uint32_t : 17; // padding
    } DOEPEACHMSK0_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPEACHMSK1;                    /*!< Device Each OUT Endpoint 1 Interrupt Register                         */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  SetUPMsk   :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  OUTTknEPdisMsk:  1;            /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  Back2BackSETup:  1;            /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  OutPktErrMsk:  1;              /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  3;
      __IO uint32_t  BbleErrMsk :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  NAKMsk     :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  NYETMsk    :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t : 17; // padding
    } DOEPEACHMSK1_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPEACHMSK2;                    /*!< Device Each OUT Endpoint 2 Interrupt Register                         */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  SetUPMsk   :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  OUTTknEPdisMsk:  1;            /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  Back2BackSETup:  1;            /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  OutPktErrMsk:  1;              /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  3;
      __IO uint32_t  BbleErrMsk :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  NAKMsk     :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  NYETMsk    :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t : 17; // padding
    } DOEPEACHMSK2_b;                               /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPEACHMSK3;                    /*!< Device Each OUT Endpoint 3 Interrupt Register                         */
    
    struct {
      __IO uint32_t  XferComplMsk:  1;              /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  EPDisbldMsk:  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  AHBErrMsk  :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  SetUPMsk   :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  OUTTknEPdisMsk:  1;            /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  Back2BackSETup:  1;            /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  1;
      __IO uint32_t  OutPktErrMsk:  1;              /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t             :  3;
      __IO uint32_t  BbleErrMsk :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  NAKMsk     :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
      __IO uint32_t  NYETMsk    :  1;               /*!< Refer to the description of the corresponding field in [DOEPEACHMSK0]. */
           uint32_t : 17; // padding
    } DOEPEACHMSK3_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[28];
  
  union {
    __IO uint32_t  DIEPCTL0;                        /*!< Device Control IN Endpoint 0 Control Register                         */
    
    struct {
      __IO uint32_t  MPS        :  2;               /*!< Maximum Packet Size (MPS)Applies to IN and OUT endpoints.The
                                                         application must program this field with the maximum packet
                                                          size for the current logical endpoint.- 2b00: 64 bytes- 2b01:
                                                          32 bytes- 2b10: 16 bytes- 2b11: 8 bytes                              */
           uint32_t             :  9;
      __IO uint32_t  NextEp     :  4;               /*!< Next Endpoint (NextEp)Applies to non-periodic IN endpoints only.Indicates
                                                         the endpoint number to be fetched after the data for the current
                                                          endpoint is fetched. The core can access this field, even when
                                                          the Endpoint Enable (EPEna) bit is not set. This field is not
                                                          valid in Slave mode.Note: This field is valid only for Shared
                                                          FIFO operations.                                                     */
      __I  uint32_t  USBActEP   :  1;               /*!< USB Active Endpoint (USBActEP)This bit is always set to 1, indicating
                                                         that control endpoint 0 is always active in all configurations
                                                          and interfaces.                                                      */
           uint32_t             :  1;
      __I  uint32_t  NAKSts     :  1;               /*!< NAK Status (NAKSts)Indicates the following:- 1b0: The core is
                                                         transmitting non-NAK handshakes based on the FIFO status- 1b1:
                                                          The core is transmitting NAK handshakes on this endpoint.When
                                                          this bit is set, either by the application or core, the core
                                                          stops transmitting data, even If there is data available in
                                                          the TxFIFO. Irrespective of this bit setting, the core always
                                                          responds to SETUP data packets with an ACK handshake.                */
      __I  uint32_t  EPType     :  2;               /*!< Endpoint Type (EPType)Hardcoded to 00 for control.                    */
           uint32_t             :  1;
      __IO uint32_t  Stall      :  1;               /*!< STALL Handshake (Stall)The application sets this bit, and the
                                                         core clears it when a SETUP token is received for this endpoint.
                                                          If a NAK bit, Global Non-periodic IN NAK, or Global OUT NAK
                                                          is set along with this bit, the STALL bit takes priority.            */
      __IO uint32_t  TxFNum     :  4;               /*!< TxFIFO Number (TxFNum)For Shared FIFO operation, this value
                                                         is always set to 0, indicating that control IN endpoint 0 data
                                                          is always written in the Non-Periodic Transmit FIFO.For Dedicated
                                                          FIFO operation, only FIFO0 can be used for EP0.                      */
      __IO uint32_t  CNAK       :  1;               /*!< Clear NAK (CNAK)A write to this bit clears the NAK bit for the
                                                         endpoint.                                                             */
      __IO uint32_t  SNAK       :  1;               /*!< Set NAK (SNAK)A write to this bit sets the NAK bit for the endpoint.
                                                         Using this bit, the application can control the transmission
                                                          of NAK handshakes on an endpoint. The core can also set this
                                                          bit for an endpoint after a SETUP packet is received on that
                                                          endpoint.                                                            */
           uint32_t             :  2;
      __IO uint32_t  EPDis      :  1;               /*!< Endpoint Disable (EPDis)The application sets this bit to stop
                                                         transmitting data on an endpoint even before the transfer for
                                                          that endpoint is complete. The application must wait for the
                                                          Endpoint Disabled interrupt before treating the endpoint as
                                                          disabled. The core clears this bit before setting the Endpoint
                                                          Disabled Interrupt. The application must set this bit only If
                                                          Endpoint Enable is already set for this endpoint. This bit is
                                                          valid only when DMA mode is enabled.                                 */
      __IO uint32_t  EPEna      :  1;               /*!< Endpoint Enable (EPEna)When Scatter/Gather DMA mode is enabled
                                                         for IN endpoints, this bit indicates that the descriptor structure
                                                          and data buffer with data ready to transmit is setup. When Scatter/Gather
                                                          DMA mode is disabled (such as in buffer pointer based DMA mode)
                                                          this bit indicates that data is ready to be transmitted on the
                                                          endpoint. The core clears this bit before setting the following
                                                          interrupts on this endpoint:- Endpoint Disabled- Transfer Completed  */
    } DIEPCTL0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6;
  
  union {
    __IO uint32_t  DIEPINT0;                        /*!< Device IN Endpoint 0 Interrupt Register                               */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Transfer Completed Interrupt (XferCompl)Applies to IN and OUT
                                                         endpoints.- When Scatter/Gather DMA mode is enabled- For IN
                                                          endpoint this field indicates that the requested data from the
                                                          descriptor is moved from external system memory to internal
                                                          FIFO.- For OUT endpoint this field indicates that the requested
                                                          data from the internal FIFO is moved to external system memory.
                                                          This interrupt is generated only when the corresponding endpoint
                                                          descriptor is closed, and the IOC bit for the corresponding
                                                          descriptor is                                                        */
      __IO uint32_t  EPDisbld   :  1;               /*!< Endpoint Disabled Interrupt (EPDisbld)Applies to IN and OUT
                                                         endpoints.This bit indicates that the endpoint is disabled per
                                                          the applications request.                                            */
      __IO uint32_t  AHBErr     :  1;               /*!< AHB Error (AHBErr)Applies to IN and OUT endpoints.This is generated
                                                         only in Internal DMA mode when there is an AHB error during
                                                          an AHB read/write. The application can read the corresponding
                                                          endpoint DMA address register to get the error address.              */
      __IO uint32_t  TimeOUT    :  1;               /*!< Timeout Condition (TimeOUT)- In shared TX FIFO mode, applies
                                                         to non-isochronous IN endpoints only.- In dedicated FIFO mode,
                                                          applies only to Control IN endpoints.- In Scatter/Gather DMA
                                                          mode, the TimeOUT interrupt is not asserted.Indicates that the
                                                          core has detected a timeout condition on the USB for the last
                                                          IN token on this endpoint.                                           */
      __IO uint32_t  INTknTXFEmp:  1;               /*!< IN Token Received When TxFIFO is Empty (INTknTXFEmp)Indicates
                                                         that an IN token was received when the associated TxFIFO (periodic/non-per
                                                         iodic) was empty. This interrupt is asserted on theendpoint for
                                                          which the IN token was received.                                     */
      __IO uint32_t  INTknEPMis :  1;               /*!< IN Token Received with EP Mismatch (INTknEPMis)Applies to non-periodic
                                                         IN endpoints only.Indicates that the data in the top of the
                                                          non-periodic TxFIFO belongs to an endpoint other than the one
                                                          for which the IN token was received. This interrupt is asserted
                                                          on the endpoint for which the IN token was received.                 */
      __IO uint32_t  INEPNakEff :  1;               /*!< IN Endpoint NAK Effective (INEPNakEff)This bit should be cleared
                                                         by writing a 1b1 before writing a 1b1 to corresponding [DIEPCTLn].CNAK.The
                                                          interrupt indicates that the IN endpoint NAK bit set by the
                                                          application has taken effect in the core.This interrupt does
                                                          not guarantee that a NAK handshake is sent on the USB. A STALL
                                                          bit takes priority over a NAK bit.This bit is applicable only
                                                          when the endpoint is enabled.                                        */
      __I  uint32_t  TxFEmp     :  1;               /*!< Transmit FIFO Empty (TxFEmp)This bit is valid only for IN EndpointsThis
                                                         interrupt is asserted when the TxFIFO for this endpoint is either
                                                          half or completely empty. The half or completely empty status
                                                          is determined by the TxFIFO Empty Level bit in the Core AHB
                                                          Configuration register ([GAHBCFG].NPTxFEmpLvl)).                     */
           uint32_t             :  1;
      __IO uint32_t  BNAIntr    :  1;               /*!< BNA (Buffer Not Available) Interrupt (BNAIntr)The core generates
                                                         this interrupt when the descriptor accessed is not ready for
                                                          the Core to process, such as Host busy or DMA doneDependency:
                                                          This bit is valid only when Scatter/Gather DMA mode is enabled.      */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Packet Dropped Status (PktDrpSts)This bit indicates to the application
                                                         that an ISOC OUT packet has been dropped. This bit does not
                                                          have an associated mask bit and does not generate an interrupt.Dependency:
                                                          This bit is valid in non Scatter/Gather DMA mode when periodic
                                                          transfer interrupt feature is selected.                              */
      __IO uint32_t  BbleErr    :  1;               /*!< BbleErr (Babble Error) interrupt (BbleErrIntrpt)The core generates
                                                         this interrupt when babble is received for the endpoint.              */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< NAK interrupt (NAKIntrpt)The core generates this interrupt when
                                                         a NAK is transmitted. In case of isochronous IN endpoints the
                                                          interrupt gets generated when a zero length packet is transmitted
                                                          due to unavailability of data in the TXFifo.                         */
      __IO uint32_t  NYETIntrpt :  1;               /*!< NYET interrupt (NYETIntrpt)The core generates this interrupt
                                                         when a NYET response is transmitted for a non isochronous OUT
                                                          endpoint.                                                            */
           uint32_t : 17; // padding
    } DIEPINT0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7;
  
  union {
    __IO uint32_t  DIEPTSIZ0;                       /*!< Device IN Endpoint 0 Transfer Size Register                           */
    
    struct {
      __IO uint32_t  XferSize   :  7;               /*!< Transfer Size (XferSize)Indicates the transfer size in bytes
                                                         for endpoint 0. The core interrupts the application only after
                                                          it has exhausted the transfer size amount of data. The transfer
                                                          size can be set to the maximum packet size of the endpoint,
                                                          to be interrupted at the end of each packet.The core decrements
                                                          this field every time a packet from the external memory is written
                                                          to the TxFIFO.                                                       */
           uint32_t             : 12;
      __IO uint32_t  PktCnt     :  2;               /*!< Packet Count (PktCnt)Indicates the total number of USB packets
                                                         that constitute the Transfer Size amount of data for endpoint
                                                          0.This field is decremented every time a packet (maximum size
                                                          or short packet) is read from the TxFIFO.                            */
           uint32_t : 11; // padding
    } DIEPTSIZ0_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPDMA0;                        /*!< Device IN Endpoint 0 DMA Address Register                             */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< DMA Address (DMAAddr)Holds the start address of the external
                                                         memory for storing or fetching endpoint data.Note: For control
                                                          endpoints, this field stores control OUT data packets as well
                                                          as SETUP transaction data packets. When more than three SETUP
                                                          packets are received back-to-back, the SETUP data packet in
                                                          the memory is overwritten.This register is incremented on every
                                                          AHB transaction. The application can give only a DWORD-aligned
                                                          address.- When Scatter/Gather DMA mode is not enabled, the application
                                                          progr                                                                */
    } DIEPDMA0_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTXFSTS0;                        /*!< Device IN Endpoint Transmit FIFO Status Register 0                    */
    
    struct {
      __I  uint32_t  INEPTxFSpcAvail: 16;           /*!< IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)Indicates the
                                                         amount of free space available in the Endpoint TxFIFO.Values
                                                          are in terms of 32-bit words.- 16h0: Endpoint TxFIFO is full-
                                                          16h1: 1 word available- 16h2: 2 words available- 16hn: n words
                                                          available (where 0 less than or equal to n less than or equal
                                                          to 32,768)- 16h8000: 32,768 words available- Others: Reserved        */
           uint32_t : 16; // padding
    } DTXFSTS0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8;
  
  union {
    __IO uint32_t  DIEPCTL1;                        /*!< Device Control IN Endpoint 1 Control Register                         */
    
    struct {
      __IO uint32_t  MPS        : 11;               /*!< Maximum Packet Size (MPS)Applies to IN and OUT endpoints.The
                                                         application must program this field with the maximum packet
                                                          size for the current logical endpoint. This value is in bytes.       */
      __IO uint32_t  NextEp     :  4;               /*!< Next Endpoint (NextEp)Applies to non-periodic IN endpoints only.Indicates
                                                         the endpoint number to be fetched after the data for the currentendpoint
                                                          is fetched. The core can access this field, even when the EndpointEnable
                                                          (EPEna) bit is low. This field is not valid in Slave mode operation.Note:
                                                          This field is valid only for Shared FIFO operations.                 */
      __I  uint32_t  USBActEP   :  1;               /*!< USB Active Endpoint (USBActEP)Applies to IN and OUT endpoints.Indicates
                                                         whether this endpoint is active in the current configuration
                                                          and interface. The core clears this bit for all endpoints (other
                                                          than EP 0) after detecting a USB reset. After receiving the
                                                          SetConfiguration and SetInterface commands, the application
                                                          must program endpoint registers accordingly and set this bit.        */
      __I  uint32_t  DPID       :  1;               /*!< Endpoint Data PID (DPID)Applies to interrupt/bulk IN and OUT
                                                         endpoints only.Contains the PID of the packet to be received
                                                          or transmitted on this endpoint.The application must program
                                                          the PID of the first packet to be received or transmitted on
                                                          this endpoint, after the endpoint is activated. The applications
                                                          use the SetD1PID and SetD0PID fields of this register to program
                                                          either DATA0 or DATA1 PID.- 1b0: DATA0- 1b1: DATA1This field
                                                          is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
                                                          DMA mo                                                               */
      __I  uint32_t  NAKSts     :  1;               /*!< NAK Status (NAKSts)Applies to IN and OUT endpoints.Indicates
                                                         the following:- 1b0: The core is transmitting non-NAK handshakes
                                                          based on the FIFO status.- 1b1: The core is transmitting NAK
                                                          handshakes on this endpoint. When either the application or
                                                          the core sets this bit:- The core stops receiving any data on
                                                          an OUT endpoint, even if there is space in the RxFIFO to accommodate
                                                          the incoming packet.- For non-isochronous IN endpoints: The
                                                          core stops transmitting any data on an IN endpoint, even if
                                                          there data is                                                        */
      __I  uint32_t  EPType     :  2;               /*!< Endpoint Type (EPType)Applies to IN and OUT endpoints.This is
                                                         the transfer type supported by this logical endpoint.- 2b00:
                                                          Control- 2b01: Isochronous- 2b10: Bulk- 2b11: Interrupt              */
           uint32_t             :  1;
      __IO uint32_t  Stall      :  1;               /*!< STALL Handshake (Stall)Applies to non-control, non-isochronous
                                                         IN and OUT endpoints only.The application sets this bit to stall
                                                          all tokens from the USB host to this endpoint.If a NAK bit,
                                                          Global Non-periodic IN NAK, or Global OUT NAK is set along with
                                                          this bit, the STALL bit takes priority. Only the application
                                                          can clear this bit, never the core.                                  */
      __IO uint32_t  TxFNum     :  4;               /*!< TxFIFO Number (TxFNum)Shared FIFO Operation-non-periodic endpoints
                                                         must set this bit to zero.Periodic endpoints must map this to
                                                          the corresponding Periodic TxFIFO number.- 4h0: Non-Periodic
                                                          TxFIFO- Others: Specified Periodic TxFIFO.numberNote: An interrupt
                                                          IN endpoint can be configured as a non-periodic endpoint for
                                                          applications such as mass storage. The core treats an IN endpoint
                                                          as a nonperiodic endpoint if the TxFNum field is set to 0. Otherwise,
                                                          a separate periodic FIFO must be allocated for an interru            */
      __IO uint32_t  CNAK       :  1;               /*!< Clear NAK (CNAK)Applies to IN and OUT endpoints.A write to this
                                                         bit clears the NAK bit for the endpoint.                              */
      __IO uint32_t  SNAK       :  1;               /*!< Set NAK (SNAK)Applies to IN and OUT endpoints.A write to this
                                                         bit sets the NAK bit for the endpoint.Using this bit, the application
                                                          can control the transmission of NAK handshakes on an endpoint.
                                                          The core can also set this bit for OUT endpoints on a Transfer
                                                          Completed interrupt, or after a SETUP is received on the endpoint.   */
      __IO uint32_t  SetD0PID   :  1;               /*!< Set DATA0 PID (SetD0PID)Applies to interrupt/bulk IN and OUT
                                                         endpoints only.Writing to this field sets the Endpoint Data
                                                          PID (DPID) field in this register to DATA0.This field is applicable
                                                          both for Scatter/Gather DMA mode and non-Scatter/Gather DMA
                                                          mode.                                                                */
      __IO uint32_t  SetD1PID   :  1;               /*!< Set DATA1 PID (SetD1PID)Applies to interrupt/bulk IN and OUT
                                                         endpoints only.Writing to this field sets the Endpoint Data
                                                          PID (DPID) field in this register to DATA1.This field is applicable
                                                          both for Scatter/Gather DMA mode and non-Scatter/Gather DMA
                                                          mode.                                                                */
      __IO uint32_t  EPDis      :  1;               /*!< Endpoint Disable (EPDis)Applies to IN and OUT endpoints.The
                                                         application sets this bit to stop transmitting/receiving data
                                                          on an endpoint, even before the transfer for that endpoint is
                                                          complete. The application must wait for the Endpoint Disabled
                                                          interrupt before treating the endpoint as disabled. The core
                                                          clears this bit before setting the Endpoint Disabled interrupt.
                                                          The application must set this bit only if Endpoint Enable is
                                                          already set for this endpoint.                                       */
      __IO uint32_t  EPEna      :  1;               /*!< Endpoint Enable (EPEna)Applies to IN and OUT endpoints.- When
                                                         Scatter/Gather DMA mode is enabled,- For IN endpoints this bit
                                                          indicates that the descriptor structure and data buffer with
                                                          data ready to transmit is setup.- For OUT endpoint it indicates
                                                          that the descriptor structure and data buffer to receive data
                                                          is setup.- When Scatter/Gather DMA mode is enabled-such as for
                                                          buffer-pointer based DMA mode:- For IN endpoints, this bit indicates
                                                          that data is ready to be transmitted on the endpoint.- For OUT
                                                          endp                                                                 */
    } DIEPCTL1_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED9;
  
  union {
    __IO uint32_t  DIEPINT1;                        /*!< Device IN Endpoint 1 Interrupt Register                               */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  EPDisbld   :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  AHBErr     :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  TimeOUT    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INTknTXFEmp:  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INTknEPMis :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INEPNakEff :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __I  uint32_t  TxFEmp     :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  BNAIntr    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  BbleErr    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  NYETIntrpt :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t : 17; // padding
    } DIEPINT1_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED10;
  
  union {
    __IO uint32_t  DIEPTSIZ1;                       /*!< Device IN Endpoint 1 Transfer Size Register                           */
    
    struct {
      __IO uint32_t  XferSize   : 19;               /*!< Transfer Size (XferSize)This field contains the transfer size
                                                         in bytes for the current endpoint. The transfer size (XferSize)
                                                          = Sum of buffer sizes across all descriptors in the list for
                                                          the endpoint.In Buffer DMA, the core only interrupts the application
                                                          after it has exhausted the transfer size amount of data. The
                                                          transfer size can be set to the maximum packet size of the endpoint,
                                                          to be interrupted at the end of each packet.- IN Endpoints:
                                                          The core decrements this field every time a packet from the
                                                          exter                                                                */
      __IO uint32_t  PktCnt     : 10;               /*!< Packet Count (PktCnt)Indicates the total number of USB packets
                                                         that constitute the Transfer Size amount of data for this endpoint
                                                          (PktCnt = XferSize / MPS). - IN Endpoints: This field is decremented
                                                          every time a packet (maximum size or short packet) is read from
                                                          the TxFIFO.- OUT Endpoints: This field is decremented every
                                                          time a packet (maximum size or short packet) is written to the
                                                          RxFIFO.                                                              */
      __IO uint32_t  MC         :  2;               /*!< Multi Count (MC)Applies to IN endpoints only.For periodic IN
                                                         endpoints, this field indicates the number of packets that must
                                                          be transmitted per microframe on the USB. The core uses this
                                                          field to calculate the data PID for isochronous IN endpoints.-
                                                          2b01: 1 packet- 2b10: 2 packets- 2b11: 3 packetsFor non-periodic
                                                          IN endpoints, this field is valid only in Internal DMA mode.
                                                          It specifies the number of packets the core must fetch for an
                                                          IN endpoint before it switches to the endpoint pointed to by
                                                          the Next Endp                                                        */
           uint32_t : 1; // padding
    } DIEPTSIZ1_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPDMA1;                        /*!< Device IN Endpoint 1 DMA Address Register                             */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< Refer to the description of [DIEPDMA0].DMAAddr.                       */
    } DIEPDMA1_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTXFSTS1;                        /*!< Device IN Endpoint Transmit FIFO Status Register 1                    */
    
    struct {
      __I  uint32_t  INEPTxFSpcAvail: 16;           /*!< Refer to the description of [DTXFSTS0].INEPTxFSpcAvail.               */
           uint32_t : 16; // padding
    } DTXFSTS1_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED11;
  
  union {
    __IO uint32_t  DIEPCTL2;                        /*!< Device Control IN Endpoint 2 Control Register                         */
    
    struct {
      __IO uint32_t  MPS        : 11;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  NextEp     :  4;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  USBActEP   :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  DPID       :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  NAKSts     :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  EPType     :  2;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
           uint32_t             :  1;
      __IO uint32_t  Stall      :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  TxFNum     :  4;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  CNAK       :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  SNAK       :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  SetD0PID   :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  SetD1PID   :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  EPDis      :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  EPEna      :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
    } DIEPCTL2_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED12;
  
  union {
    __IO uint32_t  DIEPINT2;                        /*!< Device IN Endpoint 2 Interrupt Register                               */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  EPDisbld   :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  AHBErr     :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  TimeOUT    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INTknTXFEmp:  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INTknEPMis :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INEPNakEff :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __I  uint32_t  TxFEmp     :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  BNAIntr    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  BbleErr    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  NYETIntrpt :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t : 17; // padding
    } DIEPINT2_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED13;
  
  union {
    __IO uint32_t  DIEPTSIZ2;                       /*!< Device IN Endpoint 2 Transfer Size Register                           */
    
    struct {
      __IO uint32_t  XferSize   : 19;               /*!< Refer to the description of [DIEPTSIZ1]XferSize                       */
      __IO uint32_t  PktCnt     : 10;               /*!< Refer to the description of [DIEPTSIZ1].PktCnt.                       */
      __IO uint32_t  MC         :  2;               /*!< Refer to the description of [DIEPTSIZ1].MC.                           */
           uint32_t : 1; // padding
    } DIEPTSIZ2_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPDMA2;                        /*!< Device IN Endpoint 2 DMA Address Register                             */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< Refer to the description of [DIEPDMA0].DMAAddr.                       */
    } DIEPDMA2_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTXFSTS2;                        /*!< Device IN Endpoint Transmit FIFO Status Register 2                    */
    
    struct {
      __I  uint32_t  INEPTxFSpcAvail: 16;           /*!< Refer to the description of [DTXFSTS0].INEPTxFSpcAvail.               */
           uint32_t : 16; // padding
    } DTXFSTS2_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED14;
  
  union {
    __IO uint32_t  DIEPCTL3;                        /*!< Device Control IN Endpoint 3 Control Register                         */
    
    struct {
      __IO uint32_t  MPS        : 11;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  NextEp     :  4;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  USBActEP   :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  DPID       :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  NAKSts     :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __I  uint32_t  EPType     :  2;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
           uint32_t             :  1;
      __IO uint32_t  Stall      :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  TxFNum     :  4;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  CNAK       :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  SNAK       :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  SetD0PID   :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  SetD1PID   :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  EPDis      :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
      __IO uint32_t  EPEna      :  1;               /*!< Refer to the description of the corresponding field in DIEPCTL1].     */
    } DIEPCTL3_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED15;
  
  union {
    __IO uint32_t  DIEPINT3;                        /*!< Device IN Endpoint 3 Interrupt Register                               */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  EPDisbld   :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  AHBErr     :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  TimeOUT    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INTknTXFEmp:  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INTknEPMis :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  INEPNakEff :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __I  uint32_t  TxFEmp     :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  BNAIntr    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  BbleErr    :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
      __IO uint32_t  NYETIntrpt :  1;               /*!< Refer to the description of the corresponding field in [DIEPINT0].    */
           uint32_t : 17; // padding
    } DIEPINT3_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED16;
  
  union {
    __IO uint32_t  DIEPTSIZ3;                       /*!< Device IN Endpoint 3 Transfer Size Register                           */
    
    struct {
      __IO uint32_t  XferSize   : 19;               /*!< Refer to the description of [DIEPTSIZ1]XferSize                       */
      __IO uint32_t  PktCnt     : 10;               /*!< Refer to the description of [DIEPTSIZ1].PktCnt.                       */
      __IO uint32_t  MC         :  2;               /*!< Refer to the description of [DIEPTSIZ1].MC.                           */
           uint32_t : 1; // padding
    } DIEPTSIZ3_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DIEPDMA3;                        /*!< Device IN Endpoint 3 DMA Address Register                             */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< Refer to the description of [DIEPDMA0].DMAAddr.                       */
    } DIEPDMA3_b;                                   /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  DTXFSTS3;                        /*!< Device IN Endpoint Transmit FIFO Status Register 3                    */
    
    struct {
      __I  uint32_t  INEPTxFSpcAvail: 16;           /*!< Refer to the description of [DTXFSTS0].INEPTxFSpcAvail.               */
           uint32_t : 16; // padding
    } DTXFSTS3_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED17[97];
  
  union {
    __IO uint32_t  DOEPCTL0;                        /*!< Device Control OUT Endpoint 0 Control Register                        */
    
    struct {
      __IO uint32_t  MPS        :  2;               /*!< Maximum Packet Size (MPS)The maximum packet size for control
                                                         OUT endpoint 0 is the same as what is programmed in control
                                                          IN Endpoint 0.- 2b00: 64 bytes- 2b01: 32 bytes- 2b10: 16 bytes-
                                                          2b11: 8 bytes                                                        */
           uint32_t             : 13;
      __I  uint32_t  USBActEP   :  1;               /*!< USB Active Endpoint (USBActEP)This bit is always set to 1, indicating
                                                         that a control endpoint 0 is always active in all configurations
                                                          and interfaces.                                                      */
           uint32_t             :  1;
      __I  uint32_t  NAKSts     :  1;               /*!< NAK Status (NAKSts)Indicates the following:- 1b0: The core is
                                                         transmitting non-NAK handshakes based on the FIFO status.- 1b1:
                                                          The core is transmitting NAK handshakes on this endpoint.When
                                                          either the application or the core sets this bit, the core stops
                                                          receiving data, even If there is space in the RxFIFO to accommodate
                                                          the incoming packet. Irrespective of this bit setting, the core
                                                          always responds to SETUP data packets with an ACK handshake.         */
      __I  uint32_t  EPType     :  2;               /*!< Endpoint Type (EPType)Hardcoded to 2b00 for control                   */
      __IO uint32_t  Snp        :  1;               /*!< Snoop Mode (Snp)This bit configures the endpoint to Snoop mode.
                                                         In Snoop mode, the core does not check if the OUT packets are
                                                          correct before transferring them to application memory.              */
      __IO uint32_t  Stall      :  1;               /*!< STALL Handshake (Stall)The application sets this bit, and the
                                                         core clears it, when a SETUP token is received for this endpoint.
                                                          If a NAK bit or Global OUT NAK is set along with this bit, the
                                                          STALL bit takes priority. Irrespective of this bit setting,
                                                          the core always responds to SETUP data packets with an ACK handshake. */
           uint32_t             :  4;
      __IO uint32_t  CNAK       :  1;               /*!< Clear NAK (CNAK)A write to this bit clears the NAK bit for the
                                                         endpoint.                                                             */
      __IO uint32_t  SNAK       :  1;               /*!< Set NAK (SNAK)A write to this bit sets the NAK bit for the endpoint.
                                                         Using this bit, the application can control the transmission
                                                          of NAK handshakes on an endpoint.The core can also Set bit on
                                                          a Transfer Completed interrupt, or after a SETUP is received
                                                          on the endpoint.                                                     */
           uint32_t             :  2;
      __IO uint32_t  EPDis      :  1;               /*!< Endpoint Disable (EPDis)The application cannot disable control
                                                         OUT endpoint 0.                                                       */
      __IO uint32_t  EPEna      :  1;               /*!< Endpoint Enable (EPEna)When Scatter/Gather DMA mode is enabled,
                                                         for OUT endpoints this bit indicates that the descriptor structure
                                                          and data buffer to receive data is set up.When Scatter/Gather
                                                          DMA mode is disabled (such as for buffer-pointer based DMA mode),
                                                          this bit indicates that the application has allocated the memory
                                                          to start receiving data from the USB.The core clears this bit
                                                          before setting any of the following interrupts on this endpoint:-
                                                          SETUP Phase Done- Endpoint Disabled- Transfer CompletedNote          */
    } DOEPCTL0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED18;
  
  union {
    __IO uint32_t  DOEPINT0;                        /*!< Device OUT Endpoint 0 Interrupt Register                              */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Transfer Completed Interrupt (XferCompl)Applies to IN and OUT
                                                         endpoints.- When Scatter/Gather DMA mode is enabled - For IN
                                                          endpoint this field indicates that the requested data from the
                                                          descriptor is moved from external system memory to internal
                                                          FIFO.- For OUT endpoint this field indicates that the requested
                                                          data from the internal FIFO is moved to external system memory.
                                                          This interrupt is generated only when the corresponding endpoint
                                                          descriptor is closed, and the IOC bit for the corresponding
                                                          descriptor i                                                         */
      __IO uint32_t  EPDisbld   :  1;               /*!< Endpoint Disabled Interrupt (EPDisbld)Applies to IN and OUT
                                                         endpoints.This bit indicates that the endpoint is disabled per
                                                          the applications request.                                            */
      __IO uint32_t  AHBErr     :  1;               /*!< AHB Error (AHBErr)Applies to IN and OUT endpoints.This is generated
                                                         only in Internal DMA mode when there is an AHB error during
                                                          an AHB read/write. The application can read the corresponding
                                                          endpoint DMA address register to get the error address.              */
      __IO uint32_t  SetUp      :  1;               /*!< SETUP Phase Done (SetUp)Applies to control OUT endpoints only.Indicates
                                                         that the SETUP phase for the control endpoint is complete and
                                                          no more back-to-back SETUP packets were received for the current
                                                          control transfer. On this interrupt, the application can decode
                                                          the received SETUP data packet.                                      */
      __IO uint32_t  OUTTknEPdis:  1;               /*!< OUT Token Received When Endpoint Disabled (OUTTknEPdis)Indicates
                                                         that an OUT token was received when the endpoint was not yet
                                                          enabled. This interrupt is asserted on the endpoint for which
                                                          the OUT token was received.                                          */
      __IO uint32_t  StsPhseRcvd:  1;               /*!< Status Phase Received For Control Write (StsPhseRcvd)This interrupt
                                                         is valid only for Control OUT endpoints.This interrupt is generated
                                                          only after the core has transferred all the data that the host
                                                          has sent during the data phase of a control write transfer,
                                                          to the system memory buffer.The interrupt indicates to the application
                                                          that the host has switched from data phase to the status phase
                                                          of a Control Write transfer. The application can use this interrupt
                                                          to ACK or STALL the Status phase, after it has dec                   */
      __IO uint32_t  Back2BackSETup:  1;            /*!< Back-to-Back SETUP Packets Received (Back2BackSETup)Applies
                                                         to Control OUT endpoints only.This bit indicates that the core
                                                          has received more than three back-to-back SETUP packets for
                                                          this particular endpoint.This bit is not valid in Slave mode.        */
           uint32_t             :  2;
      __IO uint32_t  BNAIntr    :  1;               /*!< BNA (Buffer Not Available) Interrupt (BNAIntr)The core generates
                                                         this interrupt when the descriptor accessed is not ready for
                                                          the Core to process, such as Host busy or DMA doneDependency:
                                                          This bit is valid only when Scatter/Gather DMA mode is enabled.      */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Packet Dropped Status (PktDrpSts)This bit indicates to the application
                                                         that an ISOC OUT packet has been dropped. This bit does not
                                                          have an associated mask bit and does not generate an interrupt.Dependency:
                                                          This bit is valid in non Scatter/Gather DMA mode when periodic
                                                          transfer interrupt feature is selected.                              */
      __IO uint32_t  BbleErr    :  1;               /*!< BbleErr (Babble Error) interrupt (BbleErrIntrpt)The core generates
                                                         this interrupt when babble is received for the endpoint.              */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< NAK interrupt (NAKIntrpt)The core generates this interrupt when
                                                         a NAK is transmitted. In case of isochronous IN endpoints the
                                                          interrupt gets generated when a zero length packet is transmitted
                                                          due to unavailability of data in the TXFifo.                         */
      __IO uint32_t  NYETIntrpt :  1;               /*!< NYET interrupt (NYETIntrpt)The core generates this interrupt
                                                         when a NYET response is transmitted for a non isochronous OUT
                                                          endpoint.                                                            */
      __IO uint32_t  StupPktRcvd:  1;               /*!< Setup Packet ReceivedApplicable for Control OUT Endpoints in
                                                         only in the Buffer DMA ModeSet by the DWC_otg core, this bit
                                                          indicates that this buffer holds 8 bytes of setup data. There
                                                          is only one Setup packet per buffer. On receiving a Setup packet,
                                                          the DWC_otg core closes the buffer and disables the corresponding
                                                          endpoint after SETUP_COMPLETE status is seen in the Rx FIFO.
                                                          The DWC_otg core puts a SETUP_COMPLETE status into the Rx FIFO
                                                          when it sees the first IN or OUT token after the SETUP packet
                                                          for that                                                             */
           uint32_t : 16; // padding
    } DOEPINT0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED19;
  
  union {
    __IO uint32_t  DOEPTSIZ0;                       /*!< Device OUT Endpoint 0 Transfer Size Register                          */
    
    struct {
      __IO uint32_t  XferSize   :  7;               /*!< Transfer Size (XferSize)Indicates the transfer size in bytes
                                                         for endpoint 0. The core interrupts the application only after
                                                          it has exhausted the transfer size amount of data. The transfer
                                                          size can be set to the maximum packet size of the endpoint,
                                                          to be interrupted at the end of each packet.The core decrements
                                                          this field every time a packet is read from the RxFIFO and written
                                                          to the external memory.                                              */
           uint32_t             : 12;
      __IO uint32_t  PktCnt     :  1;               /*!< Packet Count (PktCnt)This field is decremented to zero after
                                                         a packet is written into the RxFIFO.                                  */
           uint32_t             :  9;
      __IO uint32_t  SUPCnt     :  2;               /*!< SETUP Packet Count (SUPCnt)This field specifies the number of
                                                         back-to-back SETUP data packets the endpoint can receive.- 2b01:
                                                          1 packet- 2b10: 2 packets- 2b11: 3 packets                           */
           uint32_t : 1; // padding
    } DOEPTSIZ0_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPDMA0;                        /*!< Device OUT Endpoint 0 DMA Address Register                            */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< DMA Address (DMAAddr)Holds the start address of the external
                                                         memory for storing or fetching endpoint data.Note: For control
                                                          endpoints, this field stores control OUT data packets as well
                                                          as SETUP transaction data packets. When more than three SETUP
                                                          packets are received back-to-back, the SETUP data packet in
                                                          the memory is overwritten.This register is incremented on every
                                                          AHB transaction. The application can give only a DWORD-aligned
                                                          address.- When Scatter/Gather DMA mode is not enabled, the application
                                                          progr                                                                */
    } DOEPDMA0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED20[2];
  
  union {
    __IO uint32_t  DOEPCTL1;                        /*!< Device Control OUT Endpoint 1 Control Register                        */
    
    struct {
      __IO uint32_t  MPS        : 11;               /*!< Maximum Packet Size (MPS)Applies to IN and OUT endpoints.The
                                                         application must program this field with the maximum packet
                                                          size for the current logical endpoint. This value is in bytes.       */
      __IO uint32_t  NextEp     :  4;               /*!< Next Endpoint (NextEp)Applies to non-periodic IN endpoints only.Indicates
                                                         the endpoint number to be fetched after the data for the current
                                                          endpoint is fetched. The core can access this field, even when
                                                          the Endpoint Enable (EPEna) bit is low. This field is not valid
                                                          in Slave mode operation.Note: This field is valid only for Shared
                                                          FIFO operations.                                                     */
      __I  uint32_t  USBActEP   :  1;               /*!< USB Active Endpoint (USBActEP)Applies to IN and OUT endpoints.Indicates
                                                         whether this endpoint is active in the current configuration
                                                          and interface. The core clears this bit for all endpoints (other
                                                          than EP 0) after detecting a USB reset. After receiving the
                                                          SetConfiguration and SetInterface commands, the application
                                                          must program endpoint registers accordingly and set this bit.        */
      __I  uint32_t  DPID       :  1;               /*!< Endpoint Data PID (DPID)Applies to interrupt/bulk IN and OUT
                                                         endpoints only.Contains the PID of the packet to be received
                                                          or transmitted on this endpoint.The application must program
                                                          the PID of the first packet to be received or transmitted on
                                                          this endpoint, after the endpoint is activated. The applications
                                                          use the SetD1PID and SetD0PID fields of this register to program
                                                          either DATA0 orDATA1 PID.- 1b0: DATA0- 1b1: DATA1This field
                                                          is applicable both for Scatter/Gather DMA mode and non-Scatter/Gather
                                                          DMA mod                                                              */
      __I  uint32_t  NAKSts     :  1;               /*!< NAK Status (NAKSts)Applies to IN and OUT endpoints.Indicates
                                                         the following:- 1b0: The core is transmitting non-NAK handshakes
                                                          based on the FIFO status.- 1b1: The core is transmitting NAK
                                                          handshakes on this endpoint.When either the application or the
                                                          core sets this bit:- The core stops receiving any data on an
                                                          OUT endpoint, even if there is space in the RxFIFO to accommodate
                                                          the incoming packet.- For non-isochronous IN endpoints: The
                                                          core stops transmitting any data on an IN endpoint, even if
                                                          there data is                                                        */
      __I  uint32_t  EPType     :  2;               /*!< Endpoint Type (EPType)Applies to IN and OUT endpoints.This is
                                                         the transfer type supported by this logical endpoint.- 2b00:
                                                          Control- 2b01: Isochronous- 2b10: Bulk- 2b11: Interrupt              */
      __IO uint32_t  Snp        :  1;               /*!< Snoop Mode (Snp)Applies to OUT endpoints only.This bit configures
                                                         the endpoint to Snoop mode. In Snoop mode, the core does not
                                                          check the correctness of OUT packets before transferring them
                                                          to application memory.                                               */
      __IO uint32_t  Stall      :  1;               /*!< STALL Handshake (Stall)Applies to non-control, non-isochronous
                                                         IN and OUT endpoints only.The application sets this bit to stall
                                                          all tokens from the USB host to this endpoint.If a NAK bit,
                                                          Global Non-periodic IN NAK, or Global OUT NAK is set along with
                                                          this bit, the STALL bit takes priority. Only the application
                                                          can clear this bit, neverthe core.                                   */
           uint32_t             :  4;
      __IO uint32_t  CNAK       :  1;               /*!< Clear NAK (CNAK)Applies to IN and OUT endpoints.A write to this
                                                         bit clears the NAK bit for the endpoint.                              */
      __IO uint32_t  SNAK       :  1;               /*!< Set NAK (SNAK)Applies to IN and OUT endpoints.A write to this
                                                         bit sets the NAK bit for the endpoint.Using this bit, the application
                                                          can control the transmission of NAK handshakes on an endpoint.
                                                          The core can also set this bit for OUT endpoints on a Transfer
                                                          Completed interrupt, or after a SETUP is received on the endpoint.   */
      __IO uint32_t  SetD0PID   :  1;               /*!< Set DATA0 PID (SetD0PID)Applies to interrupt/bulk IN and OUT
                                                         endpoints only.Writing to this field sets the Endpoint Data
                                                          PID (DPID) field in this register to DATA0.This field is applicable
                                                          both for Scatter/Gather DMA mode and non-Scatter/Gather DMA
                                                          mode.                                                                */
      __IO uint32_t  SetD1PID   :  1;               /*!< Set DATA1 PID (SetD1PID)Applies to interrupt/bulk IN and OUT
                                                         endpoints only.Writing to this field sets the Endpoint Data
                                                          PID (DPID) field in this register to DATA1.This field is applicable
                                                          both for Scatter/Gather DMA mode and non-Scatter/Gather DMA
                                                          mode.                                                                */
      __IO uint32_t  EPDis      :  1;               /*!< Endpoint Disable (EPDis)Applies to IN and OUT endpoints.The
                                                         application sets this bit to stop transmitting/receiving data
                                                          on an endpoint, even before the transfer for that endpoint is
                                                          complete. The application must wait for the Endpoint Disabled
                                                          interrupt before treating the endpoint as disabled. The core
                                                          clears this bit before setting the Endpoint Disabled interrupt.
                                                          The application must set this bit only if Endpoint Enable is
                                                          already set for this endpoint.                                       */
      __IO uint32_t  EPEna      :  1;               /*!< Endpoint Enable (EPEna)Applies to IN and OUT endpoints.- When
                                                         Scatter/Gather DMA mode is enabled,- For IN endpoints this bit
                                                          indicates that the descriptor structure and data buffer with
                                                          data ready to transmit is setup.- For OUT endpoint it indicates
                                                          that the descriptor structure and data buffer to receive data
                                                          is setup.- When Scatter/Gather DMA mode is enabled-such as for
                                                          buffer-pointer based DMA mode:- For IN endpoints, this bit indicates
                                                          that data is ready to be transmitted on the endpoint.- For OUT
                                                          endp                                                                 */
    } DOEPCTL1_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED21;
  
  union {
    __IO uint32_t  DOEPINT1;                        /*!< Device OUT Endpoint 1 Interrupt Register                              */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  EPDisbld   :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  AHBErr     :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  SetUp      :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  OUTTknEPdis:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  StsPhseRcvd:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  Back2BackSETup:  1;            /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t             :  2;
      __IO uint32_t  BNAIntr    :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  BbleErr    :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  NYETIntrpt :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  StupPktRcvd:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t : 16; // padding
    } DOEPINT1_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED22;
  
  union {
    __IO uint32_t  DOEPTSIZ1;                       /*!< Device OUT Endpoint 1 Transfer Size Register                          */
    
    struct {
      __IO uint32_t  XferSize   : 19;               /*!< Transfer Size (XferSize)This field contains the transfer size
                                                         in bytes for the current endpoint. The transfer size (XferSize)
                                                          = Sum of buffer sizes across all descriptors in the list for
                                                          the endpoint.In Buffer DMA, the core only interrupts the application
                                                          after it has exhausted the transfer size amount of data. The
                                                          transfer size can be set to the maximum packet size of the endpoint,
                                                          to be interrupted at the end of each packet.- IN Endpoints:
                                                          The core decrements this field every time a packet from the
                                                          exter                                                                */
      __IO uint32_t  PktCnt     : 10;               /*!< Packet Count (PktCnt)Indicates the total number of USB packets
                                                         that constitute the Transfer Size amount of data for this endpoint
                                                          (PktCnt = XferSize / MPS). - IN Endpoints: This field is decremented
                                                          every time a packet (maximum size or short packet) is read from
                                                          the TxFIFO.- OUT Endpoints: This field is decremented every
                                                          time a packet (maximum size or short packet) is written to the
                                                          RxFIFO.                                                              */
      __I  uint32_t  RxDPID     :  2;               /*!< Received Data PID (RxDPID)Applies to isochronous OUT endpoints
                                                         only.This is the data PID received in the last packet for this
                                                          endpoint.- 2b00: DATA0- 2b01: DATA2- 2b10: DATA1- 2b11: MDATA        */
           uint32_t : 1; // padding
    } DOEPTSIZ1_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPDMA1;                        /*!< Device OUT Endpoint 1 DMA Address Register                            */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< Refer to the description of [DOEPDMA0].DMAAddr.                       */
    } DOEPDMA1_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED23[2];
  
  union {
    __IO uint32_t  DOEPCTL2;                        /*!< Device Control OUT Endpoint 2 Control Register                        */
    
    struct {
      __IO uint32_t  MPS        : 11;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  NextEp     :  4;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  USBActEP   :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  DPID       :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  NAKSts     :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  EPType     :  2;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  Snp        :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  Stall      :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
           uint32_t             :  4;
      __IO uint32_t  CNAK       :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  SNAK       :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  SetD0PID   :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  SetD1PID   :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  EPDis      :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  EPEna      :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
    } DOEPCTL2_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED24;
  
  union {
    __IO uint32_t  DOEPINT2;                        /*!< Device OUT Endpoint 2 Interrupt Register                              */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  EPDisbld   :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  AHBErr     :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  SetUp      :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  OUTTknEPdis:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  StsPhseRcvd:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  Back2BackSETup:  1;            /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t             :  2;
      __IO uint32_t  BNAIntr    :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  BbleErr    :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  NYETIntrpt :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  StupPktRcvd:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t : 16; // padding
    } DOEPINT2_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED25;
  
  union {
    __IO uint32_t  DOEPTSIZ2;                       /*!< Device OUT Endpoint 2 Transfer Size Register                          */
    
    struct {
      __IO uint32_t  XferSize   : 19;               /*!< Refer to the description of [DOEPSIZ1].XferSize.                      */
      __IO uint32_t  PktCnt     : 10;               /*!< Refer to the description of [DOEPSIZ1].PktCnt.                        */
      __I  uint32_t  RxDPID     :  2;               /*!< Refer to the description of [DOEPSIZ1].RxDPID.                        */
           uint32_t : 1; // padding
    } DOEPTSIZ2_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPDMA2;                        /*!< Device OUT Endpoint 2 DMA Address Register                            */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< Refer to the description of [DOEPDMA0].DMAAddr.                       */
    } DOEPDMA2_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED26[2];
  
  union {
    __IO uint32_t  DOEPCTL3;                        /*!< Device Control OUT Endpoint 3 Control Register                        */
    
    struct {
      __IO uint32_t  MPS        : 11;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  NextEp     :  4;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  USBActEP   :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  DPID       :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  NAKSts     :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __I  uint32_t  EPType     :  2;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  Snp        :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  Stall      :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
           uint32_t             :  4;
      __IO uint32_t  CNAK       :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  SNAK       :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  SetD0PID   :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  SetD1PID   :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  EPDis      :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
      __IO uint32_t  EPEna      :  1;               /*!< Refer to the description of the corresponding field in [DOEPCTL1].    */
    } DOEPCTL3_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED27;
  
  union {
    __IO uint32_t  DOEPINT3;                        /*!< Device OUT Endpoint 3 Interrupt Register                              */
    
    struct {
      __IO uint32_t  XferCompl  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  EPDisbld   :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  AHBErr     :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  SetUp      :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  OUTTknEPdis:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  StsPhseRcvd:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  Back2BackSETup:  1;            /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t             :  2;
      __IO uint32_t  BNAIntr    :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t             :  1;
      __IO uint32_t  PktDrpSts  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  BbleErr    :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  NAKIntrpt  :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  NYETIntrpt :  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
      __IO uint32_t  StupPktRcvd:  1;               /*!< Refer to the description of the corresponding field in [DOEPINT0].    */
           uint32_t : 16; // padding
    } DOEPINT3_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED28;
  
  union {
    __IO uint32_t  DOEPTSIZ3;                       /*!< Device OUT Endpoint 3 Transfer Size Register                          */
    
    struct {
      __IO uint32_t  XferSize   : 19;               /*!< Refer to the description of [DOEPSIZ1].XferSize.                      */
      __IO uint32_t  PktCnt     : 10;               /*!< Refer to the description of [DOEPSIZ1].PktCnt.                        */
      __I  uint32_t  RxDPID     :  2;               /*!< Refer to the description of [DOEPSIZ1].RxDPID.                        */
           uint32_t : 1; // padding
    } DOEPTSIZ3_b;                                  /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  DOEPDMA3;                        /*!< Device OUT Endpoint 3 DMA Address Register                            */
    
    struct {
      __IO uint32_t  DMAAddr    : 32;               /*!< Refer to the description of [DOEPDMA0].DMAAddr.                       */
    } DOEPDMA3_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED29[162];
  
  union {
    __IO uint32_t  PCGCCTL;                         /*!< Power and Clock Gating Control Register                               */
    
    struct {
      __IO uint32_t  StopPclk   :  1;               /*!< Stop Pclk (StopPclk)The application sets this bit to stop the
                                                         PHY clock (phy_clk) when the USB is suspended, the session is
                                                          not valid, or the device isdisconnected. The application clears
                                                          this bit when the USB is resumed or a new session starts.            */
      __IO uint32_t  GateHclk   :  1;               /*!< Gate Hclk (GateHclk)The application sets this bit to gate hclk
                                                         to modules other than the AHB Slave and Master and wakeup logic
                                                          when the USB is suspended or the session is not valid. The application
                                                          clears this bit when the USB is resumed or a new session starts.     */
      __IO uint32_t  PwrClmp    :  1;               /*!< Power Clamp (PwrClmp)This bit is valid only in Partial Power-Down
                                                         mode.The application sets this bit before the power is turned
                                                          off to clamp the signals between the power-on modules and the
                                                          power-off modules. The application clears the bit to disable
                                                          the clamping before the power is turned on.                          */
      __IO uint32_t  RstPdwnModule:  1;             /*!< Reset Power-Down Modules (RstPdwnModule)This bit is valid only
                                                         in Partial Power-Down mode. The application sets this bit when
                                                          the power is turned off. The application clears this bit after
                                                          the power is turned on and the PHY clock is up.Note: The read/write
                                                          of all core registers are possible only when this bit is set
                                                          to 1b0.                                                              */
           uint32_t             :  2;
      __I  uint32_t  PhySleep   :  1;               /*!< PHY in Sleep (PhySleep)This bit indicates that the PHY is in
                                                         the Sleep state.                                                      */
      __I  uint32_t  Suspended  :  1;               /*!< Deep Sleep (L1 Suspended)This bit indicates that the PHY is
                                                         in deep sleep when in L1 state.                                       */
           uint32_t : 24; // padding
    } PCGCCTL_b;                                    /*!< BitSize                                                               */
  };
} usb2fs_Type;


/* ================================================================================ */
/* ================                       fpu                      ================ */
/* ================================================================================ */


/**
  * @brief Floating Point system registers (fpu)
  */

typedef struct {                                    /*!< fpu Structure                                                         */
  
  union {
    __IO uint32_t  FPCCR;                           /*!< FP Context Control Register                                           */
    
    struct {
      __IO uint32_t  LSPACT     :  1;               /*!< 0 = Lazy state preservation is not active.1 = Lazy state preservation
                                                         is active. floating-point stack frame has been allocated but
                                                          saving state to it has been deferred.                                */
      __IO uint32_t  USER       :  1;               /*!< 0 = Privilege level was not user when the floating-point stack
                                                         frame was allocated.1 = Privilege level was user when the floating-point
                                                          stack frame was allocated.                                           */
           uint32_t             :  1;
      __IO uint32_t  THREAD     :  1;               /*!< 0 = Mode was not Thread Mode when the floating-point stack frame
                                                         was allocated.1 = Mode was Thread Mode when the floating-point
                                                          stack frame was allocated.                                           */
      __IO uint32_t  HFRDY      :  1;               /*!< 0 = Priority did not permit setting the HardFault handler to
                                                         the pending state when the floating-point stack frame was allocated.1
                                                          = Priority permitted setting the HardFault handler to the pending
                                                          state when the floating-point stack frame was allocated.             */
      __IO uint32_t  MMRDY      :  1;               /*!< 0 = MemManage is disabled or priority did not permit setting
                                                         the MemManage handler to the pending state when the floating-point
                                                          stack frame was allocated.1 = MemManage is enabled and priority
                                                          permitted setting the MemManage handler to the pending state
                                                          when the floating-point stack frame was allocated.                   */
      __IO uint32_t  BFRDY      :  1;               /*!< 0 = BusFault is disabled or priority did not permit setting
                                                         the BusFault handler to the pending state when the floating-point
                                                          stack frame was allocated.1 = BusFault is enabled and priority
                                                          permitted setting the BusFault handler to the pending state
                                                          when the floating-point stack frame was allocated.                   */
           uint32_t             :  1;
      __IO uint32_t  MONRDY     :  1;               /*!< 0 = DebugMonitor is disabled or priority did not permit setting
                                                         MON_PEND when the floating-point stack frame was allocated.1
                                                          = DebugMonitor is enabled and priority permits setting MON_PEND
                                                          when the floating-point stack frame was allocated.                   */
           uint32_t             : 21;
      __IO uint32_t  LSPEN      :  1;               /*!< 0 = Disable automatic lazy state preservation for floating-point
                                                         context.1 = Enable automatic lazy state preservation for floating-point
                                                          context.                                                             */
      __IO uint32_t  ASPEN      :  1;               /*!< Enables CONTROL<2> setting on execution of a floating-point
                                                         instruction. This results in automatic hardware state preservation
                                                          and restoration, for floating-point context, on exception entry
                                                          and exit.0 = Disable CONTROL<2> setting on execution of a floating-point
                                                          instruction.1 = Enable CONTROL<2> setting on execution of a
                                                          floating-point instruction.                                          */
    } FPCCR_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FPCAR;                           /*!< FP Context Address Register                                           */
    
    struct {
           uint32_t             :  3;
      __IO uint32_t  ADDRESS    : 29;               /*!< The location of the unpopulated floating-point register space
                                                         allocated on an exception stack frame.                                */
    } FPCAR_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  FPDSCR;                          /*!< FP Default Status Control Register                                    */
    
    struct {
           uint32_t             : 22;
      __IO uint32_t  RMode      :  2;               /*!< Default value for FPSCR.RMode                                         */
      __IO uint32_t  FZ         :  1;               /*!< Default value for FPSCR.FZ                                            */
      __IO uint32_t  DN         :  1;               /*!< Default value for FPSCR.DN                                            */
      __IO uint32_t  AHP        :  1;               /*!< Default value for FPSCR.AHP                                           */
           uint32_t : 5; // padding
    } FPDSCR_b;                                     /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  MVFR0;                           /*!< Media and VFP Feature Register 0                                      */
    
    struct {
      __I  uint32_t  MVFR0      : 32;               /*!< Media and VFP Feature Register 0                                      */
    } MVFR0_b;                                      /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  MVFR1;                           /*!< Media and VFP Feature Register 1                                      */
    
    struct {
      __I  uint32_t  MVFR1      : 32;               /*!< Media and VFP Feature Register 1                                      */
    } MVFR1_b;                                      /*!< BitSize                                                               */
  };
} fpu_Type;


/* --------------------  End of section using anonymous unions  ------------------- */
#if defined(__CC_ARM)
  #pragma pop
#elif defined(__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning restore
#else
  #warning Not supported compiler type
#endif




/* ================================================================================ */
/* ================              Peripheral memory map             ================ */
/* ================================================================================ */

#define mpier_BASE                      0x00100000UL
#define PERI_BASE                       0x40000000UL
#define pmulv_BASE                      0x40000000UL
#define spic_BASE                       0x40004000UL
#define sdmac_BASE                      0x40005000UL
#define rng_BASE                        0x40021000UL
#define sramc_BASE                      0x40022000UL
#define evm_BASE                        0x40023000UL
#define rtclv_BASE                      0x40040000UL
#define advtmr_BASE                     0x40041000UL
#define tmr_BASE                        0x40042000UL
#define wdt_BASE                        0x40043000UL
#define i2c2_BASE                       0x40044000UL
#define spim2_BASE                      0x40046000UL
#define spim3_BASE                      0x40047000UL
#define adcc12_BASE                     0x40048000UL
#define adcc24_BASE                     0x40049000UL
#define gconf_BASE                      0x4004A000UL
#define gpio0_BASE                      0x4004B000UL
#define gpio1_BASE                      0x4004C000UL
#define gpio2_BASE                      0x4004D000UL
#define gpio3_BASE                      0x4004E000UL
#define spim0_BASE                      0x40060000UL
#define spim1_BASE                      0x40061000UL
#define i2c0_BASE                       0x40062000UL
#define i2c1_BASE                       0x40063000UL
#define uart0_BASE                      0x40064000UL
#define uart1_BASE                      0x40065000UL
#define uart2_BASE                      0x40070000UL
#define usb2fs_BASE                     0x40080000UL
#define fpu_BASE                        0xE000EF34UL


/* ================================================================================ */
/* ================             Peripheral declaration             ================ */
/* ================================================================================ */

#define mpier                           ((mpier_Type              *) mpier_BASE)
#define pmulv                           ((pmulv_Type              *) pmulv_BASE)
#define spic                            ((spic_Type               *) spic_BASE)
#define sdmac                           ((sdmac_Type              *) sdmac_BASE)
#define rng                             ((rng_Type                *) rng_BASE)
#define sramc                           ((sramc_Type              *) sramc_BASE)
#define evm                             ((evm_Type                *) evm_BASE)
#define rtclv                           ((rtclv_Type              *) rtclv_BASE)
#define advtmr                          ((advtmr_Type             *) advtmr_BASE)
#define tmr                             ((tmr_Type                *) tmr_BASE)
#define wdt                             ((wdt_Type                *) wdt_BASE)
#define i2c2                            ((i2c_Type                *) i2c2_BASE)
#define spim2                           ((spim_Type               *) spim2_BASE)
#define spim3                           ((spim_Type               *) spim3_BASE)
#define adcc12                          ((adcc12_Type             *) adcc12_BASE)
#define adcc24                          ((adcc24_Type             *) adcc24_BASE)
#define gconf                           ((gconf_Type              *) gconf_BASE)
#define gpio0                           ((gpio_Type               *) gpio0_BASE)
#define gpio1                           ((gpio_Type               *) gpio1_BASE)
#define gpio2                           ((gpio_Type               *) gpio2_BASE)
#define gpio3                           ((gpio_Type               *) gpio3_BASE)
#define spim0                           ((spim_Type               *) spim0_BASE)
#define spim1                           ((spim_Type               *) spim1_BASE)
#define i2c0                            ((i2c_Type                *) i2c0_BASE)
#define i2c1                            ((i2c_Type                *) i2c1_BASE)
#define uart0                           ((uart_Type               *) uart0_BASE)
#define uart1                           ((uart_Type               *) uart1_BASE)
#define uart2                           ((uart_Type               *) uart2_BASE)
#define usb2fs                          ((usb2fs_Type             *) usb2fs_BASE)
#define fpu                             ((fpu_Type                *) fpu_BASE)


/* ================================================================================ */
/* ============== Bit-Band for Device Specific Peripheral Registers =============== */
/* ================================================================================ */

#define BITBAND_OFFSET                  0x02000000UL
#define BITBAND_PERI_BASE               (PERI_BASE + BITBAND_OFFSET)
#define BITBAND_PERI(addr, bitnum)      (BITBAND_PERI_BASE + (((uint32_t)(addr) - PERI_BASE) << 5) + ((uint32_t)(bitnum) << 2))
#define BITBAND_VALUE(addr, bitnum)     (*((__IO  uint32_t *)BITBAND_PERI(addr,bitnum)))


/** @} */ /* End of group Device_Peripheral_Registers */

/* ================================================================================ */
/* ==============                      Modifiers                    =============== */
/* ================================================================================ */

#if   defined ( __CC_ARM )
#define TZ1K_INLINE      __inline
#define TZ1K_PACKED_HDR
#define TZ1K_PACKED_FTR  __attribute__((packed))
#define TZ1K_ALIGNED(x)  __attribute__((aligned x))
#elif defined ( __ICCARM__ )
#define TZ1K_INLINE      inline
#define TZ1K_PACKED_HDR  __packed
#define TZ1K_PACKED_FTR
#define TZ1K_ALIGNED(x)
#elif defined ( __GNUC__ )
#define TZ1K_INLINE      __inline
#define TZ1K_PACKED_HDR
#define TZ1K_PACKED_FTR  __attribute__((packed))
#define TZ1K_ALIGNED(x)  __attribute__((aligned x))
#endif


/** @} */ /* End of group TZ10xx */
/** @} */ /* End of group (null) */

#ifdef __cplusplus
}
#endif


#endif  /* TZ10xx_H */

